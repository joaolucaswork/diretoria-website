"use strict";
(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key2 of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key2) && key2 !== except)
          __defProp(to, key2, { get: () => from[key2], enumerable: !(desc = __getOwnPropDesc(from, key2)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // bin/live-reload.js
  var init_live_reload = __esm({
    "bin/live-reload.js"() {
      "use strict";
      new EventSource(`${"http://localhost:3000"}/esbuild`).addEventListener("change", () => location.reload());
    }
  });

  // node_modules/.pnpm/sticksy@0.2.0/node_modules/sticksy/src/sticksy.js
  var require_sticksy = __commonJS({
    "node_modules/.pnpm/sticksy@0.2.0/node_modules/sticksy/src/sticksy.js"() {
      init_live_reload();
      window.Sticksy = function() {
        "use strict";
        var States = {
          STATIC: "static",
          FIXED: "fixed",
          STUCK: "stuck"
        };
        function Sticksy2(target, options) {
          if (!target)
            throw new Error("You have to specify the target element");
          if (typeof target !== "string" && !(target instanceof Element))
            throw new Error(
              "Expected a string or element, but got: " + Object.prototype.toString.call(target)
            );
          var targetEl = Utils.findElement(target);
          if (!targetEl)
            throw new Error("Cannot find target element: " + target);
          var containerEl = targetEl.parentNode;
          if (!containerEl)
            throw new Error("Cannot find container of target element: " + target);
          options = options || {};
          this._props = {
            containerEl,
            targetEl,
            topSpacing: options.topSpacing || 0,
            enabled: options.enabled || true,
            listen: options.listen || false
            // listen for the DOM changes in the container
          };
          this.onStateChanged = null;
          this.nodeRef = targetEl;
          this._initialize();
        }
        Sticksy2.instances = [];
        Sticksy2.enabledInstances = [];
        Sticksy2.prototype._initialize = function() {
          var that = this;
          this.state = States.STATIC;
          this._stickyNodes = [];
          this._dummyNodes = [];
          var sibling = this._props.targetEl;
          while (sibling) {
            var clone = sibling.cloneNode(true);
            clone.style.visibility = "hidden";
            clone.style.pointerEvents = "none";
            clone.className += " sticksy-dummy-node";
            clone.removeAttribute("id");
            this._props.targetEl.parentNode.insertBefore(clone, this._props.targetEl);
            this._stickyNodes.push(sibling);
            this._dummyNodes.push(clone);
            sibling = sibling.nextElementSibling;
          }
          this._stickyNodesHeight = 0;
          this._limits = {
            top: 0,
            bottom: 0
          };
          this._isListening = false;
          this._props.containerEl.style.position = "relative";
          this._shouldCollapseMargins = getComputedStyle(this._props.containerEl).display.indexOf("flex") === -1;
          if (this._props.listen) {
            this._mutationObserver = new MutationObserver(function() {
              that.hardRefresh();
            });
            this._startListen();
          }
          Sticksy2.instances.push(this);
          if (this._props.enabled) {
            Sticksy2.enabledInstances.push(this);
          }
          this.hardRefresh();
        };
        Sticksy2.prototype._startListen = function() {
          if (!this._props.listen || this._isListening)
            return;
          this._mutationObserver.observe(this._props.containerEl, {
            attributes: true,
            characterData: true,
            childList: true,
            subtree: true
          });
          this._isListening = true;
        };
        Sticksy2.prototype._stopListen = function() {
          if (!this._props.listen || !this._isListening)
            return;
          this._mutationObserver.disconnect();
          this._isListening = false;
        };
        Sticksy2.prototype._calcState = function(windowOffset) {
          if (windowOffset < this._limits.top) {
            return States.STATIC;
          } else if (windowOffset >= this._limits.bottom) {
            return States.STUCK;
          }
          return States.FIXED;
        };
        Sticksy2.prototype._updateStickyNodesHeight = function() {
          this._stickyNodesHeight = Utils.getComputedBox(this._stickyNodes[this._stickyNodes.length - 1]).bottomWithMargin - Utils.getComputedBox(this._stickyNodes[0]).topWithMargin;
        };
        Sticksy2.prototype._updateLimits = function() {
          var containerEl = this._props.containerEl, stickyNodes = this._stickyNodes;
          var containerBox = Utils.getComputedBox(containerEl), topNodeBox = Utils.getComputedBox(stickyNodes[0]);
          this._limits = {
            top: topNodeBox.topWithMargin - this._props.topSpacing,
            bottom: containerBox.bottom - containerBox.paddingBottom - this._props.topSpacing - this._stickyNodesHeight
          };
        };
        Sticksy2.prototype._applyState = function(state) {
          if (state === States.STATIC) {
            this._resetElements(this._stickyNodes);
            this._disableElements(this._dummyNodes);
          } else {
            this._fixElementsSize(this._stickyNodes);
            if (state === States.FIXED) {
              this._fixElements(this._stickyNodes);
            } else {
              this._stuckElements(this._stickyNodes);
            }
            this._enableElements(this._dummyNodes);
          }
        };
        Sticksy2.prototype.refresh = function() {
          var state = this._calcState(window.pageYOffset, this._limits);
          if (state === this.state)
            return;
          this.state = state;
          this._stopListen();
          this._applyState(state);
          this._startListen();
          if (typeof this.onStateChanged === "function") {
            this.onStateChanged(state);
          }
        };
        Sticksy2.prototype.hardRefresh = function() {
          this._stopListen();
          var oldState = this.state;
          this.state = States.STATIC;
          this._applyState(this.state);
          this._fixElementsSize(this._stickyNodes);
          this._updateStickyNodesHeight();
          this._updateLimits();
          this.state = this._calcState(window.pageYOffset, this._limits);
          this._applyState(this.state);
          this._startListen();
          if (typeof this.onStateChanged === "function" && oldState !== this.state) {
            this.onStateChanged(this.state);
          }
        };
        Sticksy2.prototype.enable = function() {
          this._props.enabled = true;
          Sticksy2.enabledInstances.push(this);
          this.hardRefresh();
        };
        Sticksy2.prototype.disable = function() {
          this._props.enabled = false;
          this.state = States.STATIC;
          this._applyState(this.state);
          Sticksy2.enabledInstances.splice(Sticksy2.enabledInstances.indexOf(this), 1);
        };
        Sticksy2.prototype._fixElements = function(elements) {
          var previousMarginBottom = 0;
          var offset2 = this._props.topSpacing;
          for (var i5 = 0; i5 < elements.length; i5++) {
            var el = elements[i5];
            var box = Utils.getComputedBox(el);
            var extraMarginTop = this._shouldCollapseMargins ? Math.max(0, previousMarginBottom - box.marginTop) : previousMarginBottom;
            el.style.position = "fixed";
            el.style.top = offset2 + extraMarginTop + "px";
            el.style.bottom = "";
            offset2 += box.height + box.marginTop + extraMarginTop;
            previousMarginBottom = box.marginBottom;
          }
        };
        Sticksy2.prototype._stuckElements = function(elements) {
          var previousMarginTop = 0;
          var offset2 = Utils.getComputedBox(this._props.containerEl).paddingBottom;
          for (var i5 = elements.length - 1; i5 >= 0; i5--) {
            var el = elements[i5];
            var box = Utils.getComputedBox(el);
            var extraMarginBottom = this._shouldCollapseMargins ? Math.max(0, previousMarginTop - box.marginBottom) : previousMarginTop;
            el.style.position = "absolute";
            el.style.top = "auto";
            el.style.bottom = offset2 + extraMarginBottom + "px";
            offset2 += box.height + box.marginBottom + extraMarginBottom;
            previousMarginTop = box.marginTop;
          }
        };
        Sticksy2.prototype._resetElements = function(elements) {
          elements.forEach(function(el) {
            el.style.position = "";
            el.style.top = "";
            el.style.bottom = "";
            el.style.height = "";
            el.style.width = "";
          });
        };
        Sticksy2.prototype._disableElements = function(elements) {
          elements.forEach(function(el) {
            el.style.display = "none";
          });
        };
        Sticksy2.prototype._enableElements = function(elements) {
          for (var i5 = 0; i5 < elements.length; i5++) {
            elements[i5].style.display = getComputedStyle(this._stickyNodes[i5]).display;
          }
        };
        Sticksy2.prototype._fixElementsSize = function() {
          for (var i5 = 0; i5 < this._stickyNodes.length; i5++) {
            var stickyNode = this._stickyNodes[i5];
            var style = getComputedStyle(stickyNode);
            stickyNode.style.width = style.width;
            stickyNode.style.height = style.height;
          }
        };
        Sticksy2.refreshAll = function() {
          for (var i5 = 0; i5 < Sticksy2.enabledInstances.length; i5++) {
            Sticksy2.enabledInstances[i5].refresh();
          }
        };
        Sticksy2.hardRefreshAll = function() {
          for (var i5 = 0; i5 < Sticksy2.enabledInstances.length; i5++) {
            Sticksy2.enabledInstances[i5].hardRefresh();
          }
        };
        Sticksy2.enableAll = function() {
          Sticksy2.enabledInstances = Sticksy2.instances.slice();
          this.hardRefreshAll();
        };
        Sticksy2.disableAll = function() {
          var copy = Sticksy2.enabledInstances.slice();
          for (var i5 = 0; i5 < copy.length; i5++) {
            Sticksy2.enabledInstances[i5].disable();
          }
          Sticksy2.enabledInstances = [];
        };
        Sticksy2.initializeAll = function(target, options, ignoreNothingFound) {
          if (typeof target === "undefined")
            throw new Error("'target' parameter is undefined");
          var elements = [];
          if (target instanceof Element) {
            elements = [target];
          } else if (typeof target.length !== "undefined" && target.length > 0 && target[0] instanceof Element) {
            elements = typeof target.get === "function" ? target.get() : target;
          } else if (typeof target === "string") {
            elements = document.querySelectorAll(target) || [];
          }
          var parents = [];
          var stickyElements = [];
          elements.forEach(function(el) {
            if (parents.indexOf(el.parentNode) !== -1)
              return;
            parents.push(el.parentNode);
            stickyElements.push(el);
          });
          if (!ignoreNothingFound && !stickyElements.length)
            throw new Error("There are no elements to initialize");
          return stickyElements.map(function(el) {
            return new Sticksy2(el, options);
          });
        };
        window.addEventListener("scroll", Sticksy2.refreshAll);
        window.addEventListener("resize", Sticksy2.hardRefreshAll);
        var Utils = {
          parseNumber: function(val) {
            return parseFloat(val) || 0;
          },
          findElement: function(el, root2) {
            if (!root2)
              root2 = document;
            return "string" === typeof el ? root2.querySelector(el) : el instanceof Element ? el : void 0;
          },
          getComputedBox: function(elem) {
            var box = elem.getBoundingClientRect();
            var style = getComputedStyle(elem);
            return {
              height: box.height,
              width: box.width,
              top: window.pageYOffset + box.top,
              bottom: window.pageYOffset + box.bottom,
              marginTop: Utils.parseNumber(style.marginTop),
              marginBottom: Utils.parseNumber(style.marginBottom),
              paddingTop: Utils.parseNumber(style.paddingTop),
              paddingBottom: Utils.parseNumber(style.paddingBottom),
              topWithMargin: window.pageYOffset + box.top - Utils.parseNumber(style.marginTop),
              bottomWithMargin: window.pageYOffset + box.bottom + Utils.parseNumber(style.marginBottom)
            };
          }
        };
        return Sticksy2;
      }();
      var jQueryPlugin = window.$ || window.jQuery || window.Zepto;
      if (jQueryPlugin) {
        jQueryPlugin.fn.sticksy = function sticksyPlugin(opts) {
          return window.Sticksy.initializeAll(this, opts);
        };
      }
    }
  });

  // node_modules/.pnpm/sticksy@0.2.0/node_modules/sticksy/index.js
  var require_sticksy2 = __commonJS({
    "node_modules/.pnpm/sticksy@0.2.0/node_modules/sticksy/index.js"(exports, module) {
      init_live_reload();
      module.exports = require_sticksy();
    }
  });

  // node_modules/.pnpm/dragdealer@0.10.0/node_modules/dragdealer/src/dragdealer.js
  var require_dragdealer = __commonJS({
    "node_modules/.pnpm/dragdealer@0.10.0/node_modules/dragdealer/src/dragdealer.js"(exports, module) {
      init_live_reload();
      (function(root2, factory) {
        if (typeof define === "function" && define.amd) {
          define(factory);
        } else if (typeof module === "object" && module.exports) {
          module.exports.Dragdealer = factory();
        } else {
          root2.Dragdealer = factory();
        }
      })(exports, function() {
        var Dragdealer2 = function(wrapper, options) {
          this.options = this.applyDefaults(options || {});
          this.bindMethods();
          this.wrapper = this.getWrapperElement(wrapper);
          if (!this.wrapper) {
            return;
          }
          this.handle = this.getHandleElement(this.wrapper, this.options.handleClass);
          if (!this.handle) {
            return;
          }
          this.init();
          this.bindEventListeners();
        };
        Dragdealer2.prototype = {
          defaults: {
            disabled: false,
            horizontal: true,
            vertical: false,
            slide: true,
            steps: 0,
            snap: false,
            loose: false,
            speed: 0.1,
            xPrecision: 0,
            yPrecision: 0,
            handleClass: "handle",
            css3: true,
            activeClass: "active",
            tapping: true
          },
          init: function() {
            if (this.options.css3) {
              triggerWebkitHardwareAcceleration(this.handle);
            }
            this.value = {
              prev: [-1, -1],
              current: [this.options.x || 0, this.options.y || 0],
              target: [this.options.x || 0, this.options.y || 0]
            };
            this.offset = {
              wrapper: [0, 0],
              mouse: [0, 0],
              prev: [-999999, -999999],
              current: [0, 0],
              target: [0, 0]
            };
            this.dragStartPosition = { x: 0, y: 0 };
            this.change = [0, 0];
            this.stepRatios = this.calculateStepRatios();
            this.activity = false;
            this.dragging = false;
            this.tapping = false;
            this.reflow();
            if (this.options.disabled) {
              this.disable();
            }
          },
          applyDefaults: function(options) {
            for (var k2 in this.defaults) {
              if (!options.hasOwnProperty(k2)) {
                options[k2] = this.defaults[k2];
              }
            }
            return options;
          },
          getWrapperElement: function(wrapper) {
            if (typeof wrapper == "string") {
              return document.getElementById(wrapper);
            } else {
              return wrapper;
            }
          },
          getHandleElement: function(wrapper, handleClass) {
            var childElements, handleClassMatcher, i5;
            if (wrapper.getElementsByClassName) {
              childElements = wrapper.getElementsByClassName(handleClass);
              if (childElements.length > 0) {
                return childElements[0];
              }
            } else {
              handleClassMatcher = new RegExp("(^|\\s)" + handleClass + "(\\s|$)");
              childElements = wrapper.getElementsByTagName("*");
              for (i5 = 0; i5 < childElements.length; i5++) {
                if (handleClassMatcher.test(childElements[i5].className)) {
                  return childElements[i5];
                }
              }
            }
          },
          calculateStepRatios: function() {
            var stepRatios = [];
            if (this.options.steps >= 1) {
              for (var i5 = 0; i5 <= this.options.steps - 1; i5++) {
                if (this.options.steps > 1) {
                  stepRatios[i5] = i5 / (this.options.steps - 1);
                } else {
                  stepRatios[i5] = 0;
                }
              }
            }
            return stepRatios;
          },
          setWrapperOffset: function() {
            this.offset.wrapper = Position.get(this.wrapper);
          },
          calculateBounds: function() {
            var bounds = {
              top: this.options.top || 0,
              bottom: -(this.options.bottom || 0) + this.wrapper.offsetHeight,
              left: this.options.left || 0,
              right: -(this.options.right || 0) + this.wrapper.offsetWidth
            };
            bounds.availWidth = bounds.right - bounds.left - this.handle.offsetWidth;
            bounds.availHeight = bounds.bottom - bounds.top - this.handle.offsetHeight;
            return bounds;
          },
          calculateValuePrecision: function() {
            var xPrecision = this.options.xPrecision || Math.abs(this.bounds.availWidth), yPrecision = this.options.yPrecision || Math.abs(this.bounds.availHeight);
            return [
              xPrecision ? 1 / xPrecision : 0,
              yPrecision ? 1 / yPrecision : 0
            ];
          },
          bindMethods: function() {
            if (typeof this.options.customRequestAnimationFrame === "function") {
              this.requestAnimationFrame = bind(this.options.customRequestAnimationFrame, window);
            } else {
              this.requestAnimationFrame = bind(requestAnimationFrame2, window);
            }
            if (typeof this.options.customCancelAnimationFrame === "function") {
              this.cancelAnimationFrame = bind(this.options.customCancelAnimationFrame, window);
            } else {
              this.cancelAnimationFrame = bind(cancelAnimationFrame2, window);
            }
            this.animateWithRequestAnimationFrame = bind(this.animateWithRequestAnimationFrame, this);
            this.animate = bind(this.animate, this);
            this.onHandleMouseDown = bind(this.onHandleMouseDown, this);
            this.onHandleTouchStart = bind(this.onHandleTouchStart, this);
            this.onDocumentMouseMove = bind(this.onDocumentMouseMove, this);
            this.onWrapperTouchMove = bind(this.onWrapperTouchMove, this);
            this.onWrapperMouseDown = bind(this.onWrapperMouseDown, this);
            this.onWrapperTouchStart = bind(this.onWrapperTouchStart, this);
            this.onDocumentMouseUp = bind(this.onDocumentMouseUp, this);
            this.onDocumentTouchEnd = bind(this.onDocumentTouchEnd, this);
            this.onHandleClick = bind(this.onHandleClick, this);
            this.onWindowResize = bind(this.onWindowResize, this);
          },
          bindEventListeners: function() {
            addEventListener2(this.handle, "mousedown", this.onHandleMouseDown);
            addEventListener2(this.handle, "touchstart", this.onHandleTouchStart);
            addEventListener2(document, "mousemove", this.onDocumentMouseMove);
            addEventListener2(this.wrapper, "touchmove", this.onWrapperTouchMove);
            addEventListener2(this.wrapper, "mousedown", this.onWrapperMouseDown);
            addEventListener2(this.wrapper, "touchstart", this.onWrapperTouchStart);
            addEventListener2(document, "mouseup", this.onDocumentMouseUp);
            addEventListener2(document, "touchend", this.onDocumentTouchEnd);
            addEventListener2(this.handle, "click", this.onHandleClick);
            addEventListener2(window, "resize", this.onWindowResize);
            this.animate(false, true);
            this.interval = this.requestAnimationFrame(this.animateWithRequestAnimationFrame);
          },
          unbindEventListeners: function() {
            removeEventListener2(this.handle, "mousedown", this.onHandleMouseDown);
            removeEventListener2(this.handle, "touchstart", this.onHandleTouchStart);
            removeEventListener2(document, "mousemove", this.onDocumentMouseMove);
            removeEventListener2(this.wrapper, "touchmove", this.onWrapperTouchMove);
            removeEventListener2(this.wrapper, "mousedown", this.onWrapperMouseDown);
            removeEventListener2(this.wrapper, "touchstart", this.onWrapperTouchStart);
            removeEventListener2(document, "mouseup", this.onDocumentMouseUp);
            removeEventListener2(document, "touchend", this.onDocumentTouchEnd);
            removeEventListener2(this.handle, "click", this.onHandleClick);
            removeEventListener2(window, "resize", this.onWindowResize);
            this.cancelAnimationFrame(this.interval);
          },
          onHandleMouseDown: function(e8) {
            Cursor.refresh(e8);
            preventEventDefaults(e8);
            stopEventPropagation(e8);
            this.activity = false;
            this.startDrag();
          },
          onHandleTouchStart: function(e8) {
            Cursor.refresh(e8);
            stopEventPropagation(e8);
            this.activity = false;
            this.startDrag();
          },
          onDocumentMouseMove: function(e8) {
            if (e8.clientX - this.dragStartPosition.x === 0 && e8.clientY - this.dragStartPosition.y === 0) {
              return;
            }
            Cursor.refresh(e8);
            if (this.dragging) {
              this.activity = true;
              preventEventDefaults(e8);
            }
          },
          onWrapperTouchMove: function(e8) {
            Cursor.refresh(e8);
            if (!this.activity && this.draggingOnDisabledAxis()) {
              if (this.dragging) {
                this.stopDrag();
              }
              return;
            }
            preventEventDefaults(e8);
            this.activity = true;
          },
          onWrapperMouseDown: function(e8) {
            Cursor.refresh(e8);
            preventEventDefaults(e8);
            this.startTap();
          },
          onWrapperTouchStart: function(e8) {
            Cursor.refresh(e8);
            preventEventDefaults(e8);
            this.startTap();
          },
          onDocumentMouseUp: function(e8) {
            this.stopDrag();
            this.stopTap();
          },
          onDocumentTouchEnd: function(e8) {
            this.stopDrag();
            this.stopTap();
          },
          onHandleClick: function(e8) {
            if (this.activity) {
              preventEventDefaults(e8);
              stopEventPropagation(e8);
            }
          },
          onWindowResize: function(e8) {
            this.reflow();
          },
          enable: function() {
            this.disabled = false;
            this.handle.className = this.handle.className.replace(/\s?disabled/g, "");
          },
          disable: function() {
            this.disabled = true;
            this.handle.className += " disabled";
          },
          reflow: function() {
            this.setWrapperOffset();
            this.bounds = this.calculateBounds();
            this.valuePrecision = this.calculateValuePrecision();
            this.updateOffsetFromValue();
          },
          getStep: function() {
            return [
              this.getStepNumber(this.value.target[0]),
              this.getStepNumber(this.value.target[1])
            ];
          },
          getStepWidth: function() {
            return Math.abs(this.bounds.availWidth / this.options.steps);
          },
          getValue: function() {
            return this.value.target;
          },
          setStep: function(x3, y2, snap3) {
            this.setValue(
              this.options.steps && x3 > 1 ? (x3 - 1) / (this.options.steps - 1) : 0,
              this.options.steps && y2 > 1 ? (y2 - 1) / (this.options.steps - 1) : 0,
              snap3
            );
          },
          setValue: function(x3, y2, snap3) {
            this.setTargetValue([x3, y2 || 0]);
            if (snap3) {
              this.groupCopy(this.value.current, this.value.target);
              this.updateOffsetFromValue();
              this.callAnimationCallback();
            }
          },
          startTap: function() {
            if (this.disabled || !this.options.tapping) {
              return;
            }
            this.tapping = true;
            this.setWrapperOffset();
            if (this.options.snap && this.options.steps) {
              var cursorXRatio = (Cursor.x - this.offset.wrapper[0]) / this.bounds.availWidth;
              var cursorYRatio = (Cursor.y - this.offset.wrapper[1]) / this.bounds.availHeight;
              this.setValue(this.getClosestStep(cursorXRatio), this.getClosestStep(cursorYRatio), true);
            } else {
              this.setTargetValueByOffset([
                Cursor.x - this.offset.wrapper[0] - this.handle.offsetWidth / 2,
                Cursor.y - this.offset.wrapper[1] - this.handle.offsetHeight / 2
              ]);
            }
          },
          stopTap: function() {
            if (this.disabled || !this.tapping) {
              return;
            }
            this.tapping = false;
            this.setTargetValue(this.value.current);
          },
          startDrag: function() {
            if (this.disabled) {
              return;
            }
            this.dragging = true;
            this.setWrapperOffset();
            this.dragStartPosition = { x: Cursor.x, y: Cursor.y };
            this.offset.mouse = [
              Cursor.x - Position.get(this.handle)[0],
              Cursor.y - Position.get(this.handle)[1]
            ];
            if (!this.wrapper.className.match(this.options.activeClass)) {
              this.wrapper.className += " " + this.options.activeClass;
            }
            this.callDragStartCallback();
          },
          stopDrag: function() {
            if (this.disabled || !this.dragging) {
              return;
            }
            this.dragging = false;
            var deltaX = this.bounds.availWidth === 0 ? 0 : (Cursor.x - this.dragStartPosition.x) / this.bounds.availWidth, deltaY = this.bounds.availHeight === 0 ? 0 : (Cursor.y - this.dragStartPosition.y) / this.bounds.availHeight, delta = [deltaX, deltaY];
            var target = this.groupClone(this.value.current);
            if (this.options.slide) {
              var ratioChange = this.change;
              target[0] += ratioChange[0] * 4;
              target[1] += ratioChange[1] * 4;
            }
            this.setTargetValue(target);
            this.wrapper.className = this.wrapper.className.replace(" " + this.options.activeClass, "");
            this.callDragStopCallback(delta);
          },
          callAnimationCallback: function() {
            var value = this.value.current;
            if (this.options.snap && this.options.steps > 1) {
              value = this.getClosestSteps(value);
            }
            if (!this.groupCompare(value, this.value.prev)) {
              if (typeof this.options.animationCallback == "function") {
                this.options.animationCallback.call(this, value[0], value[1]);
              }
              this.groupCopy(this.value.prev, value);
            }
          },
          callTargetCallback: function() {
            if (typeof this.options.callback == "function") {
              this.options.callback.call(this, this.value.target[0], this.value.target[1]);
            }
          },
          callDragStartCallback: function() {
            if (typeof this.options.dragStartCallback == "function") {
              this.options.dragStartCallback.call(this, this.value.target[0], this.value.target[1]);
            }
          },
          callDragStopCallback: function(delta) {
            if (typeof this.options.dragStopCallback == "function") {
              this.options.dragStopCallback.call(this, this.value.target[0], this.value.target[1], delta);
            }
          },
          animateWithRequestAnimationFrame: function(time) {
            if (time) {
              this.timeOffset = this.timeStamp ? time - this.timeStamp : 0;
              this.timeStamp = time;
            } else {
              this.timeOffset = 25;
            }
            this.animate();
            this.interval = this.requestAnimationFrame(this.animateWithRequestAnimationFrame);
          },
          animate: function(direct, first) {
            if (direct && !this.dragging) {
              return;
            }
            if (this.dragging) {
              var prevTarget = this.groupClone(this.value.target);
              var offset2 = [
                Cursor.x - this.offset.wrapper[0] - this.offset.mouse[0],
                Cursor.y - this.offset.wrapper[1] - this.offset.mouse[1]
              ];
              this.setTargetValueByOffset(offset2, this.options.loose);
              this.change = [
                this.value.target[0] - prevTarget[0],
                this.value.target[1] - prevTarget[1]
              ];
            }
            if (this.dragging || first) {
              this.groupCopy(this.value.current, this.value.target);
            }
            if (this.dragging || this.glide() || first) {
              this.updateOffsetFromValue();
              this.callAnimationCallback();
            }
          },
          glide: function() {
            var diff = [
              this.value.target[0] - this.value.current[0],
              this.value.target[1] - this.value.current[1]
            ];
            if (!diff[0] && !diff[1]) {
              return false;
            }
            if (Math.abs(diff[0]) > this.valuePrecision[0] || Math.abs(diff[1]) > this.valuePrecision[1]) {
              this.value.current[0] += diff[0] * Math.min(this.options.speed * this.timeOffset / 25, 1);
              this.value.current[1] += diff[1] * Math.min(this.options.speed * this.timeOffset / 25, 1);
            } else {
              this.groupCopy(this.value.current, this.value.target);
            }
            return true;
          },
          updateOffsetFromValue: function() {
            if (!this.options.snap) {
              this.offset.current = this.getOffsetsByRatios(this.value.current);
            } else {
              this.offset.current = this.getOffsetsByRatios(
                this.getClosestSteps(this.value.current)
              );
            }
            if (!this.groupCompare(this.offset.current, this.offset.prev)) {
              this.renderHandlePosition();
              this.groupCopy(this.offset.prev, this.offset.current);
            }
          },
          renderHandlePosition: function() {
            var transform = "";
            if (this.options.css3 && StylePrefix.transform) {
              if (this.options.horizontal) {
                transform += "translateX(" + this.offset.current[0] + "px)";
              }
              if (this.options.vertical) {
                transform += " translateY(" + this.offset.current[1] + "px)";
              }
              this.handle.style[StylePrefix.transform] = transform;
              return;
            }
            if (this.options.horizontal) {
              this.handle.style.left = this.offset.current[0] + "px";
            }
            if (this.options.vertical) {
              this.handle.style.top = this.offset.current[1] + "px";
            }
          },
          setTargetValue: function(value, loose) {
            var target = loose ? this.getLooseValue(value) : this.getProperValue(value);
            this.groupCopy(this.value.target, target);
            this.offset.target = this.getOffsetsByRatios(target);
            this.callTargetCallback();
          },
          setTargetValueByOffset: function(offset2, loose) {
            var value = this.getRatiosByOffsets(offset2);
            var target = loose ? this.getLooseValue(value) : this.getProperValue(value);
            this.groupCopy(this.value.target, target);
            this.offset.target = this.getOffsetsByRatios(target);
          },
          getLooseValue: function(value) {
            var proper = this.getProperValue(value);
            return [
              proper[0] + (value[0] - proper[0]) / 4,
              proper[1] + (value[1] - proper[1]) / 4
            ];
          },
          getProperValue: function(value) {
            var proper = this.groupClone(value);
            proper[0] = Math.max(proper[0], 0);
            proper[1] = Math.max(proper[1], 0);
            proper[0] = Math.min(proper[0], 1);
            proper[1] = Math.min(proper[1], 1);
            if (!this.dragging && !this.tapping || this.options.snap) {
              if (this.options.steps > 1) {
                proper = this.getClosestSteps(proper);
              }
            }
            return proper;
          },
          getRatiosByOffsets: function(group) {
            return [
              this.getRatioByOffset(group[0], this.bounds.availWidth, this.bounds.left),
              this.getRatioByOffset(group[1], this.bounds.availHeight, this.bounds.top)
            ];
          },
          getRatioByOffset: function(offset2, range, padding) {
            return range ? (offset2 - padding) / range : 0;
          },
          getOffsetsByRatios: function(group) {
            return [
              this.getOffsetByRatio(group[0], this.bounds.availWidth, this.bounds.left),
              this.getOffsetByRatio(group[1], this.bounds.availHeight, this.bounds.top)
            ];
          },
          getOffsetByRatio: function(ratio, range, padding) {
            return Math.round(ratio * range) + padding;
          },
          getStepNumber: function(value) {
            return this.getClosestStep(value) * (this.options.steps - 1) + 1;
          },
          getClosestSteps: function(group) {
            return [
              this.getClosestStep(group[0]),
              this.getClosestStep(group[1])
            ];
          },
          getClosestStep: function(value) {
            var k2 = 0;
            var min2 = 1;
            for (var i5 = 0; i5 <= this.options.steps - 1; i5++) {
              if (Math.abs(this.stepRatios[i5] - value) < min2) {
                min2 = Math.abs(this.stepRatios[i5] - value);
                k2 = i5;
              }
            }
            return this.stepRatios[k2];
          },
          groupCompare: function(a4, b2) {
            return a4[0] == b2[0] && a4[1] == b2[1];
          },
          groupCopy: function(a4, b2) {
            a4[0] = b2[0];
            a4[1] = b2[1];
          },
          groupClone: function(a4) {
            return [a4[0], a4[1]];
          },
          draggingOnDisabledAxis: function() {
            return !this.options.horizontal && Cursor.xDiff > Cursor.yDiff || !this.options.vertical && Cursor.yDiff > Cursor.xDiff;
          }
        };
        var bind = function(fn, context3) {
          return function() {
            return fn.apply(context3, arguments);
          };
        };
        var addEventListener2 = function(element, type, callback) {
          if (element.addEventListener) {
            element.addEventListener(type, callback, false);
          } else if (element.attachEvent) {
            element.attachEvent("on" + type, callback);
          }
        };
        var removeEventListener2 = function(element, type, callback) {
          if (element.removeEventListener) {
            element.removeEventListener(type, callback, false);
          } else if (element.detachEvent) {
            element.detachEvent("on" + type, callback);
          }
        };
        var preventEventDefaults = function(e8) {
          if (!e8) {
            e8 = window.event;
          }
          if (e8.preventDefault) {
            e8.preventDefault();
          }
          e8.returnValue = false;
        };
        var stopEventPropagation = function(e8) {
          if (!e8) {
            e8 = window.event;
          }
          if (e8.stopPropagation) {
            e8.stopPropagation();
          }
          e8.cancelBubble = true;
        };
        var Cursor = {
          /**
           * Abstraction for making the combined mouse or touch position available at
           * any time.
           *
           * It picks up the "move" events as an independent component and simply makes
           * the latest x and y mouse/touch position of the user available at any time,
           * which is requested with Cursor.x and Cursor.y respectively.
           *
           * It can receive both mouse and touch events consecutively, extracting the
           * relevant meta data from each type of event.
           *
           * Cursor.refresh(e) is called to update the global x and y values, with a
           * genuine MouseEvent or a TouchEvent from an event listener, e.g.
           * mousedown/up or touchstart/end
           */
          x: 0,
          y: 0,
          xDiff: 0,
          yDiff: 0,
          refresh: function(e8) {
            if (!e8) {
              e8 = window.event;
            }
            if (e8.type == "mousemove") {
              this.set(e8);
            } else if (e8.touches) {
              this.set(e8.touches[0]);
            }
          },
          set: function(e8) {
            var lastX = this.x, lastY = this.y;
            if (e8.clientX || e8.clientY) {
              this.x = e8.clientX;
              this.y = e8.clientY;
            } else if (e8.pageX || e8.pageY) {
              this.x = e8.pageX - document.body.scrollLeft - document.documentElement.scrollLeft;
              this.y = e8.pageY - document.body.scrollTop - document.documentElement.scrollTop;
            }
            this.xDiff = Math.abs(this.x - lastX);
            this.yDiff = Math.abs(this.y - lastY);
          }
        };
        var Position = {
          /**
           * Helper for extracting position of a DOM element, relative to the viewport
           *
           * The get(obj) method accepts a DOM element as the only parameter, and
           * returns the position under a (x, y) tuple, as an array with two elements.
           */
          get: function(obj) {
            var rect = { left: 0, top: 0 };
            if (obj.getBoundingClientRect !== void 0) {
              rect = obj.getBoundingClientRect();
            }
            return [rect.left, rect.top];
          }
        };
        var StylePrefix = {
          transform: getPrefixedStylePropName("transform"),
          perspective: getPrefixedStylePropName("perspective"),
          backfaceVisibility: getPrefixedStylePropName("backfaceVisibility")
        };
        function getPrefixedStylePropName(propName) {
          var domPrefixes = "Webkit Moz ms O".split(" "), elStyle = document.documentElement.style;
          if (elStyle[propName] !== void 0)
            return propName;
          propName = propName.charAt(0).toUpperCase() + propName.substr(1);
          for (var i5 = 0; i5 < domPrefixes.length; i5++) {
            if (elStyle[domPrefixes[i5] + propName] !== void 0) {
              return domPrefixes[i5] + propName;
            }
          }
        }
        ;
        function triggerWebkitHardwareAcceleration(element) {
          if (StylePrefix.backfaceVisibility && StylePrefix.perspective) {
            element.style[StylePrefix.perspective] = "1000px";
            element.style[StylePrefix.backfaceVisibility] = "hidden";
          }
        }
        ;
        var vendors = ["webkit", "moz"];
        var requestAnimationFrame2 = window.requestAnimationFrame;
        var cancelAnimationFrame2 = window.cancelAnimationFrame;
        for (var x2 = 0; x2 < vendors.length && !requestAnimationFrame2; ++x2) {
          requestAnimationFrame2 = window[vendors[x2] + "RequestAnimationFrame"];
          cancelAnimationFrame2 = window[vendors[x2] + "CancelAnimationFrame"] || window[vendors[x2] + "CancelRequestAnimationFrame"];
        }
        if (!requestAnimationFrame2) {
          requestAnimationFrame2 = function(callback) {
            return setTimeout(callback, 25);
          };
          cancelAnimationFrame2 = clearTimeout;
        }
        return Dragdealer2;
      });
    }
  });

  // node_modules/.pnpm/vidstack@1.12.9/node_modules/vidstack/prod/chunks/vidstack-CRlI3Mh7.js
  function flushEffects() {
    scheduledEffects = true;
    queueMicrotask(runEffects);
  }
  function runEffects() {
    if (!effects.length) {
      scheduledEffects = false;
      return;
    }
    runningEffects = true;
    for (let i5 = 0; i5 < effects.length; i5++) {
      if (effects[i5].$st !== STATE_CLEAN)
        runTop(effects[i5]);
    }
    effects = [];
    scheduledEffects = false;
    runningEffects = false;
  }
  function runTop(node) {
    let ancestors = [node];
    while (node = node[SCOPE]) {
      if (node.$e && node.$st !== STATE_CLEAN)
        ancestors.push(node);
    }
    for (let i5 = ancestors.length - 1; i5 >= 0; i5--) {
      updateCheck(ancestors[i5]);
    }
  }
  function root(init5) {
    const scope = createScope();
    return compute(scope, !init5.length ? init5 : init5.bind(null, dispose.bind(scope)), null);
  }
  function peek(fn) {
    return compute(currentScope, fn, null);
  }
  function untrack(fn) {
    return compute(null, fn, null);
  }
  function tick() {
    if (!runningEffects)
      runEffects();
  }
  function getScope() {
    return currentScope;
  }
  function scoped(run, scope) {
    try {
      return compute(scope, run, null);
    } catch (error) {
      handleError(scope, error);
      return;
    }
  }
  function getContext(key2, scope = currentScope) {
    return scope?.$cx[key2];
  }
  function setContext(key2, value, scope = currentScope) {
    if (scope)
      scope.$cx = { ...scope.$cx, [key2]: value };
  }
  function onDispose(disposable) {
    if (!disposable || !currentScope)
      return disposable || NOOP;
    const node = currentScope;
    if (!node.$d) {
      node.$d = disposable;
    } else if (Array.isArray(node.$d)) {
      node.$d.push(disposable);
    } else {
      node.$d = [node.$d, disposable];
    }
    return function removeDispose() {
      if (node.$st === STATE_DISPOSED)
        return;
      disposable.call(null);
      if (isFunction$1(node.$d)) {
        node.$d = null;
      } else if (Array.isArray(node.$d)) {
        node.$d.splice(node.$d.indexOf(disposable), 1);
      }
    };
  }
  function dispose(self = true) {
    if (this.$st === STATE_DISPOSED)
      return;
    if (this.$h) {
      if (Array.isArray(this.$h)) {
        for (let i5 = this.$h.length - 1; i5 >= 0; i5--) {
          dispose.call(this.$h[i5]);
        }
      } else {
        dispose.call(this.$h);
      }
    }
    if (self) {
      const parent = this[SCOPE];
      if (parent) {
        if (Array.isArray(parent.$h)) {
          parent.$h.splice(parent.$h.indexOf(this), 1);
        } else {
          parent.$h = null;
        }
      }
      disposeNode(this);
    }
  }
  function disposeNode(node) {
    node.$st = STATE_DISPOSED;
    if (node.$d)
      emptyDisposal(node);
    if (node.$s)
      removeSourceObservers(node, 0);
    node[SCOPE] = null;
    node.$s = null;
    node.$o = null;
    node.$h = null;
    node.$cx = defaultContext;
    node.$eh = null;
  }
  function emptyDisposal(scope) {
    try {
      if (Array.isArray(scope.$d)) {
        for (let i5 = scope.$d.length - 1; i5 >= 0; i5--) {
          const callable = scope.$d[i5];
          callable.call(callable);
        }
      } else {
        scope.$d.call(scope.$d);
      }
      scope.$d = null;
    } catch (error) {
      handleError(scope, error);
    }
  }
  function compute(scope, compute2, observer) {
    const prevScope = currentScope, prevObserver = currentObserver;
    currentScope = scope;
    currentObserver = observer;
    try {
      return compute2.call(scope);
    } finally {
      currentScope = prevScope;
      currentObserver = prevObserver;
    }
  }
  function handleError(scope, error) {
    if (!scope || !scope.$eh)
      throw error;
    let i5 = 0, len = scope.$eh.length, currentError = error;
    for (i5 = 0; i5 < len; i5++) {
      try {
        scope.$eh[i5](currentError);
        break;
      } catch (error2) {
        currentError = error2;
      }
    }
    if (i5 === len)
      throw currentError;
  }
  function read() {
    if (this.$st === STATE_DISPOSED)
      return this.$v;
    if (currentObserver && !this.$e) {
      if (!currentObservers && currentObserver.$s && currentObserver.$s[currentObserversIndex] == this) {
        currentObserversIndex++;
      } else if (!currentObservers)
        currentObservers = [this];
      else
        currentObservers.push(this);
    }
    if (this.$c)
      updateCheck(this);
    return this.$v;
  }
  function write(newValue) {
    const value = isFunction$1(newValue) ? newValue(this.$v) : newValue;
    if (this.$ch(this.$v, value)) {
      this.$v = value;
      if (this.$o) {
        for (let i5 = 0; i5 < this.$o.length; i5++) {
          notify(this.$o[i5], STATE_DIRTY);
        }
      }
    }
    return this.$v;
  }
  function createScope() {
    return new ScopeNode();
  }
  function createComputation(initialValue, compute2, options) {
    return new ComputeNode(initialValue, compute2, options);
  }
  function isNotEqual(a4, b2) {
    return a4 !== b2;
  }
  function isFunction$1(value) {
    return typeof value === "function";
  }
  function updateCheck(node) {
    if (node.$st === STATE_CHECK) {
      for (let i5 = 0; i5 < node.$s.length; i5++) {
        updateCheck(node.$s[i5]);
        if (node.$st === STATE_DIRTY) {
          break;
        }
      }
    }
    if (node.$st === STATE_DIRTY)
      update2(node);
    else
      node.$st = STATE_CLEAN;
  }
  function cleanup(node) {
    if (node.$h)
      dispose.call(node, false);
    if (node.$d)
      emptyDisposal(node);
    node.$eh = node[SCOPE] ? node[SCOPE].$eh : null;
  }
  function update2(node) {
    let prevObservers = currentObservers, prevObserversIndex = currentObserversIndex;
    currentObservers = null;
    currentObserversIndex = 0;
    try {
      cleanup(node);
      const result = compute(node, node.$c, node);
      updateObservers(node);
      if (!node.$e && node.$i) {
        write.call(node, result);
      } else {
        node.$v = result;
        node.$i = true;
      }
    } catch (error) {
      updateObservers(node);
      handleError(node, error);
    } finally {
      currentObservers = prevObservers;
      currentObserversIndex = prevObserversIndex;
      node.$st = STATE_CLEAN;
    }
  }
  function updateObservers(node) {
    if (currentObservers) {
      if (node.$s)
        removeSourceObservers(node, currentObserversIndex);
      if (node.$s && currentObserversIndex > 0) {
        node.$s.length = currentObserversIndex + currentObservers.length;
        for (let i5 = 0; i5 < currentObservers.length; i5++) {
          node.$s[currentObserversIndex + i5] = currentObservers[i5];
        }
      } else {
        node.$s = currentObservers;
      }
      let source;
      for (let i5 = currentObserversIndex; i5 < node.$s.length; i5++) {
        source = node.$s[i5];
        if (!source.$o)
          source.$o = [node];
        else
          source.$o.push(node);
      }
    } else if (node.$s && currentObserversIndex < node.$s.length) {
      removeSourceObservers(node, currentObserversIndex);
      node.$s.length = currentObserversIndex;
    }
  }
  function notify(node, state) {
    if (node.$st >= state)
      return;
    if (node.$e && node.$st === STATE_CLEAN) {
      effects.push(node);
      if (!scheduledEffects)
        flushEffects();
    }
    node.$st = state;
    if (node.$o) {
      for (let i5 = 0; i5 < node.$o.length; i5++) {
        notify(node.$o[i5], STATE_CHECK);
      }
    }
  }
  function removeSourceObservers(node, index) {
    let source, swap;
    for (let i5 = index; i5 < node.$s.length; i5++) {
      source = node.$s[i5];
      if (source.$o) {
        swap = source.$o.indexOf(node);
        source.$o[swap] = source.$o[source.$o.length - 1];
        source.$o.pop();
      }
    }
  }
  function noop(...args) {
  }
  function isNull(value) {
    return value === null;
  }
  function isUndefined(value) {
    return typeof value === "undefined";
  }
  function isNil(value) {
    return isNull(value) || isUndefined(value);
  }
  function isObject3(value) {
    return value?.constructor === Object;
  }
  function isNumber(value) {
    return typeof value === "number" && !Number.isNaN(value);
  }
  function isString(value) {
    return typeof value === "string";
  }
  function isBoolean(value) {
    return typeof value === "boolean";
  }
  function isFunction(value) {
    return typeof value === "function";
  }
  function isArray(value) {
    return Array.isArray(value);
  }
  function isDOMEvent(event2) {
    return !!event2?.[DOM_EVENT];
  }
  function listenEvent(target, type, handler, options) {
    target.addEventListener(type, handler, options);
    return onDispose(() => target.removeEventListener(type, handler, options));
  }
  function anySignal(...signals) {
    const controller = new AbortController(), options = { signal: controller.signal };
    function onAbort(event2) {
      controller.abort(event2.target.reason);
    }
    for (const signal2 of signals) {
      if (signal2.aborted) {
        controller.abort(signal2.reason);
        break;
      }
      signal2.addEventListener("abort", onAbort, options);
    }
    return controller.signal;
  }
  function isTouchEvent(event2) {
    return !!event2?.type.startsWith("touch");
  }
  function isKeyboardEvent(event2) {
    return !!event2?.type.startsWith("key");
  }
  function wasEnterKeyPressed(event2) {
    return isKeyboardEvent(event2) && event2.key === "Enter";
  }
  function isKeyboardClick(event2) {
    return isKeyboardEvent(event2) && (event2.key === "Enter" || event2.key === " ");
  }
  function isDOMNode(node) {
    return node instanceof Node;
  }
  function setAttribute(host, name, value) {
    if (!host)
      return;
    else if (!value && value !== "" && value !== 0) {
      host.removeAttribute(name);
    } else {
      const attrValue = value === true ? "" : value + "";
      if (host.getAttribute(name) !== attrValue) {
        host.setAttribute(name, attrValue);
      }
    }
  }
  function setStyle(host, property, value) {
    if (!host)
      return;
    else if (!value && value !== 0) {
      host.style.removeProperty(property);
    } else {
      host.style.setProperty(property, value + "");
    }
  }
  function signal(initialValue, options) {
    const node = createComputation(initialValue, null, options), signal2 = read.bind(node);
    signal2[SCOPE] = true;
    signal2.set = write.bind(node);
    return signal2;
  }
  function isReadSignal(fn) {
    return isFunction$1(fn) && SCOPE in fn;
  }
  function computed(compute2, options) {
    const node = createComputation(
      options?.initial,
      compute2,
      options
    ), signal2 = read.bind(node);
    signal2[SCOPE] = true;
    return signal2;
  }
  function effect$1(effect2, options) {
    const signal2 = createComputation(
      null,
      function runEffect() {
        let effectResult = effect2();
        isFunction$1(effectResult) && onDispose(effectResult);
        return null;
      },
      void 0
    );
    signal2.$e = true;
    update2(signal2);
    return dispose.bind(signal2, true);
  }
  function isWriteSignal(fn) {
    return isReadSignal(fn) && "set" in fn;
  }
  function createContext(provide) {
    return { id: Symbol(), provide };
  }
  function provideContext(context3, value, scope = getScope()) {
    const hasProvidedValue = !isUndefined(value);
    setContext(context3.id, hasProvidedValue ? value : context3.provide?.(), scope);
  }
  function useContext(context3) {
    const value = getContext(context3.id);
    return value;
  }
  function hasProvidedContext(context3) {
    return !isUndefined(getContext(context3.id));
  }
  function createInstanceProps(props) {
    const $props = {};
    for (const name of Object.keys(props)) {
      const def = props[name];
      $props[name] = signal(def, def);
    }
    return $props;
  }
  function createComponent(Component2, init5) {
    return root(() => {
      currentInstance.$$ = new Instance(Component2, getScope(), init5);
      const component = new Component2();
      currentInstance.$$.component = component;
      currentInstance.$$ = null;
      return component;
    });
  }
  function prop(target, propertyKey, descriptor) {
    if (!target[PROPS])
      target[PROPS] = /* @__PURE__ */ new Set();
    target[PROPS].add(propertyKey);
  }
  function method(target, propertyKey, descriptor) {
    if (!target[METHODS])
      target[METHODS] = /* @__PURE__ */ new Set();
    target[METHODS].add(propertyKey);
  }
  function useState(state) {
    return useContext(state);
  }
  function runAll(fns, arg) {
    for (const fn of fns)
      fn(arg);
  }
  function camelToKebabCase(str) {
    return str.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
  }
  function uppercaseFirstChar(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }
  function ariaBool(value) {
    return value ? "true" : "false";
  }
  function keysOf(obj) {
    return Object.keys(obj);
  }
  function deferredPromise() {
    let resolve, reject;
    const promise = new Promise((res, rej) => {
      resolve = res;
      reject = rej;
    });
    return { promise, resolve, reject };
  }
  function waitTimeout(delay) {
    return new Promise((resolve) => setTimeout(resolve, delay));
  }
  function animationFrameThrottle(func) {
    let id = -1, lastArgs;
    function throttle2(...args) {
      lastArgs = args;
      if (id >= 0)
        return;
      id = window.requestAnimationFrame(() => {
        func.apply(this, lastArgs);
        id = -1;
        lastArgs = void 0;
      });
    }
    return throttle2;
  }
  function waitIdlePeriod(callback, options) {
    return new Promise((resolve) => {
      requestIdleCallback((deadline) => {
        callback?.(deadline);
        resolve();
      }, options);
    });
  }
  function throttle(fn, interval, options) {
    var timeoutId = null;
    var throttledFn = null;
    var leading = options && options.leading;
    var trailing = options && options.trailing;
    if (leading == null) {
      leading = true;
    }
    if (trailing == null) {
      trailing = !leading;
    }
    if (leading == true) {
      trailing = false;
    }
    var cancel = function() {
      if (timeoutId) {
        clearTimeout(timeoutId);
        timeoutId = null;
      }
    };
    var flush = function() {
      var call = throttledFn;
      cancel();
      if (call) {
        call();
      }
    };
    var throttleWrapper = function() {
      var callNow = leading && !timeoutId;
      var context3 = this;
      var args = arguments;
      throttledFn = function() {
        return fn.apply(context3, args);
      };
      if (!timeoutId) {
        timeoutId = setTimeout(function() {
          timeoutId = null;
          if (trailing) {
            return throttledFn();
          }
        }, interval);
      }
      if (callNow) {
        callNow = false;
        return throttledFn();
      }
    };
    throttleWrapper.cancel = cancel;
    throttleWrapper.flush = flush;
    return throttleWrapper;
  }
  function debounce(fn, wait, callFirst) {
    var timeout = null;
    var debouncedFn = null;
    var clear = function() {
      if (timeout) {
        clearTimeout(timeout);
        debouncedFn = null;
        timeout = null;
      }
    };
    var flush = function() {
      var call = debouncedFn;
      clear();
      if (call) {
        call();
      }
    };
    var debounceWrapper = function() {
      if (!wait) {
        return fn.apply(this, arguments);
      }
      var context3 = this;
      var args = arguments;
      var callNow = callFirst && !timeout;
      clear();
      debouncedFn = function() {
        fn.apply(context3, args);
      };
      timeout = setTimeout(function() {
        timeout = null;
        if (!callNow) {
          var call = debouncedFn;
          debouncedFn = null;
          return call();
        }
      }, wait);
      if (callNow) {
        return debouncedFn();
      }
    };
    debounceWrapper.cancel = clear;
    debounceWrapper.flush = flush;
    return debounceWrapper;
  }
  function inferAttributeConverter(value) {
    if (value === null)
      return NULLABLE_STRING;
    switch (typeof value) {
      case "undefined":
        return STRING;
      case "string":
        return STRING;
      case "boolean":
        return BOOLEAN;
      case "number":
        return NUMBER;
      case "function":
        return FUNCTION;
      case "object":
        return isArray(value) ? ARRAY : OBJECT;
      default:
        return STRING;
    }
  }
  function Host(Super, Component2) {
    class MaverickElement extends Super {
      static attrs;
      static [ATTRS] = null;
      static get observedAttributes() {
        if (!this[ATTRS] && Component2.props) {
          const map = /* @__PURE__ */ new Map();
          for (const propName of Object.keys(Component2.props)) {
            let attr = this.attrs?.[propName], attrName = isString(attr) ? attr : !attr ? attr : attr?.attr;
            if (attrName === false)
              continue;
            if (!attrName)
              attrName = camelToKebabCase(propName);
            map.set(attrName, {
              prop: propName,
              converter: attr && !isString(attr) && attr?.converter || inferAttributeConverter(Component2.props[propName])
            });
          }
          this[ATTRS] = map;
        }
        return this[ATTRS] ? Array.from(this[ATTRS].keys()) : [];
      }
      $;
      [SETUP_STATE] = SetupState.Idle;
      [SETUP_CALLBACKS] = null;
      keepAlive = false;
      forwardKeepAlive = true;
      get scope() {
        return this.$.$$.scope;
      }
      get attachScope() {
        return this.$.$$.attachScope;
      }
      get connectScope() {
        return this.$.$$.connectScope;
      }
      get $props() {
        return this.$.$$.props;
      }
      get $state() {
        return this.$.$$.$state;
      }
      get state() {
        return this.$.state;
      }
      constructor(...args) {
        super(...args);
        this.$ = scoped(() => createComponent(Component2), null);
        this.$.$$.addHooks(this);
        if (Component2.props) {
          const props = this.$props, descriptors = Object.getOwnPropertyDescriptors(this);
          for (const prop2 of Object.keys(descriptors)) {
            if (prop2 in Component2.props) {
              props[prop2].set(this[prop2]);
              delete this[prop2];
            }
          }
        }
      }
      attributeChangedCallback(name, _2, newValue) {
        const Ctor = this.constructor;
        if (!Ctor[ATTRS]) {
          super.attributeChangedCallback?.(name, _2, newValue);
          return;
        }
        const def = Ctor[ATTRS].get(name);
        if (def)
          this[def.prop] = def.converter(newValue);
      }
      connectedCallback() {
        const instance = this.$?.$$;
        if (!instance || instance.destroyed)
          return;
        if (this[SETUP_STATE] !== SetupState.Ready) {
          setup.call(this);
          return;
        }
        if (!this.isConnected)
          return;
        if (this.hasAttribute("keep-alive")) {
          this.keepAlive = true;
        }
        instance.connect();
        if (isArray(this[SETUP_CALLBACKS]))
          runAll(this[SETUP_CALLBACKS], this);
        this[SETUP_CALLBACKS] = null;
        const callback = super.connectedCallback;
        if (callback)
          scoped(() => callback.call(this), this.connectScope);
        return;
      }
      disconnectedCallback() {
        const instance = this.$?.$$;
        if (!instance || instance.destroyed)
          return;
        instance.disconnect();
        const callback = super.disconnectedCallback;
        if (callback)
          callback.call(this);
        if (!this.keepAlive && !this.hasAttribute("keep-alive")) {
          setTimeout(() => {
            requestAnimationFrame(() => {
              if (!this.isConnected)
                instance.destroy();
            });
          }, 0);
        }
      }
      [SETUP]() {
        const instance = this.$.$$, Ctor = this.constructor;
        if (instance.destroyed)
          return;
        const attrs = Ctor[ATTRS];
        if (attrs) {
          for (const attr of this.attributes) {
            let def = attrs.get(attr.name);
            if (def && def.converter) {
              instance.props[def.prop].set(def.converter(this.getAttribute(attr.name)));
            }
          }
        }
        instance.setup();
        instance.attach(this);
        this[SETUP_STATE] = SetupState.Ready;
        this.connectedCallback();
      }
      // @ts-expect-error
      subscribe(callback) {
        return this.$.subscribe(callback);
      }
      destroy() {
        this.disconnectedCallback();
        this.$.destroy();
      }
    }
    extendProto(MaverickElement, Component2);
    return MaverickElement;
  }
  function extendProto(Element2, Component2) {
    const ElementProto = Element2.prototype, ComponentProto = Component2.prototype;
    if (Component2.props) {
      for (const prop2 of Object.keys(Component2.props)) {
        Object.defineProperty(ElementProto, prop2, {
          enumerable: true,
          configurable: true,
          get() {
            return this.$props[prop2]();
          },
          set(value) {
            this.$props[prop2].set(value);
          }
        });
      }
    }
    if (ComponentProto[PROPS]) {
      for (const name of ComponentProto[PROPS]) {
        Object.defineProperty(ElementProto, name, {
          enumerable: true,
          configurable: true,
          get() {
            return this.$[name];
          },
          set(value) {
            this.$[name] = value;
          }
        });
      }
    }
    if (ComponentProto[METHODS]) {
      for (const name of ComponentProto[METHODS]) {
        ElementProto[name] = function(...args) {
          return this.$[name](...args);
        };
      }
    }
  }
  function setup() {
    if (this[SETUP_STATE] !== SetupState.Idle)
      return;
    this[SETUP_STATE] = SetupState.Pending;
    const parent = findParent(this), isParentRegistered = parent && window.customElements.get(parent.localName), isParentSetup = parent && parent[SETUP_STATE] === SetupState.Ready;
    if (parent && (!isParentRegistered || !isParentSetup)) {
      waitForParent.call(this, parent);
      return;
    }
    attach.call(this, parent);
  }
  async function waitForParent(parent) {
    await window.customElements.whenDefined(parent.localName);
    if (parent[SETUP_STATE] !== SetupState.Ready) {
      await new Promise((res) => (parent[SETUP_CALLBACKS] ??= []).push(res));
    }
    attach.call(this, parent);
  }
  function attach(parent) {
    if (!this.isConnected)
      return;
    if (parent) {
      if (parent.keepAlive && parent.forwardKeepAlive) {
        this.keepAlive = true;
        this.setAttribute("keep-alive", "");
      }
      const scope = this.$.$$.scope;
      if (scope)
        parent.$.$$.attachScope.append(scope);
    }
    this[SETUP]();
  }
  function findParent(host) {
    let node = host.parentNode, prefix = host.localName.split("-", 1)[0] + "-";
    while (node) {
      if (node.nodeType === 1 && node.localName.startsWith(prefix)) {
        return node;
      }
      node = node.parentNode;
    }
    return null;
  }
  function defineCustomElement(element, throws = false) {
    if (throws || !window.customElements.get(element.tagName)) {
      window.customElements.define(element.tagName, element);
    }
  }
  var SCOPE, scheduledEffects, runningEffects, currentScope, currentObserver, currentObservers, currentObserversIndex, effects, defaultContext, NOOP, STATE_CLEAN, STATE_CHECK, STATE_DIRTY, STATE_DISPOSED, ScopeNode, ScopeProto, ComputeNode, ComputeProto, EVENT, DOM_EVENT, DOMEvent, EventTriggers, EventsTarget, EventsController, effect, PROPS, METHODS, ON_DISPATCH, EMPTY_PROPS, Instance, currentInstance, ViewController, Component, State, requestIdleCallback, key, webkit, moz, ms, document$1, vendor, fscreen, functionThrottle, functionDebounce, t2, e3, n2, o2, l2, r2, STRING, NULLABLE_STRING, NUMBER, BOOLEAN, FUNCTION, ARRAY, OBJECT, ATTRS, SETUP, SETUP_STATE, SETUP_CALLBACKS, SetupState, Icon$24;
  var init_vidstack_CRlI3Mh7 = __esm({
    "node_modules/.pnpm/vidstack@1.12.9/node_modules/vidstack/prod/chunks/vidstack-CRlI3Mh7.js"() {
      init_live_reload();
      SCOPE = Symbol(0);
      scheduledEffects = false;
      runningEffects = false;
      currentScope = null;
      currentObserver = null;
      currentObservers = null;
      currentObserversIndex = 0;
      effects = [];
      defaultContext = {};
      NOOP = () => {
      };
      STATE_CLEAN = 0;
      STATE_CHECK = 1;
      STATE_DIRTY = 2;
      STATE_DISPOSED = 3;
      ScopeNode = function Scope() {
        this[SCOPE] = null;
        this.$h = null;
        if (currentScope)
          currentScope.append(this);
      };
      ScopeProto = ScopeNode.prototype;
      ScopeProto.$cx = defaultContext;
      ScopeProto.$eh = null;
      ScopeProto.$c = null;
      ScopeProto.$d = null;
      ScopeProto.append = function(child) {
        child[SCOPE] = this;
        if (!this.$h) {
          this.$h = child;
        } else if (Array.isArray(this.$h)) {
          this.$h.push(child);
        } else {
          this.$h = [this.$h, child];
        }
        child.$cx = child.$cx === defaultContext ? this.$cx : { ...this.$cx, ...child.$cx };
        if (this.$eh) {
          child.$eh = !child.$eh ? this.$eh : [...child.$eh, ...this.$eh];
        }
      };
      ScopeProto.dispose = function() {
        dispose.call(this);
      };
      ComputeNode = function Computation(initialValue, compute2, options) {
        ScopeNode.call(this);
        this.$st = compute2 ? STATE_DIRTY : STATE_CLEAN;
        this.$i = false;
        this.$e = false;
        this.$s = null;
        this.$o = null;
        this.$v = initialValue;
        if (compute2)
          this.$c = compute2;
        if (options && options.dirty)
          this.$ch = options.dirty;
      };
      ComputeProto = ComputeNode.prototype;
      Object.setPrototypeOf(ComputeProto, ScopeProto);
      ComputeProto.$ch = isNotEqual;
      ComputeProto.call = read;
      EVENT = Event;
      DOM_EVENT = Symbol("DOM_EVENT");
      DOMEvent = class extends EVENT {
        [DOM_EVENT] = true;
        /**
         * The event detail.
         */
        detail;
        /**
         * The event trigger chain.
         */
        triggers = new EventTriggers();
        /**
         * The preceding event that was responsible for this event being fired.
         */
        get trigger() {
          return this.triggers.source;
        }
        /**
         * The origin event that lead to this event being fired.
         */
        get originEvent() {
          return this.triggers.origin;
        }
        /**
         * Whether the origin event was triggered by the user.
         *
         * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Event/isTrusted}
         */
        get isOriginTrusted() {
          return this.triggers.origin?.isTrusted ?? false;
        }
        constructor(type, ...init5) {
          super(type, init5[0]);
          this.detail = init5[0]?.detail;
          const trigger = init5[0]?.trigger;
          if (trigger)
            this.triggers.add(trigger);
        }
      };
      EventTriggers = class {
        chain = [];
        get source() {
          return this.chain[0];
        }
        get origin() {
          return this.chain[this.chain.length - 1];
        }
        /**
         * Appends the event to the end of the chain.
         */
        add(event2) {
          this.chain.push(event2);
          if (isDOMEvent(event2)) {
            this.chain.push(...event2.triggers);
          }
        }
        /**
         * Removes the event from the chain and returns it (if found).
         */
        remove(event2) {
          return this.chain.splice(this.chain.indexOf(event2), 1)[0];
        }
        /**
         * Returns whether the chain contains the given `event`.
         */
        has(event2) {
          return this.chain.some((e8) => e8 === event2);
        }
        /**
         * Returns whether the chain contains the given event type.
         */
        hasType(type) {
          return !!this.findType(type);
        }
        /**
         * Returns the first event with the given `type` found in the chain.
         */
        findType(type) {
          return this.chain.find((e8) => e8.type === type);
        }
        /**
         * Walks an event chain on a given `event`, and invokes the given `callback` for each trigger event.
         */
        walk(callback) {
          for (const event2 of this.chain) {
            const returnValue = callback(event2);
            if (returnValue)
              return [event2, returnValue];
          }
        }
        [Symbol.iterator]() {
          return this.chain.values();
        }
      };
      EventsTarget = class extends EventTarget {
        /** @internal type only */
        $ts__events;
        addEventListener(type, callback, options) {
          return super.addEventListener(type, callback, options);
        }
        removeEventListener(type, callback, options) {
          return super.removeEventListener(type, callback, options);
        }
      };
      EventsController = class {
        #target;
        #controller;
        get signal() {
          return this.#controller.signal;
        }
        constructor(target) {
          this.#target = target;
          this.#controller = new AbortController();
          onDispose(this.abort.bind(this));
        }
        add(type, handler, options) {
          if (this.signal.aborted)
            throw Error("aborted");
          this.#target.addEventListener(type, handler, {
            ...options,
            signal: options?.signal ? anySignal(this.signal, options.signal) : this.signal
          });
          return this;
        }
        remove(type, handler) {
          this.#target.removeEventListener(type, handler);
          return this;
        }
        abort(reason) {
          this.#controller.abort(reason);
        }
      };
      effect = effect$1;
      PROPS = /* @__PURE__ */ Symbol(0);
      METHODS = /* @__PURE__ */ Symbol(0);
      ON_DISPATCH = /* @__PURE__ */ Symbol(0);
      EMPTY_PROPS = {};
      Instance = class {
        /** @internal type only */
        $ts__events;
        /** @internal type only */
        $ts__vars;
        /* @internal */
        [ON_DISPATCH] = null;
        $el = signal(null);
        el = null;
        scope = null;
        attachScope = null;
        connectScope = null;
        component = null;
        destroyed = false;
        props = EMPTY_PROPS;
        attrs = null;
        styles = null;
        state;
        $state;
        #setupCallbacks = [];
        #attachCallbacks = [];
        #connectCallbacks = [];
        #destroyCallbacks = [];
        constructor(Component2, scope, init5) {
          this.scope = scope;
          if (init5?.scope)
            init5.scope.append(scope);
          let stateFactory = Component2.state, props = Component2.props;
          if (stateFactory) {
            this.$state = stateFactory.create();
            this.state = new Proxy(this.$state, {
              get: (_2, prop2) => this.$state[prop2]()
            });
            provideContext(stateFactory, this.$state);
          }
          if (props) {
            this.props = createInstanceProps(props);
            if (init5?.props) {
              for (const prop2 of Object.keys(init5.props)) {
                this.props[prop2]?.set(init5.props[prop2]);
              }
            }
          }
          onDispose(this.destroy.bind(this));
        }
        setup() {
          scoped(() => {
            for (const callback of this.#setupCallbacks)
              callback();
          }, this.scope);
        }
        attach(el) {
          if (this.el)
            return;
          this.el = el;
          this.$el.set(el);
          scoped(() => {
            this.attachScope = createScope();
            scoped(() => {
              for (const callback of this.#attachCallbacks)
                callback(this.el);
              this.#attachAttrs();
              this.#attachStyles();
            }, this.attachScope);
          }, this.scope);
          el.dispatchEvent(new Event("attached"));
        }
        detach() {
          this.attachScope?.dispose();
          this.attachScope = null;
          this.connectScope = null;
          this.el = null;
          this.$el.set(null);
        }
        connect() {
          if (!this.el || !this.attachScope || !this.#connectCallbacks.length)
            return;
          scoped(() => {
            this.connectScope = createScope();
            scoped(() => {
              for (const callback of this.#connectCallbacks)
                callback(this.el);
            }, this.connectScope);
          }, this.attachScope);
        }
        disconnect() {
          this.connectScope?.dispose();
          this.connectScope = null;
        }
        destroy() {
          if (this.destroyed)
            return;
          this.destroyed = true;
          scoped(() => {
            for (const callback of this.#destroyCallbacks)
              callback(this.el);
          }, this.scope);
          const el = this.el;
          this.detach();
          this.scope.dispose();
          this.#setupCallbacks.length = 0;
          this.#attachCallbacks.length = 0;
          this.#connectCallbacks.length = 0;
          this.#destroyCallbacks.length = 0;
          this.component = null;
          this.attrs = null;
          this.styles = null;
          this.props = EMPTY_PROPS;
          this.scope = null;
          this.state = EMPTY_PROPS;
          this.$state = null;
          if (el)
            delete el.$;
        }
        addHooks(target) {
          if (target.onSetup)
            this.#setupCallbacks.push(target.onSetup.bind(target));
          if (target.onAttach)
            this.#attachCallbacks.push(target.onAttach.bind(target));
          if (target.onConnect)
            this.#connectCallbacks.push(target.onConnect.bind(target));
          if (target.onDestroy)
            this.#destroyCallbacks.push(target.onDestroy.bind(target));
        }
        #attachAttrs() {
          if (!this.attrs)
            return;
          for (const name of Object.keys(this.attrs)) {
            if (isFunction(this.attrs[name])) {
              effect(this.#setAttr.bind(this, name));
            } else {
              setAttribute(this.el, name, this.attrs[name]);
            }
          }
        }
        #attachStyles() {
          if (!this.styles)
            return;
          for (const name of Object.keys(this.styles)) {
            if (isFunction(this.styles[name])) {
              effect(this.#setStyle.bind(this, name));
            } else {
              setStyle(this.el, name, this.styles[name]);
            }
          }
        }
        #setAttr(name) {
          setAttribute(this.el, name, this.attrs[name].call(this.component));
        }
        #setStyle(name) {
          setStyle(this.el, name, this.styles[name].call(this.component));
        }
      };
      currentInstance = { $$: null };
      ViewController = class extends EventTarget {
        /** @internal */
        $$;
        get el() {
          return this.$$.el;
        }
        get $el() {
          return this.$$.$el();
        }
        get scope() {
          return this.$$.scope;
        }
        get attachScope() {
          return this.$$.attachScope;
        }
        get connectScope() {
          return this.$$.connectScope;
        }
        /** @internal */
        get $props() {
          return this.$$.props;
        }
        /** @internal */
        get $state() {
          return this.$$.$state;
        }
        get state() {
          return this.$$.state;
        }
        constructor() {
          super();
          if (currentInstance.$$)
            this.attach(currentInstance);
        }
        attach({ $$ }) {
          this.$$ = $$;
          $$.addHooks(this);
          return this;
        }
        addEventListener(type, callback, options) {
          this.listen(type, callback, options);
        }
        removeEventListener(type, callback, options) {
          this.el?.removeEventListener(type, callback, options);
        }
        /**
         * The given callback is invoked when the component is ready to be set up.
         *
         * - This hook will run once.
         * - This hook is called both client-side and server-side.
         * - It's safe to use context inside this hook.
         * - The host element has not attached yet - wait for `onAttach`.
         */
        /**
         * This method can be used to specify attributes that should be set on the host element. Any
         * attributes that are assigned to a function will be considered a signal and updated accordingly.
         */
        setAttributes(attributes) {
          if (!this.$$.attrs)
            this.$$.attrs = {};
          Object.assign(this.$$.attrs, attributes);
        }
        /**
         * This method can be used to specify styles that should set be set on the host element. Any
         * styles that are assigned to a function will be considered a signal and updated accordingly.
         */
        setStyles(styles) {
          if (!this.$$.styles)
            this.$$.styles = {};
          Object.assign(this.$$.styles, styles);
        }
        /**
         * This method is used to satisfy the CSS variables contract specified on the current
         * component. Other CSS variables can be set via the `setStyles` method.
         */
        setCSSVars(vars) {
          this.setStyles(vars);
        }
        /**
         * Type-safe utility for creating component DOM events.
         */
        createEvent(type, ...init5) {
          return new DOMEvent(type, init5[0]);
        }
        /**
         * Creates a `DOMEvent` and dispatches it from the host element. This method is typed to
         * match all component events.
         */
        dispatch(type, ...init5) {
          if (!this.el)
            return false;
          const event2 = type instanceof Event ? type : new DOMEvent(type, init5[0]);
          Object.defineProperty(event2, "target", {
            get: () => this.$$.component
          });
          return untrack(() => {
            this.$$[ON_DISPATCH]?.(event2);
            return this.el.dispatchEvent(event2);
          });
        }
        dispatchEvent(event2) {
          return this.dispatch(event2);
        }
        /**
         * Adds an event listener for the given `type` and returns a function which can be invoked to
         * remove the event listener.
         *
         * - The listener is removed if the current scope is disposed.
         * - This method is safe to use on the server (noop).
         */
        listen(type, handler, options) {
          if (!this.el)
            return noop;
          return listenEvent(this.el, type, handler, options);
        }
      };
      Component = class extends ViewController {
        subscribe(callback) {
          return scoped(() => effect(() => callback(this.state)), this.$$.scope);
        }
        destroy() {
          this.$$.destroy();
        }
      };
      State = class {
        id = Symbol(0);
        record;
        #descriptors;
        constructor(record) {
          this.record = record;
          this.#descriptors = Object.getOwnPropertyDescriptors(record);
        }
        create() {
          const store = {}, state = new Proxy(store, { get: (_2, prop2) => store[prop2]() });
          for (const name of Object.keys(this.record)) {
            const getter = this.#descriptors[name].get;
            store[name] = getter ? computed(getter.bind(state)) : signal(this.record[name]);
          }
          return store;
        }
        reset(record, filter) {
          for (const name of Object.keys(record)) {
            if (!this.#descriptors[name].get && (!filter || filter(name))) {
              record[name].set(this.record[name]);
            }
          }
        }
      };
      requestIdleCallback = typeof window !== "undefined" ? "requestIdleCallback" in window ? window.requestIdleCallback : (cb) => window.setTimeout(cb, 1) : noop;
      key = {
        fullscreenEnabled: 0,
        fullscreenElement: 1,
        requestFullscreen: 2,
        exitFullscreen: 3,
        fullscreenchange: 4,
        fullscreenerror: 5,
        fullscreen: 6
      };
      webkit = [
        "webkitFullscreenEnabled",
        "webkitFullscreenElement",
        "webkitRequestFullscreen",
        "webkitExitFullscreen",
        "webkitfullscreenchange",
        "webkitfullscreenerror",
        "-webkit-full-screen"
      ];
      moz = [
        "mozFullScreenEnabled",
        "mozFullScreenElement",
        "mozRequestFullScreen",
        "mozCancelFullScreen",
        "mozfullscreenchange",
        "mozfullscreenerror",
        "-moz-full-screen"
      ];
      ms = [
        "msFullscreenEnabled",
        "msFullscreenElement",
        "msRequestFullscreen",
        "msExitFullscreen",
        "MSFullscreenChange",
        "MSFullscreenError",
        "-ms-fullscreen"
      ];
      document$1 = typeof window !== "undefined" && typeof window.document !== "undefined" ? window.document : {};
      vendor = "fullscreenEnabled" in document$1 && Object.keys(key) || webkit[0] in document$1 && webkit || moz[0] in document$1 && moz || ms[0] in document$1 && ms || [];
      fscreen = {
        requestFullscreen: function(element) {
          return element[vendor[key.requestFullscreen]]();
        },
        requestFullscreenFunction: function(element) {
          return element[vendor[key.requestFullscreen]];
        },
        get exitFullscreen() {
          return document$1[vendor[key.exitFullscreen]].bind(document$1);
        },
        get fullscreenPseudoClass() {
          return ":" + vendor[key.fullscreen];
        },
        addEventListener: function(type, handler, options) {
          return document$1.addEventListener(vendor[key[type]], handler, options);
        },
        removeEventListener: function(type, handler, options) {
          return document$1.removeEventListener(vendor[key[type]], handler, options);
        },
        get fullscreenEnabled() {
          return Boolean(document$1[vendor[key.fullscreenEnabled]]);
        },
        set fullscreenEnabled(val) {
        },
        get fullscreenElement() {
          return document$1[vendor[key.fullscreenElement]];
        },
        set fullscreenElement(val) {
        },
        get onfullscreenchange() {
          return document$1[("on" + vendor[key.fullscreenchange]).toLowerCase()];
        },
        set onfullscreenchange(handler) {
          return document$1[("on" + vendor[key.fullscreenchange]).toLowerCase()] = handler;
        },
        get onfullscreenerror() {
          return document$1[("on" + vendor[key.fullscreenerror]).toLowerCase()];
        },
        set onfullscreenerror(handler) {
          return document$1[("on" + vendor[key.fullscreenerror]).toLowerCase()] = handler;
        }
      };
      functionThrottle = throttle;
      functionDebounce = debounce;
      t2 = (t22) => "object" == typeof t22 && null != t22 && 1 === t22.nodeType;
      e3 = (t22, e22) => (!e22 || "hidden" !== t22) && ("visible" !== t22 && "clip" !== t22);
      n2 = (t22, n22) => {
        if (t22.clientHeight < t22.scrollHeight || t22.clientWidth < t22.scrollWidth) {
          const o22 = getComputedStyle(t22, null);
          return e3(o22.overflowY, n22) || e3(o22.overflowX, n22) || ((t32) => {
            const e22 = ((t42) => {
              if (!t42.ownerDocument || !t42.ownerDocument.defaultView)
                return null;
              try {
                return t42.ownerDocument.defaultView.frameElement;
              } catch (t52) {
                return null;
              }
            })(t32);
            return !!e22 && (e22.clientHeight < t32.scrollHeight || e22.clientWidth < t32.scrollWidth);
          })(t22);
        }
        return false;
      };
      o2 = (t22, e22, n22, o22, l22, r22, i5, s5) => r22 < t22 && i5 > e22 || r22 > t22 && i5 < e22 ? 0 : r22 <= t22 && s5 <= n22 || i5 >= e22 && s5 >= n22 ? r22 - t22 - o22 : i5 > e22 && s5 < n22 || r22 < t22 && s5 > n22 ? i5 - e22 + l22 : 0;
      l2 = (t22) => {
        const e22 = t22.parentElement;
        return null == e22 ? t22.getRootNode().host || null : e22;
      };
      r2 = (e22, r22) => {
        var i5, s5, d2, h5;
        if ("undefined" == typeof document)
          return [];
        const { scrollMode: c4, block: f2, inline: u2, boundary: a4, skipOverflowHiddenElements: g2 } = r22, p2 = "function" == typeof a4 ? a4 : (t22) => t22 !== a4;
        if (!t2(e22))
          throw new TypeError("Invalid target");
        const m2 = document.scrollingElement || document.documentElement, w2 = [];
        let W = e22;
        for (; t2(W) && p2(W); ) {
          if (W = l2(W), W === m2) {
            w2.push(W);
            break;
          }
          null != W && W === document.body && n2(W) && !n2(document.documentElement) || null != W && n2(W, g2) && w2.push(W);
        }
        const b2 = null != (s5 = null == (i5 = window.visualViewport) ? void 0 : i5.width) ? s5 : innerWidth, H2 = null != (h5 = null == (d2 = window.visualViewport) ? void 0 : d2.height) ? h5 : innerHeight, { scrollX: y2, scrollY: M2 } = window, { height: v2, width: E2, top: x2, right: C2, bottom: I2, left: R2 } = e22.getBoundingClientRect(), { top: T2, right: B2, bottom: F, left: V2 } = ((t22) => {
          const e32 = window.getComputedStyle(t22);
          return { top: parseFloat(e32.scrollMarginTop) || 0, right: parseFloat(e32.scrollMarginRight) || 0, bottom: parseFloat(e32.scrollMarginBottom) || 0, left: parseFloat(e32.scrollMarginLeft) || 0 };
        })(e22);
        let k2 = "start" === f2 || "nearest" === f2 ? x2 - T2 : "end" === f2 ? I2 + F : x2 + v2 / 2 - T2 + F, D = "center" === u2 ? R2 + E2 / 2 - V2 + B2 : "end" === u2 ? C2 + B2 : R2 - V2;
        const L2 = [];
        for (let t22 = 0; t22 < w2.length; t22++) {
          const e32 = w2[t22], { height: n22, width: l22, top: r32, right: i22, bottom: s22, left: d22 } = e32.getBoundingClientRect();
          if ("if-needed" === c4 && x2 >= 0 && R2 >= 0 && I2 <= H2 && C2 <= b2 && x2 >= r32 && I2 <= s22 && R2 >= d22 && C2 <= i22)
            return L2;
          const h22 = getComputedStyle(e32), a22 = parseInt(h22.borderLeftWidth, 10), g22 = parseInt(h22.borderTopWidth, 10), p22 = parseInt(h22.borderRightWidth, 10), W2 = parseInt(h22.borderBottomWidth, 10);
          let T22 = 0, B22 = 0;
          const F2 = "offsetWidth" in e32 ? e32.offsetWidth - e32.clientWidth - a22 - p22 : 0, V22 = "offsetHeight" in e32 ? e32.offsetHeight - e32.clientHeight - g22 - W2 : 0, S2 = "offsetWidth" in e32 ? 0 === e32.offsetWidth ? 0 : l22 / e32.offsetWidth : 0, X = "offsetHeight" in e32 ? 0 === e32.offsetHeight ? 0 : n22 / e32.offsetHeight : 0;
          if (m2 === e32)
            T22 = "start" === f2 ? k2 : "end" === f2 ? k2 - H2 : "nearest" === f2 ? o2(M2, M2 + H2, H2, g22, W2, M2 + k2, M2 + k2 + v2, v2) : k2 - H2 / 2, B22 = "start" === u2 ? D : "center" === u2 ? D - b2 / 2 : "end" === u2 ? D - b2 : o2(y2, y2 + b2, b2, a22, p22, y2 + D, y2 + D + E2, E2), T22 = Math.max(0, T22 + M2), B22 = Math.max(0, B22 + y2);
          else {
            T22 = "start" === f2 ? k2 - r32 - g22 : "end" === f2 ? k2 - s22 + W2 + V22 : "nearest" === f2 ? o2(r32, s22, n22, g22, W2 + V22, k2, k2 + v2, v2) : k2 - (r32 + n22 / 2) + V22 / 2, B22 = "start" === u2 ? D - d22 - a22 : "center" === u2 ? D - (d22 + l22 / 2) + F2 / 2 : "end" === u2 ? D - i22 + p22 + F2 : o2(d22, i22, l22, a22, p22 + F2, D, D + E2, E2);
            const { scrollLeft: t32, scrollTop: h32 } = e32;
            T22 = 0 === X ? 0 : Math.max(0, Math.min(h32 + T22 / X, e32.scrollHeight - n22 / X + V22)), B22 = 0 === S2 ? 0 : Math.max(0, Math.min(t32 + B22 / S2, e32.scrollWidth - l22 / S2 + F2)), k2 += h32 - T22, D += t32 - B22;
          }
          L2.push({ el: e32, top: T22, left: B22 });
        }
        return L2;
      };
      STRING = (v2) => v2 === null ? "" : v2 + "";
      NULLABLE_STRING = (v2) => v2 === null ? null : v2 + "";
      NUMBER = (v2) => v2 === null ? 0 : Number(v2);
      BOOLEAN = (v2) => v2 !== null;
      FUNCTION = () => null;
      ARRAY = (v2) => v2 === null ? [] : JSON.parse(v2);
      OBJECT = (v2) => v2 === null ? {} : JSON.parse(v2);
      ATTRS = /* @__PURE__ */ Symbol(0);
      SETUP = /* @__PURE__ */ Symbol(0);
      SETUP_STATE = /* @__PURE__ */ Symbol(0);
      SETUP_CALLBACKS = /* @__PURE__ */ Symbol(0);
      (function(SetupState2) {
        const Idle = 0;
        SetupState2[SetupState2["Idle"] = Idle] = "Idle";
        const Pending = 1;
        SetupState2[SetupState2["Pending"] = Pending] = "Pending";
        const Ready = 2;
        SetupState2[SetupState2["Ready"] = Ready] = "Ready";
      })(SetupState || (SetupState = {}));
      Icon$24 = `<path fill-rule="evenodd" clip-rule="evenodd" d="M6 7C5.63181 7 5.33333 7.29848 5.33333 7.66667V14.8667C5.33333 14.9403 5.39361 14.9999 5.46724 15.0009C10.8844 15.0719 15.2614 19.449 15.3325 24.8661C15.3334 24.9397 15.393 25 15.4667 25H26C26.3682 25 26.6667 24.7015 26.6667 24.3333V7.66667C26.6667 7.29848 26.3682 7 26 7H6ZM17.0119 22.2294C17.0263 22.29 17.0802 22.3333 17.1425 22.3333H23.3333C23.7015 22.3333 24 22.0349 24 21.6667V10.3333C24 9.96514 23.7015 9.66667 23.3333 9.66667H8.66667C8.29848 9.66667 8 9.96514 8 10.3333V13.1909C8 13.2531 8.04332 13.3071 8.10392 13.3214C12.5063 14.3618 15.9715 17.827 17.0119 22.2294Z" fill="currentColor"/> <path d="M13.2 25C13.2736 25 13.3334 24.9398 13.3322 24.8661C13.2615 20.5544 9.77889 17.0718 5.46718 17.0011C5.39356 16.9999 5.33333 17.0597 5.33333 17.1333V18.8667C5.33333 18.9403 5.39348 18.9999 5.4671 19.0015C8.67465 19.0716 11.2617 21.6587 11.3319 24.8662C11.3335 24.9399 11.393 25 11.4667 25H13.2Z" fill="currentColor"/> <path d="M5.33333 21.1333C5.33333 21.0597 5.39332 20.9998 5.46692 21.0022C7.57033 21.0712 9.26217 22.763 9.33114 24.8664C9.33356 24.94 9.27364 25 9.2 25H6C5.63181 25 5.33333 24.7015 5.33333 24.3333V21.1333Z" fill="currentColor"/>`;
    }
  });

  // node_modules/.pnpm/vidstack@1.12.9/node_modules/vidstack/prod/chunks/vidstack-Cpte_fRf.js
  function useMediaContext() {
    return useContext(mediaContext);
  }
  var mediaContext;
  var init_vidstack_Cpte_fRf = __esm({
    "node_modules/.pnpm/vidstack@1.12.9/node_modules/vidstack/prod/chunks/vidstack-Cpte_fRf.js"() {
      init_live_reload();
      init_vidstack_CRlI3Mh7();
      mediaContext = createContext();
    }
  });

  // node_modules/.pnpm/@floating-ui+utils@0.2.7/node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs
  function clamp4(start, value, end) {
    return max(start, min(value, end));
  }
  function evaluate(value, param) {
    return typeof value === "function" ? value(param) : value;
  }
  function getSide(placement) {
    return placement.split("-")[0];
  }
  function getAlignment(placement) {
    return placement.split("-")[1];
  }
  function getOppositeAxis(axis) {
    return axis === "x" ? "y" : "x";
  }
  function getAxisLength(axis) {
    return axis === "y" ? "height" : "width";
  }
  function getSideAxis(placement) {
    return ["top", "bottom"].includes(getSide(placement)) ? "y" : "x";
  }
  function getAlignmentAxis(placement) {
    return getOppositeAxis(getSideAxis(placement));
  }
  function getAlignmentSides(placement, rects, rtl) {
    if (rtl === void 0) {
      rtl = false;
    }
    const alignment = getAlignment(placement);
    const alignmentAxis = getAlignmentAxis(placement);
    const length = getAxisLength(alignmentAxis);
    let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
    if (rects.reference[length] > rects.floating[length]) {
      mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
    }
    return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
  }
  function getExpandedPlacements(placement) {
    const oppositePlacement = getOppositePlacement(placement);
    return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
  }
  function getOppositeAlignmentPlacement(placement) {
    return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
  }
  function getSideList(side, isStart, rtl) {
    const lr = ["left", "right"];
    const rl = ["right", "left"];
    const tb = ["top", "bottom"];
    const bt = ["bottom", "top"];
    switch (side) {
      case "top":
      case "bottom":
        if (rtl)
          return isStart ? rl : lr;
        return isStart ? lr : rl;
      case "left":
      case "right":
        return isStart ? tb : bt;
      default:
        return [];
    }
  }
  function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
    const alignment = getAlignment(placement);
    let list = getSideList(getSide(placement), direction === "start", rtl);
    if (alignment) {
      list = list.map((side) => side + "-" + alignment);
      if (flipAlignment) {
        list = list.concat(list.map(getOppositeAlignmentPlacement));
      }
    }
    return list;
  }
  function getOppositePlacement(placement) {
    return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
  }
  function expandPaddingObject(padding) {
    return {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0,
      ...padding
    };
  }
  function getPaddingObject(padding) {
    return typeof padding !== "number" ? expandPaddingObject(padding) : {
      top: padding,
      right: padding,
      bottom: padding,
      left: padding
    };
  }
  function rectToClientRect(rect) {
    const {
      x: x2,
      y: y2,
      width,
      height
    } = rect;
    return {
      width,
      height,
      top: y2,
      left: x2,
      right: x2 + width,
      bottom: y2 + height,
      x: x2,
      y: y2
    };
  }
  var min, max, round, floor, createCoords, oppositeSideMap, oppositeAlignmentMap;
  var init_floating_ui_utils = __esm({
    "node_modules/.pnpm/@floating-ui+utils@0.2.7/node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs"() {
      init_live_reload();
      min = Math.min;
      max = Math.max;
      round = Math.round;
      floor = Math.floor;
      createCoords = (v2) => ({
        x: v2,
        y: v2
      });
      oppositeSideMap = {
        left: "right",
        right: "left",
        bottom: "top",
        top: "bottom"
      };
      oppositeAlignmentMap = {
        start: "end",
        end: "start"
      };
    }
  });

  // node_modules/.pnpm/@floating-ui+core@1.6.7/node_modules/@floating-ui/core/dist/floating-ui.core.mjs
  function computeCoordsFromPlacement(_ref, placement, rtl) {
    let {
      reference,
      floating
    } = _ref;
    const sideAxis = getSideAxis(placement);
    const alignmentAxis = getAlignmentAxis(placement);
    const alignLength = getAxisLength(alignmentAxis);
    const side = getSide(placement);
    const isVertical = sideAxis === "y";
    const commonX = reference.x + reference.width / 2 - floating.width / 2;
    const commonY = reference.y + reference.height / 2 - floating.height / 2;
    const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
    let coords;
    switch (side) {
      case "top":
        coords = {
          x: commonX,
          y: reference.y - floating.height
        };
        break;
      case "bottom":
        coords = {
          x: commonX,
          y: reference.y + reference.height
        };
        break;
      case "right":
        coords = {
          x: reference.x + reference.width,
          y: commonY
        };
        break;
      case "left":
        coords = {
          x: reference.x - floating.width,
          y: commonY
        };
        break;
      default:
        coords = {
          x: reference.x,
          y: reference.y
        };
    }
    switch (getAlignment(placement)) {
      case "start":
        coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
        break;
      case "end":
        coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
        break;
    }
    return coords;
  }
  async function detectOverflow(state, options) {
    var _await$platform$isEle;
    if (options === void 0) {
      options = {};
    }
    const {
      x: x2,
      y: y2,
      platform: platform2,
      rects,
      elements,
      strategy
    } = state;
    const {
      boundary = "clippingAncestors",
      rootBoundary = "viewport",
      elementContext = "floating",
      altBoundary = false,
      padding = 0
    } = evaluate(options, state);
    const paddingObject = getPaddingObject(padding);
    const altContext = elementContext === "floating" ? "reference" : "floating";
    const element = elements[altBoundary ? altContext : elementContext];
    const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
      element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
      boundary,
      rootBoundary,
      strategy
    }));
    const rect = elementContext === "floating" ? {
      x: x2,
      y: y2,
      width: rects.floating.width,
      height: rects.floating.height
    } : rects.reference;
    const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
    const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
      x: 1,
      y: 1
    } : {
      x: 1,
      y: 1
    };
    const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
      elements,
      rect,
      offsetParent,
      strategy
    }) : rect);
    return {
      top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
      bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
      left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
      right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
    };
  }
  var computePosition, flip, shift;
  var init_floating_ui_core = __esm({
    "node_modules/.pnpm/@floating-ui+core@1.6.7/node_modules/@floating-ui/core/dist/floating-ui.core.mjs"() {
      init_live_reload();
      init_floating_ui_utils();
      init_floating_ui_utils();
      computePosition = async (reference, floating, config3) => {
        const {
          placement = "bottom",
          strategy = "absolute",
          middleware = [],
          platform: platform2
        } = config3;
        const validMiddleware = middleware.filter(Boolean);
        const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
        let rects = await platform2.getElementRects({
          reference,
          floating,
          strategy
        });
        let {
          x: x2,
          y: y2
        } = computeCoordsFromPlacement(rects, placement, rtl);
        let statefulPlacement = placement;
        let middlewareData = {};
        let resetCount = 0;
        for (let i5 = 0; i5 < validMiddleware.length; i5++) {
          const {
            name,
            fn
          } = validMiddleware[i5];
          const {
            x: nextX,
            y: nextY,
            data,
            reset
          } = await fn({
            x: x2,
            y: y2,
            initialPlacement: placement,
            placement: statefulPlacement,
            strategy,
            middlewareData,
            rects,
            platform: platform2,
            elements: {
              reference,
              floating
            }
          });
          x2 = nextX != null ? nextX : x2;
          y2 = nextY != null ? nextY : y2;
          middlewareData = {
            ...middlewareData,
            [name]: {
              ...middlewareData[name],
              ...data
            }
          };
          if (reset && resetCount <= 50) {
            resetCount++;
            if (typeof reset === "object") {
              if (reset.placement) {
                statefulPlacement = reset.placement;
              }
              if (reset.rects) {
                rects = reset.rects === true ? await platform2.getElementRects({
                  reference,
                  floating,
                  strategy
                }) : reset.rects;
              }
              ({
                x: x2,
                y: y2
              } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
            }
            i5 = -1;
          }
        }
        return {
          x: x2,
          y: y2,
          placement: statefulPlacement,
          strategy,
          middlewareData
        };
      };
      flip = function(options) {
        if (options === void 0) {
          options = {};
        }
        return {
          name: "flip",
          options,
          async fn(state) {
            var _middlewareData$arrow, _middlewareData$flip;
            const {
              placement,
              middlewareData,
              rects,
              initialPlacement,
              platform: platform2,
              elements
            } = state;
            const {
              mainAxis: checkMainAxis = true,
              crossAxis: checkCrossAxis = true,
              fallbackPlacements: specifiedFallbackPlacements,
              fallbackStrategy = "bestFit",
              fallbackAxisSideDirection = "none",
              flipAlignment = true,
              ...detectOverflowOptions
            } = evaluate(options, state);
            if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
              return {};
            }
            const side = getSide(placement);
            const initialSideAxis = getSideAxis(initialPlacement);
            const isBasePlacement = getSide(initialPlacement) === initialPlacement;
            const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
            const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
            const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
            if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
              fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
            }
            const placements2 = [initialPlacement, ...fallbackPlacements];
            const overflow = await detectOverflow(state, detectOverflowOptions);
            const overflows = [];
            let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
            if (checkMainAxis) {
              overflows.push(overflow[side]);
            }
            if (checkCrossAxis) {
              const sides2 = getAlignmentSides(placement, rects, rtl);
              overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
            }
            overflowsData = [...overflowsData, {
              placement,
              overflows
            }];
            if (!overflows.every((side2) => side2 <= 0)) {
              var _middlewareData$flip2, _overflowsData$filter;
              const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
              const nextPlacement = placements2[nextIndex];
              if (nextPlacement) {
                return {
                  data: {
                    index: nextIndex,
                    overflows: overflowsData
                  },
                  reset: {
                    placement: nextPlacement
                  }
                };
              }
              let resetPlacement = (_overflowsData$filter = overflowsData.filter((d2) => d2.overflows[0] <= 0).sort((a4, b2) => a4.overflows[1] - b2.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
              if (!resetPlacement) {
                switch (fallbackStrategy) {
                  case "bestFit": {
                    var _overflowsData$filter2;
                    const placement2 = (_overflowsData$filter2 = overflowsData.filter((d2) => {
                      if (hasFallbackAxisSideDirection) {
                        const currentSideAxis = getSideAxis(d2.placement);
                        return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                        // reading directions favoring greater width.
                        currentSideAxis === "y";
                      }
                      return true;
                    }).map((d2) => [d2.placement, d2.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a4, b2) => a4[1] - b2[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
                    if (placement2) {
                      resetPlacement = placement2;
                    }
                    break;
                  }
                  case "initialPlacement":
                    resetPlacement = initialPlacement;
                    break;
                }
              }
              if (placement !== resetPlacement) {
                return {
                  reset: {
                    placement: resetPlacement
                  }
                };
              }
            }
            return {};
          }
        };
      };
      shift = function(options) {
        if (options === void 0) {
          options = {};
        }
        return {
          name: "shift",
          options,
          async fn(state) {
            const {
              x: x2,
              y: y2,
              placement
            } = state;
            const {
              mainAxis: checkMainAxis = true,
              crossAxis: checkCrossAxis = false,
              limiter = {
                fn: (_ref) => {
                  let {
                    x: x3,
                    y: y3
                  } = _ref;
                  return {
                    x: x3,
                    y: y3
                  };
                }
              },
              ...detectOverflowOptions
            } = evaluate(options, state);
            const coords = {
              x: x2,
              y: y2
            };
            const overflow = await detectOverflow(state, detectOverflowOptions);
            const crossAxis = getSideAxis(getSide(placement));
            const mainAxis = getOppositeAxis(crossAxis);
            let mainAxisCoord = coords[mainAxis];
            let crossAxisCoord = coords[crossAxis];
            if (checkMainAxis) {
              const minSide = mainAxis === "y" ? "top" : "left";
              const maxSide = mainAxis === "y" ? "bottom" : "right";
              const min2 = mainAxisCoord + overflow[minSide];
              const max2 = mainAxisCoord - overflow[maxSide];
              mainAxisCoord = clamp4(min2, mainAxisCoord, max2);
            }
            if (checkCrossAxis) {
              const minSide = crossAxis === "y" ? "top" : "left";
              const maxSide = crossAxis === "y" ? "bottom" : "right";
              const min2 = crossAxisCoord + overflow[minSide];
              const max2 = crossAxisCoord - overflow[maxSide];
              crossAxisCoord = clamp4(min2, crossAxisCoord, max2);
            }
            const limitedCoords = limiter.fn({
              ...state,
              [mainAxis]: mainAxisCoord,
              [crossAxis]: crossAxisCoord
            });
            return {
              ...limitedCoords,
              data: {
                x: limitedCoords.x - x2,
                y: limitedCoords.y - y2
              }
            };
          }
        };
      };
    }
  });

  // node_modules/.pnpm/@floating-ui+utils@0.2.7/node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs
  function getNodeName(node) {
    if (isNode2(node)) {
      return (node.nodeName || "").toLowerCase();
    }
    return "#document";
  }
  function getWindow2(node) {
    var _node$ownerDocument;
    return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
  }
  function getDocumentElement(node) {
    var _ref;
    return (_ref = (isNode2(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
  }
  function isNode2(value) {
    return value instanceof Node || value instanceof getWindow2(value).Node;
  }
  function isElement(value) {
    return value instanceof Element || value instanceof getWindow2(value).Element;
  }
  function isHTMLElement(value) {
    return value instanceof HTMLElement || value instanceof getWindow2(value).HTMLElement;
  }
  function isShadowRoot(value) {
    if (typeof ShadowRoot === "undefined") {
      return false;
    }
    return value instanceof ShadowRoot || value instanceof getWindow2(value).ShadowRoot;
  }
  function isOverflowElement(element) {
    const {
      overflow,
      overflowX,
      overflowY,
      display
    } = getComputedStyle3(element);
    return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
  }
  function isTableElement(element) {
    return ["table", "td", "th"].includes(getNodeName(element));
  }
  function isTopLayer(element) {
    return [":popover-open", ":modal"].some((selector3) => {
      try {
        return element.matches(selector3);
      } catch (e8) {
        return false;
      }
    });
  }
  function isContainingBlock(elementOrCss) {
    const webkit2 = isWebKit();
    const css = isElement(elementOrCss) ? getComputedStyle3(elementOrCss) : elementOrCss;
    return css.transform !== "none" || css.perspective !== "none" || (css.containerType ? css.containerType !== "normal" : false) || !webkit2 && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit2 && (css.filter ? css.filter !== "none" : false) || ["transform", "perspective", "filter"].some((value) => (css.willChange || "").includes(value)) || ["paint", "layout", "strict", "content"].some((value) => (css.contain || "").includes(value));
  }
  function getContainingBlock(element) {
    let currentNode = getParentNode(element);
    while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
      if (isContainingBlock(currentNode)) {
        return currentNode;
      } else if (isTopLayer(currentNode)) {
        return null;
      }
      currentNode = getParentNode(currentNode);
    }
    return null;
  }
  function isWebKit() {
    if (typeof CSS === "undefined" || !CSS.supports)
      return false;
    return CSS.supports("-webkit-backdrop-filter", "none");
  }
  function isLastTraversableNode(node) {
    return ["html", "body", "#document"].includes(getNodeName(node));
  }
  function getComputedStyle3(element) {
    return getWindow2(element).getComputedStyle(element);
  }
  function getNodeScroll(element) {
    if (isElement(element)) {
      return {
        scrollLeft: element.scrollLeft,
        scrollTop: element.scrollTop
      };
    }
    return {
      scrollLeft: element.scrollX,
      scrollTop: element.scrollY
    };
  }
  function getParentNode(node) {
    if (getNodeName(node) === "html") {
      return node;
    }
    const result = (
      // Step into the shadow DOM of the parent of a slotted node.
      node.assignedSlot || // DOM Element detected.
      node.parentNode || // ShadowRoot detected.
      isShadowRoot(node) && node.host || // Fallback.
      getDocumentElement(node)
    );
    return isShadowRoot(result) ? result.host : result;
  }
  function getNearestOverflowAncestor(node) {
    const parentNode = getParentNode(node);
    if (isLastTraversableNode(parentNode)) {
      return node.ownerDocument ? node.ownerDocument.body : node.body;
    }
    if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
      return parentNode;
    }
    return getNearestOverflowAncestor(parentNode);
  }
  function getOverflowAncestors(node, list, traverseIframes) {
    var _node$ownerDocument2;
    if (list === void 0) {
      list = [];
    }
    if (traverseIframes === void 0) {
      traverseIframes = true;
    }
    const scrollableAncestor = getNearestOverflowAncestor(node);
    const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
    const win = getWindow2(scrollableAncestor);
    if (isBody) {
      const frameElement = getFrameElement(win);
      return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
    }
    return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
  }
  function getFrameElement(win) {
    return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
  }
  var init_floating_ui_utils_dom = __esm({
    "node_modules/.pnpm/@floating-ui+utils@0.2.7/node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs"() {
      init_live_reload();
    }
  });

  // node_modules/.pnpm/@floating-ui+dom@1.6.10/node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs
  function getCssDimensions(element) {
    const css = getComputedStyle3(element);
    let width = parseFloat(css.width) || 0;
    let height = parseFloat(css.height) || 0;
    const hasOffset = isHTMLElement(element);
    const offsetWidth = hasOffset ? element.offsetWidth : width;
    const offsetHeight = hasOffset ? element.offsetHeight : height;
    const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
    if (shouldFallback) {
      width = offsetWidth;
      height = offsetHeight;
    }
    return {
      width,
      height,
      $: shouldFallback
    };
  }
  function unwrapElement(element) {
    return !isElement(element) ? element.contextElement : element;
  }
  function getScale(element) {
    const domElement = unwrapElement(element);
    if (!isHTMLElement(domElement)) {
      return createCoords(1);
    }
    const rect = domElement.getBoundingClientRect();
    const {
      width,
      height,
      $: $3
    } = getCssDimensions(domElement);
    let x2 = ($3 ? round(rect.width) : rect.width) / width;
    let y2 = ($3 ? round(rect.height) : rect.height) / height;
    if (!x2 || !Number.isFinite(x2)) {
      x2 = 1;
    }
    if (!y2 || !Number.isFinite(y2)) {
      y2 = 1;
    }
    return {
      x: x2,
      y: y2
    };
  }
  function getVisualOffsets(element) {
    const win = getWindow2(element);
    if (!isWebKit() || !win.visualViewport) {
      return noOffsets;
    }
    return {
      x: win.visualViewport.offsetLeft,
      y: win.visualViewport.offsetTop
    };
  }
  function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
    if (isFixed === void 0) {
      isFixed = false;
    }
    if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow2(element)) {
      return false;
    }
    return isFixed;
  }
  function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
    if (includeScale === void 0) {
      includeScale = false;
    }
    if (isFixedStrategy === void 0) {
      isFixedStrategy = false;
    }
    const clientRect = element.getBoundingClientRect();
    const domElement = unwrapElement(element);
    let scale = createCoords(1);
    if (includeScale) {
      if (offsetParent) {
        if (isElement(offsetParent)) {
          scale = getScale(offsetParent);
        }
      } else {
        scale = getScale(element);
      }
    }
    const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
    let x2 = (clientRect.left + visualOffsets.x) / scale.x;
    let y2 = (clientRect.top + visualOffsets.y) / scale.y;
    let width = clientRect.width / scale.x;
    let height = clientRect.height / scale.y;
    if (domElement) {
      const win = getWindow2(domElement);
      const offsetWin = offsetParent && isElement(offsetParent) ? getWindow2(offsetParent) : offsetParent;
      let currentWin = win;
      let currentIFrame = getFrameElement(currentWin);
      while (currentIFrame && offsetParent && offsetWin !== currentWin) {
        const iframeScale = getScale(currentIFrame);
        const iframeRect = currentIFrame.getBoundingClientRect();
        const css = getComputedStyle3(currentIFrame);
        const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
        const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
        x2 *= iframeScale.x;
        y2 *= iframeScale.y;
        width *= iframeScale.x;
        height *= iframeScale.y;
        x2 += left;
        y2 += top;
        currentWin = getWindow2(currentIFrame);
        currentIFrame = getFrameElement(currentWin);
      }
    }
    return rectToClientRect({
      width,
      height,
      x: x2,
      y: y2
    });
  }
  function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
    let {
      elements,
      rect,
      offsetParent,
      strategy
    } = _ref;
    const isFixed = strategy === "fixed";
    const documentElement = getDocumentElement(offsetParent);
    const topLayer = elements ? isTopLayer(elements.floating) : false;
    if (offsetParent === documentElement || topLayer && isFixed) {
      return rect;
    }
    let scroll = {
      scrollLeft: 0,
      scrollTop: 0
    };
    let scale = createCoords(1);
    const offsets = createCoords(0);
    const isOffsetParentAnElement = isHTMLElement(offsetParent);
    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
      if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
        scroll = getNodeScroll(offsetParent);
      }
      if (isHTMLElement(offsetParent)) {
        const offsetRect = getBoundingClientRect(offsetParent);
        scale = getScale(offsetParent);
        offsets.x = offsetRect.x + offsetParent.clientLeft;
        offsets.y = offsetRect.y + offsetParent.clientTop;
      }
    }
    return {
      width: rect.width * scale.x,
      height: rect.height * scale.y,
      x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,
      y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y
    };
  }
  function getClientRects(element) {
    return Array.from(element.getClientRects());
  }
  function getWindowScrollBarX(element) {
    return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;
  }
  function getDocumentRect(element) {
    const html = getDocumentElement(element);
    const scroll = getNodeScroll(element);
    const body = element.ownerDocument.body;
    const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
    const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
    let x2 = -scroll.scrollLeft + getWindowScrollBarX(element);
    const y2 = -scroll.scrollTop;
    if (getComputedStyle3(body).direction === "rtl") {
      x2 += max(html.clientWidth, body.clientWidth) - width;
    }
    return {
      width,
      height,
      x: x2,
      y: y2
    };
  }
  function getViewportRect(element, strategy) {
    const win = getWindow2(element);
    const html = getDocumentElement(element);
    const visualViewport = win.visualViewport;
    let width = html.clientWidth;
    let height = html.clientHeight;
    let x2 = 0;
    let y2 = 0;
    if (visualViewport) {
      width = visualViewport.width;
      height = visualViewport.height;
      const visualViewportBased = isWebKit();
      if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
        x2 = visualViewport.offsetLeft;
        y2 = visualViewport.offsetTop;
      }
    }
    return {
      width,
      height,
      x: x2,
      y: y2
    };
  }
  function getInnerBoundingClientRect(element, strategy) {
    const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
    const top = clientRect.top + element.clientTop;
    const left = clientRect.left + element.clientLeft;
    const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);
    const width = element.clientWidth * scale.x;
    const height = element.clientHeight * scale.y;
    const x2 = left * scale.x;
    const y2 = top * scale.y;
    return {
      width,
      height,
      x: x2,
      y: y2
    };
  }
  function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
    let rect;
    if (clippingAncestor === "viewport") {
      rect = getViewportRect(element, strategy);
    } else if (clippingAncestor === "document") {
      rect = getDocumentRect(getDocumentElement(element));
    } else if (isElement(clippingAncestor)) {
      rect = getInnerBoundingClientRect(clippingAncestor, strategy);
    } else {
      const visualOffsets = getVisualOffsets(element);
      rect = {
        ...clippingAncestor,
        x: clippingAncestor.x - visualOffsets.x,
        y: clippingAncestor.y - visualOffsets.y
      };
    }
    return rectToClientRect(rect);
  }
  function hasFixedPositionAncestor(element, stopNode) {
    const parentNode = getParentNode(element);
    if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
      return false;
    }
    return getComputedStyle3(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
  }
  function getClippingElementAncestors(element, cache2) {
    const cachedResult = cache2.get(element);
    if (cachedResult) {
      return cachedResult;
    }
    let result = getOverflowAncestors(element, [], false).filter((el) => isElement(el) && getNodeName(el) !== "body");
    let currentContainingBlockComputedStyle = null;
    const elementIsFixed = getComputedStyle3(element).position === "fixed";
    let currentNode = elementIsFixed ? getParentNode(element) : element;
    while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
      const computedStyle = getComputedStyle3(currentNode);
      const currentNodeIsContaining = isContainingBlock(currentNode);
      if (!currentNodeIsContaining && computedStyle.position === "fixed") {
        currentContainingBlockComputedStyle = null;
      }
      const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
      if (shouldDropCurrentNode) {
        result = result.filter((ancestor) => ancestor !== currentNode);
      } else {
        currentContainingBlockComputedStyle = computedStyle;
      }
      currentNode = getParentNode(currentNode);
    }
    cache2.set(element, result);
    return result;
  }
  function getClippingRect(_ref) {
    let {
      element,
      boundary,
      rootBoundary,
      strategy
    } = _ref;
    const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
    const clippingAncestors = [...elementClippingAncestors, rootBoundary];
    const firstClippingAncestor = clippingAncestors[0];
    const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
      const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
      accRect.top = max(rect.top, accRect.top);
      accRect.right = min(rect.right, accRect.right);
      accRect.bottom = min(rect.bottom, accRect.bottom);
      accRect.left = max(rect.left, accRect.left);
      return accRect;
    }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
    return {
      width: clippingRect.right - clippingRect.left,
      height: clippingRect.bottom - clippingRect.top,
      x: clippingRect.left,
      y: clippingRect.top
    };
  }
  function getDimensions(element) {
    const {
      width,
      height
    } = getCssDimensions(element);
    return {
      width,
      height
    };
  }
  function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
    const isOffsetParentAnElement = isHTMLElement(offsetParent);
    const documentElement = getDocumentElement(offsetParent);
    const isFixed = strategy === "fixed";
    const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
    let scroll = {
      scrollLeft: 0,
      scrollTop: 0
    };
    const offsets = createCoords(0);
    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
      if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
        scroll = getNodeScroll(offsetParent);
      }
      if (isOffsetParentAnElement) {
        const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
        offsets.x = offsetRect.x + offsetParent.clientLeft;
        offsets.y = offsetRect.y + offsetParent.clientTop;
      } else if (documentElement) {
        offsets.x = getWindowScrollBarX(documentElement);
      }
    }
    const x2 = rect.left + scroll.scrollLeft - offsets.x;
    const y2 = rect.top + scroll.scrollTop - offsets.y;
    return {
      x: x2,
      y: y2,
      width: rect.width,
      height: rect.height
    };
  }
  function isStaticPositioned(element) {
    return getComputedStyle3(element).position === "static";
  }
  function getTrueOffsetParent(element, polyfill) {
    if (!isHTMLElement(element) || getComputedStyle3(element).position === "fixed") {
      return null;
    }
    if (polyfill) {
      return polyfill(element);
    }
    return element.offsetParent;
  }
  function getOffsetParent(element, polyfill) {
    const win = getWindow2(element);
    if (isTopLayer(element)) {
      return win;
    }
    if (!isHTMLElement(element)) {
      let svgOffsetParent = getParentNode(element);
      while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
        if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
          return svgOffsetParent;
        }
        svgOffsetParent = getParentNode(svgOffsetParent);
      }
      return win;
    }
    let offsetParent = getTrueOffsetParent(element, polyfill);
    while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
      offsetParent = getTrueOffsetParent(offsetParent, polyfill);
    }
    if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
      return win;
    }
    return offsetParent || getContainingBlock(element) || win;
  }
  function isRTL(element) {
    return getComputedStyle3(element).direction === "rtl";
  }
  function observeMove(element, onMove) {
    let io = null;
    let timeoutId;
    const root2 = getDocumentElement(element);
    function cleanup2() {
      var _io;
      clearTimeout(timeoutId);
      (_io = io) == null || _io.disconnect();
      io = null;
    }
    function refresh(skip, threshold) {
      if (skip === void 0) {
        skip = false;
      }
      if (threshold === void 0) {
        threshold = 1;
      }
      cleanup2();
      const {
        left,
        top,
        width,
        height
      } = element.getBoundingClientRect();
      if (!skip) {
        onMove();
      }
      if (!width || !height) {
        return;
      }
      const insetTop = floor(top);
      const insetRight = floor(root2.clientWidth - (left + width));
      const insetBottom = floor(root2.clientHeight - (top + height));
      const insetLeft = floor(left);
      const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
      const options = {
        rootMargin,
        threshold: max(0, min(1, threshold)) || 1
      };
      let isFirstUpdate = true;
      function handleObserve(entries) {
        const ratio = entries[0].intersectionRatio;
        if (ratio !== threshold) {
          if (!isFirstUpdate) {
            return refresh();
          }
          if (!ratio) {
            timeoutId = setTimeout(() => {
              refresh(false, 1e-7);
            }, 1e3);
          } else {
            refresh(false, ratio);
          }
        }
        isFirstUpdate = false;
      }
      try {
        io = new IntersectionObserver(handleObserve, {
          ...options,
          // Handle <iframe>s
          root: root2.ownerDocument
        });
      } catch (e8) {
        io = new IntersectionObserver(handleObserve, options);
      }
      io.observe(element);
    }
    refresh(true);
    return cleanup2;
  }
  function autoUpdate(reference, floating, update3, options) {
    if (options === void 0) {
      options = {};
    }
    const {
      ancestorScroll = true,
      ancestorResize = true,
      elementResize = typeof ResizeObserver === "function",
      layoutShift = typeof IntersectionObserver === "function",
      animationFrame = false
    } = options;
    const referenceEl = unwrapElement(reference);
    const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.addEventListener("scroll", update3, {
        passive: true
      });
      ancestorResize && ancestor.addEventListener("resize", update3);
    });
    const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update3) : null;
    let reobserveFrame = -1;
    let resizeObserver = null;
    if (elementResize) {
      resizeObserver = new ResizeObserver((_ref) => {
        let [firstEntry] = _ref;
        if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
          resizeObserver.unobserve(floating);
          cancelAnimationFrame(reobserveFrame);
          reobserveFrame = requestAnimationFrame(() => {
            var _resizeObserver;
            (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
          });
        }
        update3();
      });
      if (referenceEl && !animationFrame) {
        resizeObserver.observe(referenceEl);
      }
      resizeObserver.observe(floating);
    }
    let frameId;
    let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
    if (animationFrame) {
      frameLoop();
    }
    function frameLoop() {
      const nextRefRect = getBoundingClientRect(reference);
      if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {
        update3();
      }
      prevRefRect = nextRefRect;
      frameId = requestAnimationFrame(frameLoop);
    }
    update3();
    return () => {
      var _resizeObserver2;
      ancestors.forEach((ancestor) => {
        ancestorScroll && ancestor.removeEventListener("scroll", update3);
        ancestorResize && ancestor.removeEventListener("resize", update3);
      });
      cleanupIo == null || cleanupIo();
      (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
      resizeObserver = null;
      if (animationFrame) {
        cancelAnimationFrame(frameId);
      }
    };
  }
  var noOffsets, getElementRects, platform, shift2, flip2, computePosition2;
  var init_floating_ui_dom = __esm({
    "node_modules/.pnpm/@floating-ui+dom@1.6.10/node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs"() {
      init_live_reload();
      init_floating_ui_core();
      init_floating_ui_utils();
      init_floating_ui_utils_dom();
      noOffsets = /* @__PURE__ */ createCoords(0);
      getElementRects = async function(data) {
        const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
        const getDimensionsFn = this.getDimensions;
        const floatingDimensions = await getDimensionsFn(data.floating);
        return {
          reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
          floating: {
            x: 0,
            y: 0,
            width: floatingDimensions.width,
            height: floatingDimensions.height
          }
        };
      };
      platform = {
        convertOffsetParentRelativeRectToViewportRelativeRect,
        getDocumentElement,
        getClippingRect,
        getOffsetParent,
        getElementRects,
        getClientRects,
        getDimensions,
        getScale,
        isElement,
        isRTL
      };
      shift2 = shift;
      flip2 = flip;
      computePosition2 = (reference, floating, options) => {
        const cache2 = /* @__PURE__ */ new Map();
        const mergedOptions = {
          platform,
          ...options
        };
        const platformWithCache = {
          ...mergedOptions.platform,
          _c: cache2
        };
        return computePosition(reference, floating, {
          ...mergedOptions,
          platform: platformWithCache
        });
      };
    }
  });

  // node_modules/.pnpm/vidstack@1.12.9/node_modules/vidstack/prod/chunks/vidstack-Ds_q5BGO.js
  function isEventInside(el, event2) {
    const target = event2.composedPath()[0];
    return isDOMNode(target) && el.contains(target);
  }
  function scheduleRafJob(job) {
    rafJobs.add(job);
    return () => rafJobs.delete(job);
  }
  function setAttributeIfEmpty(target, name, value) {
    if (!target.hasAttribute(name))
      target.setAttribute(name, value);
  }
  function setARIALabel(target, $label) {
    if (target.hasAttribute("aria-label") || target.hasAttribute("data-no-label"))
      return;
    if (!isFunction($label)) {
      setAttribute(target, "aria-label", $label);
      return;
    }
    function updateAriaDescription() {
      setAttribute(target, "aria-label", $label());
    }
    effect(updateAriaDescription);
  }
  function isElementVisible(el) {
    const style = getComputedStyle(el);
    return style.display !== "none" && parseInt(style.opacity) > 0;
  }
  function checkVisibility(el) {
    return !!el && ("checkVisibility" in el ? el.checkVisibility({ checkOpacity: true, checkVisibilityCSS: true }) : isElementVisible(el));
  }
  function observeVisibility(el, callback) {
    return scheduleRafJob(() => callback(checkVisibility(el)));
  }
  function isElementParent(owner, node, test) {
    while (node) {
      if (node === owner) {
        return true;
      } else if (test?.(node)) {
        break;
      } else {
        node = node.parentElement;
      }
    }
    return false;
  }
  function onPress(target, handler) {
    return new EventsController(target).add("pointerup", (event2) => {
      if (event2.button === 0 && !event2.defaultPrevented)
        handler(event2);
    }).add("keydown", (event2) => {
      if (isKeyboardClick(event2))
        handler(event2);
    });
  }
  function isTouchPinchEvent(event2) {
    return isTouchEvent(event2) && (event2.touches.length > 1 || event2.changedTouches.length > 1);
  }
  function requestScopedAnimationFrame(callback) {
    let scope = getScope(), id = window.requestAnimationFrame(() => {
      scoped(callback, scope);
      id = -1;
    });
    return () => void window.cancelAnimationFrame(id);
  }
  function cloneTemplate(template, length, onCreate) {
    let current, prev = template, parent = template.parentElement, content = template.content.firstElementChild, elements = [];
    if (!content && template.firstElementChild) {
      template.innerHTML = template.firstElementChild.outerHTML;
      template.firstElementChild.remove();
      content = template.content.firstElementChild;
    }
    for (let i5 = 0; i5 < length; i5++) {
      current = document.importNode(content, true);
      onCreate?.(current, i5);
      parent.insertBefore(current, prev.nextSibling);
      elements.push(current);
      prev = current;
    }
    onDispose(() => {
      for (let i5 = 0; i5 < elements.length; i5++)
        elements[i5].remove();
    });
    return elements;
  }
  function createTemplate(content) {
    const template = document.createElement("template");
    template.innerHTML = content;
    return template.content;
  }
  function cloneTemplateContent(content) {
    const fragment = content.cloneNode(true);
    return fragment.firstElementChild;
  }
  function autoPlacement2(el, trigger, placement, {
    offsetVarName,
    xOffset,
    yOffset,
    ...options
  }) {
    if (!el)
      return;
    const floatingPlacement = placement.replace(" ", "-").replace("-center", "");
    setStyle(el, "visibility", !trigger ? "hidden" : null);
    if (!trigger)
      return;
    let isTop = placement.includes("top");
    const negateX = (x2) => placement.includes("left") ? `calc(-1 * ${x2})` : x2, negateY = (y2) => isTop ? `calc(-1 * ${y2})` : y2;
    return autoUpdate(trigger, el, () => {
      computePosition2(trigger, el, {
        placement: floatingPlacement,
        middleware: [
          ...options.middleware ?? [],
          flip2({ fallbackAxisSideDirection: "start", crossAxis: false }),
          shift2()
        ],
        ...options
      }).then(({ x: x2, y: y2, middlewareData }) => {
        const hasFlipped = !!middlewareData.flip?.index;
        isTop = placement.includes(hasFlipped ? "bottom" : "top");
        el.setAttribute(
          "data-placement",
          hasFlipped ? placement.startsWith("top") ? placement.replace("top", "bottom") : placement.replace("bottom", "top") : placement
        );
        Object.assign(el.style, {
          top: `calc(${y2 + "px"} + ${negateY(
            yOffset ? yOffset + "px" : `var(--${offsetVarName}-y-offset, 0px)`
          )})`,
          left: `calc(${x2 + "px"} + ${negateX(
            xOffset ? xOffset + "px" : `var(--${offsetVarName}-x-offset, 0px)`
          )})`
        });
      });
    });
  }
  function hasAnimation(el) {
    const styles = getComputedStyle(el);
    return styles.animationName !== "none";
  }
  function isHTMLElement2(el) {
    return el instanceof HTMLElement;
  }
  var rafJobs;
  var init_vidstack_Ds_q5BGO = __esm({
    "node_modules/.pnpm/vidstack@1.12.9/node_modules/vidstack/prod/chunks/vidstack-Ds_q5BGO.js"() {
      init_live_reload();
      init_floating_ui_dom();
      init_vidstack_CRlI3Mh7();
      rafJobs = /* @__PURE__ */ new Set();
      {
        let processJobs = function() {
          for (const job of rafJobs) {
            try {
              job();
            } catch (e8) {
            }
          }
          window.requestAnimationFrame(processJobs);
        };
        processJobs();
      }
    }
  });

  // node_modules/.pnpm/vidstack@1.12.9/node_modules/vidstack/prod/chunks/vidstack-BOTZD4tC.js
  function sortVideoQualities(qualities, desc) {
    return [...qualities].sort(desc ? compareVideoQualityDesc : compareVideoQualityAsc);
  }
  function compareVideoQualityAsc(a4, b2) {
    return a4.height === b2.height ? (a4.bitrate ?? 0) - (b2.bitrate ?? 0) : a4.height - b2.height;
  }
  function compareVideoQualityDesc(a4, b2) {
    return b2.height === a4.height ? (b2.bitrate ?? 0) - (a4.bitrate ?? 0) : b2.height - a4.height;
  }
  function ariaBool2(value) {
    return value ? "true" : "false";
  }
  function $ariaBool(signal2) {
    return () => ariaBool2(signal2());
  }
  var init_vidstack_BOTZD4tC = __esm({
    "node_modules/.pnpm/vidstack@1.12.9/node_modules/vidstack/prod/chunks/vidstack-BOTZD4tC.js"() {
      init_live_reload();
    }
  });

  // node_modules/.pnpm/vidstack@1.12.9/node_modules/vidstack/prod/chunks/vidstack-DyMkFGuS.js
  function canOrientScreen() {
    return canRotateScreen() && isFunction(screen.orientation.unlock);
  }
  function canRotateScreen() {
    return !isUndefined(window.screen.orientation) && !isUndefined(window.screen.orientation.lock);
  }
  function canPlayAudioType(audio, type) {
    if (!audio)
      audio = document.createElement("audio");
    return audio.canPlayType(type).length > 0;
  }
  function canPlayVideoType(video, type) {
    if (!video)
      video = document.createElement("video");
    return video.canPlayType(type).length > 0;
  }
  function canPlayHLSNatively(video) {
    if (!video)
      video = document.createElement("video");
    return video.canPlayType("application/vnd.apple.mpegurl").length > 0;
  }
  function canUsePictureInPicture(video) {
    return !!document.pictureInPictureEnabled && !video?.disablePictureInPicture;
  }
  function canUseVideoPresentation(video) {
    return isFunction(video?.webkitSupportsPresentationMode) && isFunction(video?.webkitSetPresentationMode);
  }
  async function canChangeVolume() {
    const video = document.createElement("video");
    video.volume = 0.5;
    await waitTimeout(0);
    return video.volume === 0.5;
  }
  function getMediaSource() {
    return window?.ManagedMediaSource ?? window?.MediaSource ?? window?.WebKitMediaSource;
  }
  function getSourceBuffer() {
    return window?.SourceBuffer ?? window?.WebKitSourceBuffer;
  }
  function isHLSSupported() {
    const MediaSource = getMediaSource();
    if (isUndefined(MediaSource))
      return false;
    const isTypeSupported = MediaSource && isFunction(MediaSource.isTypeSupported) && MediaSource.isTypeSupported('video/mp4; codecs="avc1.42E01E,mp4a.40.2"');
    const SourceBuffer = getSourceBuffer();
    const isSourceBufferValid = isUndefined(SourceBuffer) || !isUndefined(SourceBuffer.prototype) && isFunction(SourceBuffer.prototype.appendBuffer) && isFunction(SourceBuffer.prototype.remove);
    return !!isTypeSupported && !!isSourceBufferValid;
  }
  function isDASHSupported() {
    return isHLSSupported();
  }
  function isAudioSrc({ src, type }) {
    return isString(src) ? AUDIO_EXTENSIONS.test(src) || AUDIO_TYPES.has(type) || src.startsWith("blob:") && type === "audio/object" : type === "audio/object";
  }
  function isVideoSrc(src) {
    return isString(src.src) ? VIDEO_EXTENSIONS.test(src.src) || VIDEO_TYPES.has(src.type) || src.src.startsWith("blob:") && src.type === "video/object" || isHLSSrc(src) && canPlayHLSNatively() : src.type === "video/object";
  }
  function isHLSSrc({ src, type }) {
    return isString(src) && HLS_VIDEO_EXTENSIONS.test(src) || HLS_VIDEO_TYPES.has(type);
  }
  function isDASHSrc({ src, type }) {
    return isString(src) && DASH_VIDEO_EXTENSIONS.test(src) || DASH_VIDEO_TYPES.has(type);
  }
  function canGoogleCastSrc(src) {
    return isString(src.src) && (isAudioSrc(src) || isVideoSrc(src) || isHLSSrc(src));
  }
  function isMediaStream(src) {
    return typeof window.MediaStream !== "undefined" && src instanceof window.MediaStream;
  }
  var UA, IS_IOS, IS_IPHONE, IS_CHROME, IS_SAFARI, AUDIO_EXTENSIONS, AUDIO_TYPES, VIDEO_EXTENSIONS, VIDEO_TYPES, HLS_VIDEO_EXTENSIONS, DASH_VIDEO_EXTENSIONS, HLS_VIDEO_TYPES, DASH_VIDEO_TYPES;
  var init_vidstack_DyMkFGuS = __esm({
    "node_modules/.pnpm/vidstack@1.12.9/node_modules/vidstack/prod/chunks/vidstack-DyMkFGuS.js"() {
      init_live_reload();
      init_vidstack_CRlI3Mh7();
      UA = navigator?.userAgent.toLowerCase() || "";
      IS_IOS = /iphone|ipad|ipod|ios|crios|fxios/i.test(UA);
      IS_IPHONE = /(iphone|ipod)/gi.test(navigator?.platform || "");
      IS_CHROME = !!window.chrome;
      IS_SAFARI = !!window.safari || IS_IOS;
      AUDIO_EXTENSIONS = /\.(m4a|m4b|mp4a|mpga|mp2|mp2a|mp3|m2a|m3a|wav|weba|aac|oga|spx|flac)($|\?)/i;
      AUDIO_TYPES = /* @__PURE__ */ new Set([
        "audio/mpeg",
        "audio/ogg",
        "audio/3gp",
        "audio/mp3",
        "audio/webm",
        "audio/flac",
        "audio/m4a",
        "audio/m4b",
        "audio/mp4a"
      ]);
      VIDEO_EXTENSIONS = /\.(mp4|og[gv]|webm|mov|m4v)(#t=[,\d+]+)?($|\?)/i;
      VIDEO_TYPES = /* @__PURE__ */ new Set([
        "video/mp4",
        "video/webm",
        "video/3gp",
        "video/ogg",
        "video/avi",
        "video/mpeg"
      ]);
      HLS_VIDEO_EXTENSIONS = /\.(m3u8)($|\?)/i;
      DASH_VIDEO_EXTENSIONS = /\.(mpd)($|\?)/i;
      HLS_VIDEO_TYPES = /* @__PURE__ */ new Set([
        // Apple sanctioned
        "application/vnd.apple.mpegurl",
        // Apple sanctioned for backwards compatibility
        "audio/mpegurl",
        // Very common
        "audio/x-mpegurl",
        // Very common
        "application/x-mpegurl",
        // Included for completeness
        "video/x-mpegurl",
        "video/mpegurl",
        "application/mpegurl"
      ]);
      DASH_VIDEO_TYPES = /* @__PURE__ */ new Set(["application/dash+xml"]);
    }
  });

  // node_modules/.pnpm/vidstack@1.12.9/node_modules/vidstack/prod/chunks/vidstack-vDnjyKV8.js
  function appendParamsToURL(baseUrl, params) {
    const searchParams = new URLSearchParams();
    for (const key2 of Object.keys(params)) {
      searchParams.set(key2, params[key2] + "");
    }
    return baseUrl + "?" + searchParams.toString();
  }
  function preconnect(url, rel = "preconnect") {
    const exists = document.querySelector(`link[href="${url}"]`);
    if (!isNull(exists))
      return true;
    const link = document.createElement("link");
    link.rel = rel;
    link.href = url;
    link.crossOrigin = "true";
    document.head.append(link);
    return true;
  }
  function loadScript(src) {
    if (pendingRequests[src])
      return pendingRequests[src].promise;
    const promise = deferredPromise(), exists = document.querySelector(`script[src="${src}"]`);
    if (!isNull(exists)) {
      promise.resolve();
      return promise.promise;
    }
    const script = document.createElement("script");
    script.src = src;
    script.onload = () => {
      promise.resolve();
      delete pendingRequests[src];
    };
    script.onerror = () => {
      promise.reject();
      delete pendingRequests[src];
    };
    setTimeout(() => document.head.append(script), 0);
    return promise.promise;
  }
  function getRequestCredentials(crossOrigin) {
    return crossOrigin === "use-credentials" ? "include" : isString(crossOrigin) ? "same-origin" : void 0;
  }
  var pendingRequests;
  var init_vidstack_vDnjyKV8 = __esm({
    "node_modules/.pnpm/vidstack@1.12.9/node_modules/vidstack/prod/chunks/vidstack-vDnjyKV8.js"() {
      init_live_reload();
      init_vidstack_CRlI3Mh7();
      pendingRequests = {};
    }
  });

  // node_modules/.pnpm/vidstack@1.12.9/node_modules/vidstack/prod/chunks/vidstack-DE4XvkHU.js
  function isCueActive(cue, time) {
    return time >= cue.startTime && time < cue.endTime;
  }
  function watchActiveTextTrack(tracks, kind, onChange) {
    let currentTrack = null, scope = getScope();
    function onModeChange() {
      const kinds = isString(kind) ? [kind] : kind, track = tracks.toArray().find((track2) => kinds.includes(track2.kind) && track2.mode === "showing");
      if (track === currentTrack)
        return;
      if (!track) {
        onChange(null);
        currentTrack = null;
        return;
      }
      if (track.readyState == 2) {
        onChange(track);
      } else {
        onChange(null);
        scoped(() => {
          const off = listenEvent(
            track,
            "load",
            () => {
              onChange(track);
              off();
            },
            { once: true }
          );
        }, scope);
      }
      currentTrack = track;
    }
    onModeChange();
    return listenEvent(tracks, "mode-change", onModeChange);
  }
  var init_vidstack_DE4XvkHU = __esm({
    "node_modules/.pnpm/vidstack@1.12.9/node_modules/vidstack/prod/chunks/vidstack-DE4XvkHU.js"() {
      init_live_reload();
      init_vidstack_CRlI3Mh7();
    }
  });

  // node_modules/.pnpm/media-captions@1.0.4/node_modules/media-captions/dist/prod/srt-parser.js
  var srt_parser_exports = {};
  __export(srt_parser_exports, {
    SRTParser: () => SRTParser,
    default: () => createSRTParser
  });
  function createSRTParser() {
    return new SRTParser();
  }
  var MILLISECOND_SEP_RE, TIMESTAMP_SEP, SRTParser;
  var init_srt_parser = __esm({
    "node_modules/.pnpm/media-captions@1.0.4/node_modules/media-captions/dist/prod/srt-parser.js"() {
      init_live_reload();
      init_prod();
      MILLISECOND_SEP_RE = /,/g;
      TIMESTAMP_SEP = "-->";
      SRTParser = class extends VTTParser {
        parse(line, lineCount) {
          if (line === "") {
            if (this.c) {
              this.l.push(this.c);
              this.h.onCue?.(this.c);
              this.c = null;
            }
            this.e = VTTBlock.None;
          } else if (this.e === VTTBlock.Cue) {
            this.c.text += (this.c.text ? "\n" : "") + line;
          } else if (line.includes(TIMESTAMP_SEP)) {
            const result = this.q(line, lineCount);
            if (result) {
              this.c = new VTTCue(result[0], result[1], result[2].join(" "));
              this.c.id = this.n;
              this.e = VTTBlock.Cue;
            }
          }
          this.n = line;
        }
        q(line, lineCount) {
          return super.q(line.replace(MILLISECOND_SEP_RE, "."), lineCount);
        }
      };
    }
  });

  // node_modules/.pnpm/media-captions@1.0.4/node_modules/media-captions/dist/prod/errors.js
  var errors_exports = {};
  __export(errors_exports, {
    ParseErrorBuilder: () => ParseErrorBuilder
  });
  var ParseErrorBuilder;
  var init_errors = __esm({
    "node_modules/.pnpm/media-captions@1.0.4/node_modules/media-captions/dist/prod/errors.js"() {
      init_live_reload();
      init_prod();
      ParseErrorBuilder = {
        r() {
          return new ParseError({
            code: ParseErrorCode.BadSignature,
            reason: "missing WEBVTT file header",
            line: 1
          });
        },
        s(startTime, line) {
          return new ParseError({
            code: ParseErrorCode.BadTimestamp,
            reason: `cue start timestamp \`${startTime}\` is invalid on line ${line}`,
            line
          });
        },
        t(endTime, line) {
          return new ParseError({
            code: ParseErrorCode.BadTimestamp,
            reason: `cue end timestamp \`${endTime}\` is invalid on line ${line}`,
            line
          });
        },
        u(startTime, endTime, line) {
          return new ParseError({
            code: ParseErrorCode.BadTimestamp,
            reason: `cue end timestamp \`${endTime}\` is greater than start \`${startTime}\` on line ${line}`,
            line
          });
        },
        y(name, value, line) {
          return new ParseError({
            code: ParseErrorCode.BadSettingValue,
            reason: `invalid value for cue setting \`${name}\` on line ${line} (value: ${value})`,
            line
          });
        },
        x(name, value, line) {
          return new ParseError({
            code: ParseErrorCode.UnknownSetting,
            reason: `unknown cue setting \`${name}\` on line ${line} (value: ${value})`,
            line
          });
        },
        w(name, value, line) {
          return new ParseError({
            code: ParseErrorCode.BadSettingValue,
            reason: `invalid value for region setting \`${name}\` on line ${line} (value: ${value})`,
            line
          });
        },
        v(name, value, line) {
          return new ParseError({
            code: ParseErrorCode.UnknownSetting,
            reason: `unknown region setting \`${name}\` on line ${line} (value: ${value})`,
            line
          });
        },
        // SSA-specific errors
        T(type, line) {
          return new ParseError({
            code: ParseErrorCode.BadFormat,
            reason: `format missing for \`${type}\` block on line ${line}`,
            line
          });
        }
      };
    }
  });

  // node_modules/.pnpm/media-captions@1.0.4/node_modules/media-captions/dist/prod/ssa-parser.js
  var ssa_parser_exports = {};
  __export(ssa_parser_exports, {
    SSAParser: () => SSAParser,
    default: () => createSSAParser
  });
  function parseColor(color) {
    const abgr = parseInt(color.replace("&H", ""), 16);
    if (abgr >= 0) {
      const a4 = abgr >> 24 & 255 ^ 255;
      const alpha = a4 / 255;
      const b2 = abgr >> 16 & 255;
      const g2 = abgr >> 8 & 255;
      const r5 = abgr & 255;
      return "rgba(" + [r5, g2, b2, alpha].join(",") + ")";
    }
    return null;
  }
  function buildTextShadow(x2, y2, color) {
    const noOfShadows = Math.ceil(2 * Math.PI * x2);
    let textShadow = "";
    for (let i5 = 0; i5 < noOfShadows; i5++) {
      const theta = 2 * Math.PI * i5 / noOfShadows;
      textShadow += x2 * Math.cos(theta) + "px " + y2 * Math.sin(theta) + "px 0 " + color + (i5 == noOfShadows - 1 ? "" : ",");
    }
    return textShadow;
  }
  function createSSAParser() {
    return new SSAParser();
  }
  var FORMAT_START_RE, STYLE_START_RE, DIALOGUE_START_RE, FORMAT_SPLIT_RE, STYLE_FUNCTION_RE, NEW_LINE_RE, STYLES_SECTION_START_RE, EVENTS_SECTION_START_RE, SSAParser;
  var init_ssa_parser = __esm({
    "node_modules/.pnpm/media-captions@1.0.4/node_modules/media-captions/dist/prod/ssa-parser.js"() {
      init_live_reload();
      init_prod();
      FORMAT_START_RE = /^Format:[\s\t]*/;
      STYLE_START_RE = /^Style:[\s\t]*/;
      DIALOGUE_START_RE = /^Dialogue:[\s\t]*/;
      FORMAT_SPLIT_RE = /[\s\t]*,[\s\t]*/;
      STYLE_FUNCTION_RE = /\{[^}]+\}/g;
      NEW_LINE_RE = /\\N/g;
      STYLES_SECTION_START_RE = /^\[(.*)[\s\t]?Styles\]$/;
      EVENTS_SECTION_START_RE = /^\[(.*)[\s\t]?Events\]$/;
      SSAParser = class {
        h;
        O = 0;
        c = null;
        l = [];
        m = [];
        N = null;
        f;
        P = {};
        async init(init5) {
          this.h = init5;
          if (init5.errors)
            this.f = (await Promise.resolve().then(() => (init_errors(), errors_exports))).ParseErrorBuilder;
        }
        parse(line, lineCount) {
          if (this.O) {
            switch (this.O) {
              case 1:
                if (line === "") {
                  this.O = 0;
                } else if (STYLE_START_RE.test(line)) {
                  if (this.N) {
                    const styles = line.replace(STYLE_START_RE, "").split(FORMAT_SPLIT_RE);
                    this.S(styles);
                  } else {
                    this.g(this.f?.T("Style", lineCount));
                  }
                } else if (FORMAT_START_RE.test(line)) {
                  this.N = line.replace(FORMAT_START_RE, "").split(FORMAT_SPLIT_RE);
                } else if (EVENTS_SECTION_START_RE.test(line)) {
                  this.N = null;
                  this.O = 2;
                }
                break;
              case 2:
                if (line === "") {
                  this.Q();
                } else if (DIALOGUE_START_RE.test(line)) {
                  this.Q();
                  if (this.N) {
                    const dialogue = line.replace(DIALOGUE_START_RE, "").split(FORMAT_SPLIT_RE), cue = this.U(dialogue, lineCount);
                    if (cue)
                      this.c = cue;
                  } else {
                    this.g(this.f?.T("Dialogue", lineCount));
                  }
                } else if (this.c) {
                  this.c.text += "\n" + line.replace(STYLE_FUNCTION_RE, "").replace(NEW_LINE_RE, "\n");
                } else if (FORMAT_START_RE.test(line)) {
                  this.N = line.replace(FORMAT_START_RE, "").split(FORMAT_SPLIT_RE);
                } else if (STYLES_SECTION_START_RE.test(line)) {
                  this.N = null;
                  this.O = 1;
                } else if (EVENTS_SECTION_START_RE.test(line)) {
                  this.N = null;
                }
            }
          } else if (line === "")
            ;
          else if (STYLES_SECTION_START_RE.test(line)) {
            this.N = null;
            this.O = 1;
          } else if (EVENTS_SECTION_START_RE.test(line)) {
            this.N = null;
            this.O = 2;
          }
        }
        done() {
          return {
            metadata: {},
            cues: this.l,
            regions: [],
            errors: this.m
          };
        }
        Q() {
          if (!this.c)
            return;
          this.l.push(this.c);
          this.h.onCue?.(this.c);
          this.c = null;
        }
        S(values) {
          let name = "Default", styles = {}, outlineX, align = "center", vertical = "bottom", marginV, outlineY = 1.2, outlineColor, bgColor, borderStyle = 3, transform = [];
          for (let i5 = 0; i5 < this.N.length; i5++) {
            const field = this.N[i5], value = values[i5];
            switch (field) {
              case "Name":
                name = value;
                break;
              case "Fontname":
                styles["font-family"] = value;
                break;
              case "Fontsize":
                styles["font-size"] = `calc(${value} / var(--overlay-height))`;
                break;
              case "PrimaryColour":
                const color = parseColor(value);
                if (color)
                  styles["--cue-color"] = color;
                break;
              case "BorderStyle":
                borderStyle = parseInt(value, 10);
                break;
              case "BackColour":
                bgColor = parseColor(value);
                break;
              case "OutlineColour":
                const _outlineColor = parseColor(value);
                if (_outlineColor)
                  outlineColor = _outlineColor;
                break;
              case "Bold":
                if (parseInt(value))
                  styles["font-weight"] = "bold";
                break;
              case "Italic":
                if (parseInt(value))
                  styles["font-style"] = "italic";
                break;
              case "Underline":
                if (parseInt(value))
                  styles["text-decoration"] = "underline";
                break;
              case "StrikeOut":
                if (parseInt(value))
                  styles["text-decoration"] = "line-through";
                break;
              case "Spacing":
                styles["letter-spacing"] = value + "px";
                break;
              case "AlphaLevel":
                styles["opacity"] = parseFloat(value);
                break;
              case "ScaleX":
                transform.push(`scaleX(${parseFloat(value) / 100})`);
                break;
              case "ScaleY":
                transform.push(`scaleY(${parseFloat(value) / 100})`);
                break;
              case "Angle":
                transform.push(`rotate(${value}deg)`);
                break;
              case "Shadow":
                outlineY = parseInt(value, 10) * 1.2;
                break;
              case "MarginL":
                styles["--cue-width"] = "auto";
                styles["--cue-left"] = parseFloat(value) + "px";
                break;
              case "MarginR":
                styles["--cue-width"] = "auto";
                styles["--cue-right"] = parseFloat(value) + "px";
                break;
              case "MarginV":
                marginV = parseFloat(value);
                break;
              case "Outline":
                outlineX = parseInt(value, 10);
                break;
              case "Alignment":
                const alignment = parseInt(value, 10);
                if (alignment >= 4)
                  vertical = alignment >= 7 ? "top" : "center";
                switch (alignment % 3) {
                  case 1:
                    align = "start";
                    break;
                  case 2:
                    align = "center";
                    break;
                  case 3:
                    align = "end";
                    break;
                }
            }
          }
          styles.R = vertical;
          styles["--cue-white-space"] = "normal";
          styles["--cue-line-height"] = "normal";
          styles["--cue-text-align"] = align;
          if (vertical === "center") {
            styles[`--cue-top`] = "50%";
            transform.push("translateY(-50%)");
          } else {
            styles[`--cue-${vertical}`] = (marginV || 0) + "px";
          }
          if (borderStyle === 1) {
            styles["--cue-padding-y"] = "0";
          }
          if (borderStyle === 1 || bgColor) {
            styles["--cue-bg-color"] = borderStyle === 1 ? "none" : bgColor;
          }
          if (borderStyle === 3 && outlineColor) {
            styles["--cue-outline"] = `${outlineX}px solid ${outlineColor}`;
          }
          if (borderStyle === 1 && typeof outlineX === "number") {
            const color = bgColor ?? "#000";
            styles["--cue-text-shadow"] = [
              outlineColor && buildTextShadow(outlineX * 1.2, outlineY * 1.2, outlineColor),
              outlineColor ? buildTextShadow(outlineX * (outlineX / 2), outlineY * (outlineX / 2), color) : buildTextShadow(outlineX, outlineY, color)
            ].filter(Boolean).join(", ");
          }
          if (transform.length)
            styles["--cue-transform"] = transform.join(" ");
          this.P[name] = styles;
        }
        U(values, lineCount) {
          const fields = this.V(values);
          const timestamp = this.q(fields.Start, fields.End, lineCount);
          if (!timestamp)
            return;
          const cue = new VTTCue(timestamp[0], timestamp[1], ""), styles = { ...this.P[fields.Style] || {} }, voice = fields.Name ? `<v ${fields.Name}>` : "";
          const vertical = styles.R, marginLeft = fields.MarginL && parseFloat(fields.MarginL), marginRight = fields.MarginR && parseFloat(fields.MarginR), marginV = fields.MarginV && parseFloat(fields.MarginV);
          if (marginLeft) {
            styles["--cue-width"] = "auto";
            styles["--cue-left"] = marginLeft + "px";
          }
          if (marginRight) {
            styles["--cue-width"] = "auto";
            styles["--cue-right"] = marginRight + "px";
          }
          if (marginV && vertical !== "center") {
            styles[`--cue-${vertical}`] = marginV + "px";
          }
          cue.text = voice + values.slice(this.N.length - 1).join(", ").replace(STYLE_FUNCTION_RE, "").replace(NEW_LINE_RE, "\n");
          delete styles.R;
          if (Object.keys(styles).length)
            cue.style = styles;
          return cue;
        }
        V(values) {
          const fields = {};
          for (let i5 = 0; i5 < this.N.length; i5++) {
            fields[this.N[i5]] = values[i5];
          }
          return fields;
        }
        q(startTimeText, endTimeText, lineCount) {
          const startTime = parseVTTTimestamp(startTimeText), endTime = parseVTTTimestamp(endTimeText);
          if (startTime !== null && endTime !== null && endTime > startTime) {
            return [startTime, endTime];
          } else {
            if (startTime === null) {
              this.g(this.f?.s(startTimeText, lineCount));
            }
            if (endTime === null) {
              this.g(this.f?.t(endTimeText, lineCount));
            }
            if (startTime != null && endTime !== null && endTime > startTime) {
              this.g(this.f?.u(startTime, endTime, lineCount));
            }
          }
        }
        g(error) {
          if (!error)
            return;
          this.m.push(error);
          if (this.h.strict) {
            this.h.cancel();
            throw error;
          } else {
            this.h.onError?.(error);
          }
        }
      };
    }
  });

  // node_modules/.pnpm/media-captions@1.0.4/node_modules/media-captions/dist/prod/index.js
  async function parseText(text, options) {
    const stream = new ReadableStream({
      start(controller) {
        const lines = text.split(LINE_TERMINATOR_RE);
        for (const line of lines)
          controller.enqueue(line);
        controller.close();
      }
    });
    return parseTextStream(stream, options);
  }
  async function parseTextStream(stream, options) {
    const type = options?.type ?? "vtt";
    let factory;
    if (typeof type === "string") {
      switch (type) {
        case "srt":
          factory = (await Promise.resolve().then(() => (init_srt_parser(), srt_parser_exports))).default;
          break;
        case "ssa":
        case "ass":
          factory = (await Promise.resolve().then(() => (init_ssa_parser(), ssa_parser_exports))).default;
          break;
        default:
          factory = (await Promise.resolve().then(function() {
            return vttParser;
          })).default;
      }
    } else {
      factory = type;
    }
    let result;
    const reader = stream.getReader(), parser = factory(), errors = !!options?.strict || !!options?.errors;
    await parser.init({
      strict: false,
      ...options,
      errors,
      type,
      cancel() {
        reader.cancel();
        result = parser.done(true);
      }
    });
    let i5 = 1;
    while (true) {
      const { value, done } = await reader.read();
      if (done) {
        parser.parse("", i5);
        result = parser.done(false);
        break;
      }
      parser.parse(value, i5);
      i5++;
    }
    return result;
  }
  async function parseResponse(response, options) {
    const res = await response;
    if (!res.ok || !res.body) {
      let error;
      return {
        metadata: {},
        cues: [],
        regions: [],
        errors: [error]
      };
    }
    const contentType = res.headers.get("content-type") || "", type = contentType.match(/text\/(.*?)(?:;|$)/)?.[1], encoding = contentType.match(/charset=(.*?)(?:;|$)/)?.[1];
    return parseByteStream(res.body, { type, encoding, ...options });
  }
  async function parseByteStream(stream, { encoding = "utf-8", ...options } = {}) {
    const textStream = stream.pipeThrough(new TextLineTransformStream(encoding));
    return parseTextStream(textStream, options);
  }
  function toNumber(text) {
    const num = parseInt(text, 10);
    return !Number.isNaN(num) ? num : null;
  }
  function toPercentage(text) {
    const num = parseInt(text.replace(PERCENT_SIGN$1, ""), 10);
    return !Number.isNaN(num) && num >= 0 && num <= 100 ? num : null;
  }
  function toCoords(text) {
    if (!text.includes(COMMA$1))
      return null;
    const [x2, y2] = text.split(COMMA$1).map(toPercentage);
    return x2 !== null && y2 !== null ? [x2, y2] : null;
  }
  function toFloat(text) {
    const num = parseFloat(text);
    return !Number.isNaN(num) ? num : null;
  }
  function parseVTTTimestamp(timestamp) {
    const match = timestamp.match(TIMESTAMP_RE);
    if (!match)
      return null;
    const hours = match[1] ? parseInt(match[1], 10) : 0, minutes = parseInt(match[2], 10), seconds = parseInt(match[3], 10), milliseconds = match[4] ? parseInt(match[4].padEnd(3, "0"), 10) : 0, total = hours * 3600 + minutes * 60 + seconds + milliseconds / 1e3;
    if (hours < 0 || minutes < 0 || seconds < 0 || milliseconds < 0 || minutes > 59 || seconds > 59) {
      return null;
    }
    return total;
  }
  function createVTTParser() {
    return new VTTParser();
  }
  function tokenizeVTTCue(cue) {
    let buffer = "", mode = 1, result = [], stack = [], node;
    for (let i5 = 0; i5 < cue.text.length; i5++) {
      const char = cue.text[i5];
      switch (mode) {
        case 1:
          if (char === "<") {
            addText();
            mode = 2;
          } else {
            buffer += char;
          }
          break;
        case 2:
          switch (char) {
            case "\n":
            case "	":
            case " ":
              addNode();
              mode = 4;
              break;
            case ".":
              addNode();
              mode = 3;
              break;
            case "/":
              mode = 5;
              break;
            case ">":
              addNode();
              mode = 1;
              break;
            default:
              if (!buffer && DIGIT_RE.test(char))
                mode = 6;
              buffer += char;
              break;
          }
          break;
        case 3:
          switch (char) {
            case "	":
            case " ":
            case "\n":
              addClass();
              if (node)
                node.class?.trim();
              mode = 4;
              break;
            case ".":
              addClass();
              break;
            case ">":
              addClass();
              if (node)
                node.class?.trim();
              mode = 1;
              break;
            default:
              buffer += char;
          }
          break;
        case 4:
          if (char === ">") {
            buffer = buffer.replace(MULTI_SPACE_RE, " ");
            if (node?.type === "v")
              node.voice = replaceHTMLEntities(buffer);
            else if (node?.type === "lang")
              node.lang = replaceHTMLEntities(buffer);
            buffer = "";
            mode = 1;
          } else {
            buffer += char;
          }
          break;
        case 5:
          if (char === ">") {
            buffer = "";
            node = stack.pop();
            mode = 1;
          }
          break;
        case 6:
          if (char === ">") {
            const time = parseVTTTimestamp(buffer);
            if (time !== null && time >= cue.startTime && time <= cue.endTime) {
              buffer = "timestamp";
              addNode();
              node.time = time;
            }
            buffer = "";
            mode = 1;
          } else {
            buffer += char;
          }
          break;
      }
    }
    function addNode() {
      if (BLOCK_TYPES.has(buffer)) {
        const parent = node;
        node = createBlockNode(buffer);
        if (parent) {
          if (stack[stack.length - 1] !== parent)
            stack.push(parent);
          parent.children.push(node);
        } else
          result.push(node);
      }
      buffer = "";
      mode = 1;
    }
    function addClass() {
      if (node && buffer) {
        const color = buffer.replace("bg_", "");
        if (COLORS.has(color)) {
          node[buffer.startsWith("bg_") ? "bgColor" : "color"] = color;
        } else {
          node.class = !node.class ? buffer : node.class + " " + buffer;
        }
      }
      buffer = "";
    }
    function addText() {
      if (!buffer)
        return;
      const text = { type: "text", data: replaceHTMLEntities(buffer) };
      node ? node.children.push(text) : result.push(text);
      buffer = "";
    }
    if (mode === 1)
      addText();
    return result;
  }
  function createBlockNode(type) {
    return {
      tagName: TAG_NAME[type],
      type,
      children: []
    };
  }
  function replaceHTMLEntities(text) {
    return text.replace(HTML_ENTITY_RE, (entity) => HTML_ENTITIES[entity] || "'");
  }
  function setCSSVar(el, name, value) {
    el.style.setProperty(`--${name}`, value + "");
  }
  function setDataAttr(el, name, value = true) {
    el.setAttribute(`data-${name}`, value === true ? "" : value + "");
  }
  function setPartAttr(el, name) {
    el.setAttribute("data-part", name);
  }
  function getLineHeight(el) {
    return parseFloat(getComputedStyle(el).lineHeight) || 0;
  }
  function createVTTCueTemplate(cue) {
    if (IS_SERVER) {
      throw Error(
        "[media-captions] called `createVTTCueTemplate` on the server - use `renderVTTCueString`"
      );
    }
    const template = document.createElement("template");
    template.innerHTML = renderVTTCueString(cue);
    return { cue, content: template.content };
  }
  function renderVTTCueString(cue, currentTime = 0) {
    return renderVTTTokensString(tokenizeVTTCue(cue), currentTime);
  }
  function renderVTTTokensString(tokens, currentTime = 0) {
    let attrs, result = "";
    for (const token of tokens) {
      if (token.type === "text") {
        result += token.data;
      } else {
        const isTimestamp = token.type === "timestamp";
        attrs = {};
        attrs.class = token.class;
        attrs.title = token.type === "v" && token.voice;
        attrs.lang = token.type === "lang" && token.lang;
        attrs["data-part"] = token.type === "v" && "voice";
        if (isTimestamp) {
          attrs["data-part"] = "timed";
          attrs["data-time"] = token.time;
          attrs["data-future"] = token.time > currentTime;
          attrs["data-past"] = token.time < currentTime;
        }
        attrs.style = `${token.color ? `color: ${token.color};` : ""}${token.bgColor ? `background-color: ${token.bgColor};` : ""}`;
        const attributes = Object.entries(attrs).filter((v2) => v2[1]).map((v2) => `${v2[0]}="${v2[1] === true ? "" : v2[1]}"`).join(" ");
        result += `<${token.tagName}${attributes ? " " + attributes : ""}>${renderVTTTokensString(
          token.children
        )}</${token.tagName}>`;
      }
    }
    return result;
  }
  function updateTimedVTTCueNodes(root2, currentTime) {
    if (IS_SERVER)
      return;
    for (const el of root2.querySelectorAll('[data-part="timed"]')) {
      const time = Number(el.getAttribute("data-time"));
      if (Number.isNaN(time))
        continue;
      if (time > currentTime)
        setDataAttr(el, "future");
      else
        el.removeAttribute("data-future");
      if (time < currentTime)
        setDataAttr(el, "past");
      else
        el.removeAttribute("data-past");
    }
  }
  function debounce2(fn, delay) {
    let timeout = null, args;
    function run() {
      clear();
      fn(...args);
      args = void 0;
    }
    function clear() {
      clearTimeout(timeout);
      timeout = null;
    }
    function debounce22() {
      args = [].slice.call(arguments);
      clear();
      timeout = setTimeout(run, delay);
    }
    return debounce22;
  }
  function createBox(box) {
    if (box instanceof HTMLElement) {
      return {
        top: box.offsetTop,
        width: box.clientWidth,
        height: box.clientHeight,
        left: box.offsetLeft,
        right: box.offsetLeft + box.clientWidth,
        bottom: box.offsetTop + box.clientHeight
      };
    }
    return { ...box };
  }
  function moveBox(box, axis, delta) {
    switch (axis) {
      case "+x":
        box.left += delta;
        box.right += delta;
        break;
      case "-x":
        box.left -= delta;
        box.right -= delta;
        break;
      case "+y":
        box.top += delta;
        box.bottom += delta;
        break;
      case "-y":
        box.top -= delta;
        box.bottom -= delta;
        break;
    }
  }
  function isBoxCollision(a4, b2) {
    return a4.left <= b2.right && a4.right >= b2.left && a4.top <= b2.bottom && a4.bottom >= b2.top;
  }
  function isAnyBoxCollision(box, boxes) {
    for (let i5 = 0; i5 < boxes.length; i5++)
      if (isBoxCollision(box, boxes[i5]))
        return boxes[i5];
    return null;
  }
  function isWithinBox(container, box) {
    return box.top >= 0 && box.bottom <= container.height && box.left >= 0 && box.right <= container.width;
  }
  function isBoxOutOfBounds(container, box, axis) {
    switch (axis) {
      case "+x":
        return box.left < 0;
      case "-x":
        return box.right > container.width;
      case "+y":
        return box.top < 0;
      case "-y":
        return box.bottom > container.height;
    }
  }
  function calcBoxIntersectPercentage(container, box) {
    const x2 = Math.max(0, Math.min(container.width, box.right) - Math.max(0, box.left)), y2 = Math.max(0, Math.min(container.height, box.bottom) - Math.max(0, box.top)), intersectArea = x2 * y2;
    return intersectArea / (container.height * container.width);
  }
  function createCSSBox(container, box) {
    return {
      top: box.top / container.height,
      left: box.left / container.width,
      right: (container.width - box.right) / container.width,
      bottom: (container.height - box.bottom) / container.height
    };
  }
  function resolveRelativeBox(container, box) {
    box.top = box.top * container.height;
    box.left = box.left * container.width;
    box.right = container.width - box.right * container.width;
    box.bottom = container.height - box.bottom * container.height;
    return box;
  }
  function setBoxCSSVars(el, container, box, prefix) {
    const cssBox = createCSSBox(container, box);
    for (const side of BOX_SIDES) {
      setCSSVar(el, `${prefix}-${side}`, cssBox[side] * 100 + "%");
    }
  }
  function avoidBoxCollisions(container, box, boxes, axis) {
    let percentage = 1, positionedBox, startBox = { ...box };
    for (let i5 = 0; i5 < axis.length; i5++) {
      while (isBoxOutOfBounds(container, box, axis[i5]) || isWithinBox(container, box) && isAnyBoxCollision(box, boxes)) {
        moveBox(box, axis[i5], 1);
      }
      if (isWithinBox(container, box))
        return box;
      const intersection = calcBoxIntersectPercentage(container, box);
      if (percentage > intersection) {
        positionedBox = { ...box };
        percentage = intersection;
      }
      box = { ...startBox };
    }
    return positionedBox || startBox;
  }
  function positionCue(container, cue, displayEl, boxes) {
    let cueEl = displayEl.firstElementChild, line = computeCueLine(cue), displayBox, axis = [];
    if (!displayEl[STARTING_BOX]) {
      displayEl[STARTING_BOX] = createStartingBox(container, displayEl);
    }
    displayBox = resolveRelativeBox(container, { ...displayEl[STARTING_BOX] });
    if (displayEl[POSITION_OVERRIDE]) {
      axis = [displayEl[POSITION_OVERRIDE] === "top" ? "+y" : "-y", "+x", "-x"];
    } else if (cue.snapToLines) {
      let size2;
      switch (cue.vertical) {
        case "":
          axis = ["+y", "-y"];
          size2 = "height";
          break;
        case "rl":
          axis = ["+x", "-x"];
          size2 = "width";
          break;
        case "lr":
          axis = ["-x", "+x"];
          size2 = "width";
          break;
      }
      let step = getLineHeight(cueEl), position = step * Math.round(line), maxPosition = container[size2] + step, initialAxis = axis[0];
      if (Math.abs(position) > maxPosition) {
        position = position < 0 ? -1 : 1;
        position *= Math.ceil(maxPosition / step) * step;
      }
      if (line < 0) {
        position += cue.vertical === "" ? container.height : container.width;
        axis = axis.reverse();
      }
      moveBox(displayBox, initialAxis, position);
    } else {
      const isHorizontal = cue.vertical === "", posAxis = isHorizontal ? "+y" : "+x", size2 = isHorizontal ? displayBox.height : displayBox.width;
      moveBox(
        displayBox,
        posAxis,
        (isHorizontal ? container.height : container.width) * line / 100
      );
      moveBox(
        displayBox,
        posAxis,
        cue.lineAlign === "center" ? size2 / 2 : cue.lineAlign === "end" ? size2 : 0
      );
      axis = isHorizontal ? ["-y", "+y", "-x", "+x"] : ["-x", "+x", "-y", "+y"];
    }
    displayBox = avoidBoxCollisions(container, displayBox, boxes, axis);
    setBoxCSSVars(displayEl, container, displayBox, "cue");
    return displayBox;
  }
  function createStartingBox(container, cueEl) {
    const box = createBox(cueEl), pos = getStyledPositions(cueEl);
    cueEl[POSITION_OVERRIDE] = false;
    if (pos.top) {
      box.top = pos.top;
      box.bottom = pos.top + box.height;
      cueEl[POSITION_OVERRIDE] = "top";
    }
    if (pos.bottom) {
      const bottom = container.height - pos.bottom;
      box.top = bottom - box.height;
      box.bottom = bottom;
      cueEl[POSITION_OVERRIDE] = "bottom";
    }
    if (pos.left)
      box.left = pos.left;
    if (pos.right)
      box.right = container.width - pos.right;
    return createCSSBox(container, box);
  }
  function getStyledPositions(el) {
    const positions = {};
    for (const side of BOX_SIDES) {
      positions[side] = parseFloat(el.style.getPropertyValue(`--cue-${side}`));
    }
    return positions;
  }
  function computeCueLine(cue) {
    if (cue.line === "auto") {
      if (!cue.snapToLines) {
        return 100;
      } else {
        return -1;
      }
    }
    return cue.line;
  }
  function computeCuePosition(cue) {
    if (cue.position === "auto") {
      switch (cue.align) {
        case "start":
        case "left":
          return 0;
        case "right":
        case "end":
          return 100;
        default:
          return 50;
      }
    }
    return cue.position;
  }
  function computeCuePositionAlignment(cue, dir) {
    if (cue.positionAlign === "auto") {
      switch (cue.align) {
        case "start":
          return dir === "ltr" ? "line-left" : "line-right";
        case "end":
          return dir === "ltr" ? "line-right" : "line-left";
        case "center":
          return "center";
        default:
          return `line-${cue.align}`;
      }
    }
    return cue.positionAlign;
  }
  function positionRegion(container, region, regionEl, boxes) {
    let cues = Array.from(regionEl.querySelectorAll('[data-part="cue-display"]')), height = 0, limit = Math.max(0, cues.length - region.lines);
    for (let i5 = cues.length - 1; i5 >= limit; i5--) {
      height += cues[i5].offsetHeight;
    }
    setCSSVar(regionEl, "region-height", height + "px");
    if (!regionEl[STARTING_BOX]) {
      regionEl[STARTING_BOX] = createCSSBox(container, createBox(regionEl));
    }
    let box = { ...regionEl[STARTING_BOX] };
    box = resolveRelativeBox(container, box);
    box.width = regionEl.clientWidth;
    box.height = height;
    box.right = box.left + box.width;
    box.bottom = box.top + height;
    box = avoidBoxCollisions(container, box, boxes, REGION_AXIS);
    setBoxCSSVars(regionEl, container, box, "region");
    return box;
  }
  var ParseErrorCode, ParseError, LINE_TERMINATOR_RE, TextLineTransformStream, TextStreamLineIterator, TextCue, IS_SERVER, CueBase, VTTCue, VTTRegion, COMMA$1, PERCENT_SIGN$1, HEADER_MAGIC, COMMA, PERCENT_SIGN, SETTING_SEP_RE, SETTING_LINE_RE, NOTE_BLOCK_START, REGION_BLOCK_START, REGION_BLOCK_START_RE, SPACE_RE, TIMESTAMP_SEP2, TIMESTAMP_SEP_RE, ALIGN_RE, LINE_ALIGN_RE, POS_ALIGN_RE, TIMESTAMP_RE, VTTBlock, VTTParser, vttParser, DIGIT_RE, MULTI_SPACE_RE, TAG_NAME, HTML_ENTITIES, HTML_ENTITY_RE, COLORS, BLOCK_TYPES, STARTING_BOX, BOX_SIDES, POSITION_OVERRIDE, REGION_AXIS, CaptionsRenderer;
  var init_prod = __esm({
    "node_modules/.pnpm/media-captions@1.0.4/node_modules/media-captions/dist/prod/index.js"() {
      init_live_reload();
      ParseErrorCode = {
        LoadFail: 0,
        BadSignature: 1,
        BadTimestamp: 2,
        BadSettingValue: 3,
        BadFormat: 4,
        UnknownSetting: 5
      };
      ParseError = class extends Error {
        code;
        line;
        constructor(init5) {
          super(init5.reason);
          this.code = init5.code;
          this.line = init5.line;
        }
      };
      LINE_TERMINATOR_RE = /\r?\n|\r/gm;
      TextLineTransformStream = class {
        writable;
        readable;
        constructor(encoding) {
          const transformer = new TextStreamLineIterator(encoding);
          this.writable = new WritableStream({
            write(chunk) {
              transformer.transform(chunk);
            },
            close() {
              transformer.close();
            }
          });
          this.readable = new ReadableStream({
            start(controller) {
              transformer.onLine = (line) => controller.enqueue(line);
              transformer.onClose = () => controller.close();
            }
          });
        }
      };
      TextStreamLineIterator = class {
        a = "";
        b;
        onLine;
        onClose;
        constructor(encoding) {
          this.b = new TextDecoder(encoding);
        }
        transform(chunk) {
          this.a += this.b.decode(chunk, { stream: true });
          const lines = this.a.split(LINE_TERMINATOR_RE);
          this.a = lines.pop() || "";
          for (let i5 = 0; i5 < lines.length; i5++)
            this.onLine(lines[i5].trim());
        }
        close() {
          if (this.a)
            this.onLine(this.a.trim());
          this.a = "";
          this.onClose();
        }
      };
      TextCue = class extends EventTarget {
        /**
         * A string that identifies the cue.
         *
         * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/TextTrackCue/id}
         */
        id = "";
        /**
         * A `double` that represents the video time that the cue will start being displayed, in seconds.
         *
         * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/TextTrackCue/startTime}
         */
        startTime;
        /**
         * A `double` that represents the video time that the cue will stop being displayed, in seconds.
         *
         * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/TextTrackCue/endTime}
         */
        endTime;
        /**
         * Returns a string with the contents of the cue.
         *
         * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/VTTCue/text}
         */
        text;
        /**
         * A `boolean` for whether the video will pause when this cue stops being displayed.
         *
         * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/TextTrackCue/pauseOnExit}
         */
        pauseOnExit = false;
        constructor(startTime, endTime, text) {
          super();
          this.startTime = startTime;
          this.endTime = endTime;
          this.text = text;
        }
        addEventListener(type, listener, options) {
          super.addEventListener(type, listener, options);
        }
        removeEventListener(type, listener, options) {
          super.removeEventListener(type, listener, options);
        }
      };
      IS_SERVER = typeof document === "undefined";
      CueBase = IS_SERVER ? TextCue : window.VTTCue;
      VTTCue = class extends CueBase {
        /**
         * A `VTTRegion` object describing the video's sub-region that the cue will be drawn onto,
         * or `null` if none is assigned.
         *
         * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/VTTCue/region}
         */
        region = null;
        /**
         * The cue writing direction.
         *
         * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/VTTCue/vertical}
         */
        vertical = "";
        /**
         * Returns `true` if the `VTTCue.line` attribute is an integer number of lines or a percentage
         * of the video size.
         *
         * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/VTTCue/snapToLines}
         */
        snapToLines = true;
        /**
         * Returns the line positioning of the cue. This can be the string `'auto'` or a number whose
         * interpretation depends on the value of `VTTCue.snapToLines`.
         *
         * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/VTTCue/line}
         */
        line = "auto";
        /**
         * Returns an enum representing the alignment of the `VTTCue.line`.
         *
         * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/VTTCue/lineAlign}
         */
        lineAlign = "start";
        /**
         * Returns the indentation of the cue within the line. This can be the string `'auto'` or a
         * number representing the percentage of the `VTTCue.region`, or the video size if `VTTCue`.region`
         * is `null`.
         *
         * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/VTTCue/position}
         */
        position = "auto";
        /**
         * Returns an enum representing the alignment of the cue. This is used to determine what
         * the `VTTCue.position` is anchored to. The default is `'auto'`.
         *
         * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/VTTCue/positionAlign}
         */
        positionAlign = "auto";
        /**
         * Returns a double representing the size of the cue, as a percentage of the video size.
         *
         * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/VTTCue/size}
         */
        size = 100;
        /**
         * Returns an enum representing the alignment of all the lines of text within the cue box.
         *
         * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/VTTCue/align}
         */
        align = "center";
        /**
         * Additional styles associated with the cue.
         */
        style;
      };
      VTTRegion = class {
        /**
         * A string that identifies the region.
         */
        id = "";
        /**
         * A `double` representing the width of the region, as a percentage of the video.
         */
        width = 100;
        /**
         * A `double` representing the height of the region, in number of lines.
         */
        lines = 3;
        /**
         * A `double` representing the region anchor X offset, as a percentage of the region.
         */
        regionAnchorX = 0;
        /**
         * A `double` representing the region anchor Y offset, as a percentage of the region.
         */
        regionAnchorY = 100;
        /**
         * A `double` representing the viewport anchor X offset, as a percentage of the video.
         */
        viewportAnchorX = 0;
        /**
         * A `double` representing the viewport anchor Y offset, as a percentage of the video.
         */
        viewportAnchorY = 100;
        /**
         * An enum representing how adding new cues will move existing cues.
         */
        scroll = "";
      };
      COMMA$1 = ",";
      PERCENT_SIGN$1 = "%";
      HEADER_MAGIC = "WEBVTT";
      COMMA = ",";
      PERCENT_SIGN = "%";
      SETTING_SEP_RE = /[:=]/;
      SETTING_LINE_RE = /^[\s\t]*(region|vertical|line|position|size|align)[:=]/;
      NOTE_BLOCK_START = "NOTE";
      REGION_BLOCK_START = "REGION";
      REGION_BLOCK_START_RE = /^REGION:?[\s\t]+/;
      SPACE_RE = /[\s\t]+/;
      TIMESTAMP_SEP2 = "-->";
      TIMESTAMP_SEP_RE = /[\s\t]*-->[\s\t]+/;
      ALIGN_RE = /start|center|end|left|right/;
      LINE_ALIGN_RE = /start|center|end/;
      POS_ALIGN_RE = /line-(?:left|right)|center|auto/;
      TIMESTAMP_RE = /^(?:(\d{1,2}):)?(\d{2}):(\d{2})(?:\.(\d{1,3}))?$/;
      VTTBlock = /* @__PURE__ */ ((VTTBlock2) => {
        VTTBlock2[VTTBlock2["None"] = 0] = "None";
        VTTBlock2[VTTBlock2["Header"] = 1] = "Header";
        VTTBlock2[VTTBlock2["Cue"] = 2] = "Cue";
        VTTBlock2[VTTBlock2["Region"] = 3] = "Region";
        VTTBlock2[VTTBlock2["Note"] = 4] = "Note";
        return VTTBlock2;
      })(VTTBlock || {});
      VTTParser = class {
        h;
        e = 0;
        i = {};
        j = {};
        l = [];
        c = null;
        d = null;
        m = [];
        f;
        n = "";
        async init(init5) {
          this.h = init5;
          if (init5.strict)
            this.e = 1;
          if (init5.errors)
            this.f = (await Promise.resolve().then(() => (init_errors(), errors_exports))).ParseErrorBuilder;
        }
        parse(line, lineCount) {
          if (line === "") {
            if (this.c) {
              this.l.push(this.c);
              this.h.onCue?.(this.c);
              this.c = null;
            } else if (this.d) {
              this.j[this.d.id] = this.d;
              this.h.onRegion?.(this.d);
              this.d = null;
            } else if (this.e === 1) {
              this.k(line, lineCount);
              this.h.onHeaderMetadata?.(this.i);
            }
            this.e = 0;
          } else if (this.e) {
            switch (this.e) {
              case 1:
                this.k(line, lineCount);
                break;
              case 2:
                if (this.c) {
                  const hasText = this.c.text.length > 0;
                  if (!hasText && SETTING_LINE_RE.test(line)) {
                    this.o(line.split(SPACE_RE), lineCount);
                  } else {
                    this.c.text += (hasText ? "\n" : "") + line;
                  }
                }
                break;
              case 3:
                this.p(line.split(SPACE_RE), lineCount);
                break;
            }
          } else if (line.startsWith(NOTE_BLOCK_START)) {
            this.e = 4;
          } else if (line.startsWith(REGION_BLOCK_START)) {
            this.e = 3;
            this.d = new VTTRegion();
            this.p(line.replace(REGION_BLOCK_START_RE, "").split(SPACE_RE), lineCount);
          } else if (line.includes(TIMESTAMP_SEP2)) {
            const result = this.q(line, lineCount);
            if (result) {
              this.c = new VTTCue(result[0], result[1], "");
              this.c.id = this.n;
              this.o(result[2], lineCount);
            }
            this.e = 2;
          } else if (lineCount === 1) {
            this.k(line, lineCount);
          }
          this.n = line;
        }
        done() {
          return {
            metadata: this.i,
            cues: this.l,
            regions: Object.values(this.j),
            errors: this.m
          };
        }
        k(line, lineCount) {
          if (lineCount > 1) {
            if (SETTING_SEP_RE.test(line)) {
              const [key2, value] = line.split(SETTING_SEP_RE);
              if (key2)
                this.i[key2] = (value || "").replace(SPACE_RE, "");
            }
          } else if (line.startsWith(HEADER_MAGIC)) {
            this.e = 1;
          } else {
            this.g(this.f?.r());
          }
        }
        q(line, lineCount) {
          const [startTimeText, trailingText = ""] = line.split(TIMESTAMP_SEP_RE), [endTimeText, ...settingsText] = trailingText.split(SPACE_RE), startTime = parseVTTTimestamp(startTimeText), endTime = parseVTTTimestamp(endTimeText);
          if (startTime !== null && endTime !== null && endTime > startTime) {
            return [startTime, endTime, settingsText];
          } else {
            if (startTime === null) {
              this.g(this.f?.s(startTimeText, lineCount));
            }
            if (endTime === null) {
              this.g(this.f?.t(endTimeText, lineCount));
            }
            if (startTime != null && endTime !== null && endTime > startTime) {
              this.g(this.f?.u(startTime, endTime, lineCount));
            }
          }
        }
        /**
         * @see {@link https://www.w3.org/TR/webvtt1/#region-settings-parsing}
         */
        p(settings, line) {
          let badValue;
          for (let i5 = 0; i5 < settings.length; i5++) {
            if (SETTING_SEP_RE.test(settings[i5])) {
              badValue = false;
              const [name, value] = settings[i5].split(SETTING_SEP_RE);
              switch (name) {
                case "id":
                  this.d.id = value;
                  break;
                case "width":
                  const width = toPercentage(value);
                  if (width !== null)
                    this.d.width = width;
                  else
                    badValue = true;
                  break;
                case "lines":
                  const lines = toNumber(value);
                  if (lines !== null)
                    this.d.lines = lines;
                  else
                    badValue = true;
                  break;
                case "regionanchor":
                  const region = toCoords(value);
                  if (region !== null) {
                    this.d.regionAnchorX = region[0];
                    this.d.regionAnchorY = region[1];
                  } else
                    badValue = true;
                  break;
                case "viewportanchor":
                  const viewport = toCoords(value);
                  if (viewport !== null) {
                    this.d.viewportAnchorX = viewport[0];
                    this.d.viewportAnchorY = viewport[1];
                  } else
                    badValue = true;
                  break;
                case "scroll":
                  if (value === "up")
                    this.d.scroll = "up";
                  else
                    badValue = true;
                  break;
                default:
                  this.g(this.f?.v(name, value, line));
              }
              if (badValue) {
                this.g(this.f?.w(name, value, line));
              }
            }
          }
        }
        /**
         * @see {@link https://www.w3.org/TR/webvtt1/#cue-timings-and-settings-parsing}
         */
        o(settings, line) {
          let badValue;
          for (let i5 = 0; i5 < settings.length; i5++) {
            badValue = false;
            if (SETTING_SEP_RE.test(settings[i5])) {
              const [name, value] = settings[i5].split(SETTING_SEP_RE);
              switch (name) {
                case "region":
                  const region = this.j[value];
                  if (region)
                    this.c.region = region;
                  break;
                case "vertical":
                  if (value === "lr" || value === "rl") {
                    this.c.vertical = value;
                    this.c.region = null;
                  } else
                    badValue = true;
                  break;
                case "line":
                  const [linePos, lineAlign] = value.split(COMMA);
                  if (linePos.includes(PERCENT_SIGN)) {
                    const percentage = toPercentage(linePos);
                    if (percentage !== null) {
                      this.c.line = percentage;
                      this.c.snapToLines = false;
                    } else
                      badValue = true;
                  } else {
                    const number = toFloat(linePos);
                    if (number !== null)
                      this.c.line = number;
                    else
                      badValue = true;
                  }
                  if (LINE_ALIGN_RE.test(lineAlign)) {
                    this.c.lineAlign = lineAlign;
                  } else if (lineAlign) {
                    badValue = true;
                  }
                  if (this.c.line !== "auto")
                    this.c.region = null;
                  break;
                case "position":
                  const [colPos, colAlign] = value.split(COMMA), position = toPercentage(colPos);
                  if (position !== null)
                    this.c.position = position;
                  else
                    badValue = true;
                  if (colAlign && POS_ALIGN_RE.test(colAlign)) {
                    this.c.positionAlign = colAlign;
                  } else if (colAlign) {
                    badValue = true;
                  }
                  break;
                case "size":
                  const size2 = toPercentage(value);
                  if (size2 !== null) {
                    this.c.size = size2;
                    if (size2 < 100)
                      this.c.region = null;
                  } else {
                    badValue = true;
                  }
                  break;
                case "align":
                  if (ALIGN_RE.test(value)) {
                    this.c.align = value;
                  } else {
                    badValue = true;
                  }
                  break;
                default:
                  this.g(this.f?.x(name, value, line));
              }
              if (badValue) {
                this.g(this.f?.y(name, value, line));
              }
            }
          }
        }
        g(error) {
          if (!error)
            return;
          this.m.push(error);
          if (this.h.strict) {
            this.h.cancel();
            throw error;
          } else {
            this.h.onError?.(error);
          }
        }
      };
      vttParser = /* @__PURE__ */ Object.freeze({
        __proto__: null,
        VTTBlock,
        VTTParser,
        default: createVTTParser,
        parseVTTTimestamp
      });
      DIGIT_RE = /[0-9]/;
      MULTI_SPACE_RE = /[\s\t]+/;
      TAG_NAME = {
        c: "span",
        i: "i",
        b: "b",
        u: "u",
        ruby: "ruby",
        rt: "rt",
        v: "span",
        lang: "span",
        timestamp: "span"
      };
      HTML_ENTITIES = {
        "&amp;": "&",
        "&lt;": "<",
        "&gt;": ">",
        "&quot;": '"',
        "&#39;": "'",
        "&nbsp;": "\xA0",
        "&lrm;": "\u200E",
        "&rlm;": "\u200F"
      };
      HTML_ENTITY_RE = /&(?:amp|lt|gt|quot|#(0+)?39|nbsp|lrm|rlm);/g;
      COLORS = /* @__PURE__ */ new Set([
        "white",
        "lime",
        "cyan",
        "red",
        "yellow",
        "magenta",
        "blue",
        "black"
      ]);
      BLOCK_TYPES = /* @__PURE__ */ new Set(Object.keys(TAG_NAME));
      STARTING_BOX = Symbol(0);
      BOX_SIDES = ["top", "left", "right", "bottom"];
      POSITION_OVERRIDE = Symbol(0);
      REGION_AXIS = ["-y", "+y", "-x", "+x"];
      CaptionsRenderer = class {
        overlay;
        z;
        A = 0;
        C = "ltr";
        B = [];
        D = false;
        E;
        j = /* @__PURE__ */ new Map();
        l = /* @__PURE__ */ new Map();
        /* Text direction. */
        get dir() {
          return this.C;
        }
        set dir(dir) {
          this.C = dir;
          setDataAttr(this.overlay, "dir", dir);
        }
        get currentTime() {
          return this.A;
        }
        set currentTime(time) {
          this.A = time;
          this.update();
        }
        constructor(overlay, init5) {
          this.overlay = overlay;
          this.dir = init5?.dir ?? "ltr";
          overlay.setAttribute("translate", "yes");
          overlay.setAttribute("aria-live", "off");
          overlay.setAttribute("aria-atomic", "true");
          setPartAttr(overlay, "captions");
          this.G();
          this.E = new ResizeObserver(this.I.bind(this));
          this.E.observe(overlay);
        }
        changeTrack({ regions, cues }) {
          this.reset();
          this.J(regions);
          for (const cue of cues)
            this.l.set(cue, null);
          this.update();
        }
        addCue(cue) {
          this.l.set(cue, null);
          this.update();
        }
        removeCue(cue) {
          this.l.delete(cue);
          this.update();
        }
        update(forceUpdate = false) {
          this.H(forceUpdate);
        }
        reset() {
          this.l.clear();
          this.j.clear();
          this.B = [];
          this.overlay.textContent = "";
        }
        destroy() {
          this.reset();
          this.E.disconnect();
        }
        I() {
          this.D = true;
          this.K();
        }
        K = debounce2(() => {
          this.D = false;
          this.G();
          for (const el of this.j.values()) {
            el[STARTING_BOX] = null;
          }
          for (const el of this.l.values()) {
            if (el)
              el[STARTING_BOX] = null;
          }
          this.H(true);
        }, 50);
        G() {
          this.z = createBox(this.overlay);
          setCSSVar(this.overlay, "overlay-width", this.z.width + "px");
          setCSSVar(this.overlay, "overlay-height", this.z.height + "px");
        }
        H(forceUpdate = false) {
          if (!this.l.size || this.D)
            return;
          let cue, activeCues = [...this.l.keys()].filter((cue2) => this.A >= cue2.startTime && this.A <= cue2.endTime).sort(
            (cueA, cueB) => cueA.startTime !== cueB.startTime ? cueA.startTime - cueB.startTime : cueA.endTime - cueB.endTime
          ), activeRegions = activeCues.map((cue2) => cue2.region);
          for (let i5 = 0; i5 < this.B.length; i5++) {
            cue = this.B[i5];
            if (activeCues[i5] === cue)
              continue;
            if (cue.region && !activeRegions.includes(cue.region)) {
              const regionEl = this.j.get(cue.region.id);
              if (regionEl) {
                regionEl.removeAttribute("data-active");
                forceUpdate = true;
              }
            }
            const cueEl = this.l.get(cue);
            if (cueEl) {
              cueEl.remove();
              forceUpdate = true;
            }
          }
          for (let i5 = 0; i5 < activeCues.length; i5++) {
            cue = activeCues[i5];
            let cueEl = this.l.get(cue);
            if (!cueEl)
              this.l.set(cue, cueEl = this.L(cue));
            const regionEl = this.F(cue) && this.j.get(cue.region.id);
            if (regionEl && !regionEl.hasAttribute("data-active")) {
              requestAnimationFrame(() => setDataAttr(regionEl, "active"));
              forceUpdate = true;
            }
            if (!cueEl.isConnected) {
              (regionEl || this.overlay).append(cueEl);
              forceUpdate = true;
            }
          }
          if (forceUpdate) {
            const boxes = [], seen = /* @__PURE__ */ new Set();
            for (let i5 = activeCues.length - 1; i5 >= 0; i5--) {
              cue = activeCues[i5];
              if (seen.has(cue.region || cue))
                continue;
              const isRegion = this.F(cue), el = isRegion ? this.j.get(cue.region.id) : this.l.get(cue);
              if (isRegion) {
                boxes.push(positionRegion(this.z, cue.region, el, boxes));
              } else {
                boxes.push(positionCue(this.z, cue, el, boxes));
              }
              seen.add(isRegion ? cue.region : cue);
            }
          }
          updateTimedVTTCueNodes(this.overlay, this.A);
          this.B = activeCues;
        }
        J(regions) {
          if (!regions)
            return;
          for (const region of regions) {
            const el = this.M(region);
            this.j.set(region.id, el);
            this.overlay.append(el);
          }
        }
        M(region) {
          const el = document.createElement("div");
          setPartAttr(el, "region");
          setDataAttr(el, "id", region.id);
          setDataAttr(el, "scroll", region.scroll);
          setCSSVar(el, "region-width", region.width + "%");
          setCSSVar(el, "region-anchor-x", region.regionAnchorX);
          setCSSVar(el, "region-anchor-y", region.regionAnchorY);
          setCSSVar(el, "region-viewport-anchor-x", region.viewportAnchorX);
          setCSSVar(el, "region-viewport-anchor-y", region.viewportAnchorY);
          setCSSVar(el, "region-lines", region.lines);
          return el;
        }
        L(cue) {
          const display = document.createElement("div"), position = computeCuePosition(cue), positionAlignment = computeCuePositionAlignment(cue, this.C);
          setPartAttr(display, "cue-display");
          if (cue.vertical !== "")
            setDataAttr(display, "vertical");
          setCSSVar(display, "cue-text-align", cue.align);
          if (cue.style) {
            for (const prop2 of Object.keys(cue.style)) {
              display.style.setProperty(prop2, cue.style[prop2]);
            }
          }
          if (!this.F(cue)) {
            setCSSVar(
              display,
              "cue-writing-mode",
              cue.vertical === "" ? "horizontal-tb" : cue.vertical === "lr" ? "vertical-lr" : "vertical-rl"
            );
            if (!cue.style?.["--cue-width"]) {
              let maxSize = position;
              if (positionAlignment === "line-left") {
                maxSize = 100 - position;
              } else if (positionAlignment === "center" && position <= 50) {
                maxSize = position * 2;
              } else if (positionAlignment === "center" && position > 50) {
                maxSize = (100 - position) * 2;
              }
              const size2 = cue.size < maxSize ? cue.size : maxSize;
              if (cue.vertical === "")
                setCSSVar(display, "cue-width", size2 + "%");
              else
                setCSSVar(display, "cue-height", size2 + "%");
            }
          } else {
            setCSSVar(
              display,
              "cue-offset",
              `${position - (positionAlignment === "line-right" ? 100 : positionAlignment === "center" ? 50 : 0)}%`
            );
          }
          const el = document.createElement("div");
          setPartAttr(el, "cue");
          if (cue.id)
            setDataAttr(el, "id", cue.id);
          el.innerHTML = renderVTTCueString(cue);
          display.append(el);
          return display;
        }
        F(cue) {
          return cue.region && cue.size === 100 && cue.vertical === "" && cue.line === "auto";
        }
      };
    }
  });

  // node_modules/.pnpm/media-captions@1.0.4/node_modules/media-captions/dist/prod.js
  var prod_exports = {};
  __export(prod_exports, {
    CaptionsRenderer: () => CaptionsRenderer,
    ParseError: () => ParseError,
    ParseErrorCode: () => ParseErrorCode,
    TextCue: () => TextCue,
    VTTCue: () => VTTCue,
    VTTRegion: () => VTTRegion,
    createVTTCueTemplate: () => createVTTCueTemplate,
    parseByteStream: () => parseByteStream,
    parseResponse: () => parseResponse,
    parseText: () => parseText,
    parseTextStream: () => parseTextStream,
    parseVTTTimestamp: () => parseVTTTimestamp,
    renderVTTCueString: () => renderVTTCueString,
    renderVTTTokensString: () => renderVTTTokensString,
    tokenizeVTTCue: () => tokenizeVTTCue,
    updateTimedVTTCueNodes: () => updateTimedVTTCueNodes
  });
  var init_prod2 = __esm({
    "node_modules/.pnpm/media-captions@1.0.4/node_modules/media-captions/dist/prod.js"() {
      init_live_reload();
      init_prod();
    }
  });

  // node_modules/.pnpm/vidstack@1.12.9/node_modules/vidstack/prod/chunks/vidstack-B5628Ni3.js
  function isTrackCaptionKind(track) {
    return captionRE.test(track.kind);
  }
  function parseJSONCaptionsFile(json, Cue, Region) {
    const content = isString(json) ? JSON.parse(json) : json;
    let regions = [], cues = [];
    if (content.regions && Region) {
      regions = content.regions.map((region) => Object.assign(new Region(), region));
    }
    if (content.cues || isArray(content)) {
      cues = (isArray(content) ? content : content.cues).filter((content2) => isNumber(content2.startTime) && isNumber(content2.endTime)).map((cue) => Object.assign(new Cue(0, 0, ""), cue));
    }
    return { regions, cues };
  }
  var CROSS_ORIGIN, READY_STATE, UPDATE_ACTIVE_CUES, CAN_LOAD, ON_MODE_CHANGE, NATIVE, NATIVE_HLS, TextTrackSymbol, TextTrack, captionRE;
  var init_vidstack_B5628Ni3 = __esm({
    "node_modules/.pnpm/vidstack@1.12.9/node_modules/vidstack/prod/chunks/vidstack-B5628Ni3.js"() {
      init_live_reload();
      init_vidstack_CRlI3Mh7();
      init_vidstack_vDnjyKV8();
      init_vidstack_DE4XvkHU();
      CROSS_ORIGIN = Symbol(0);
      READY_STATE = Symbol(0);
      UPDATE_ACTIVE_CUES = Symbol(0);
      CAN_LOAD = Symbol(0);
      ON_MODE_CHANGE = Symbol(0);
      NATIVE = Symbol(0);
      NATIVE_HLS = Symbol(0);
      TextTrackSymbol = {
        crossOrigin: CROSS_ORIGIN,
        readyState: READY_STATE,
        updateActiveCues: UPDATE_ACTIVE_CUES,
        canLoad: CAN_LOAD,
        onModeChange: ON_MODE_CHANGE,
        native: NATIVE,
        nativeHLS: NATIVE_HLS
      };
      TextTrack = class extends EventsTarget {
        static createId(track) {
          return `vds-${track.type}-${track.kind}-${track.src ?? track.label ?? "?"}`;
        }
        src;
        content;
        type;
        encoding;
        id = "";
        label = "";
        language = "";
        kind;
        default = false;
        #canLoad = false;
        #currentTime = 0;
        #mode = "disabled";
        #metadata = {};
        #regions = [];
        #cues = [];
        #activeCues = [];
        /** @internal */
        [TextTrackSymbol.readyState] = 0;
        /** @internal */
        [TextTrackSymbol.crossOrigin];
        /** @internal */
        [TextTrackSymbol.onModeChange] = null;
        /** @internal */
        [TextTrackSymbol.native] = null;
        get metadata() {
          return this.#metadata;
        }
        get regions() {
          return this.#regions;
        }
        get cues() {
          return this.#cues;
        }
        get activeCues() {
          return this.#activeCues;
        }
        /**
         * - 0: Not Loading
         * - 1: Loading
         * - 2: Ready
         * - 3: Error
         */
        get readyState() {
          return this[TextTrackSymbol.readyState];
        }
        get mode() {
          return this.#mode;
        }
        set mode(mode) {
          this.setMode(mode);
        }
        constructor(init5) {
          super();
          for (const prop2 of Object.keys(init5))
            this[prop2] = init5[prop2];
          if (!this.type)
            this.type = "vtt";
          if (init5.content) {
            this.#parseContent(init5);
          } else if (!init5.src) {
            this[TextTrackSymbol.readyState] = 2;
          }
        }
        addCue(cue, trigger) {
          let i5 = 0, length = this.#cues.length;
          for (i5 = 0; i5 < length; i5++)
            if (cue.endTime <= this.#cues[i5].startTime)
              break;
          if (i5 === length)
            this.#cues.push(cue);
          else
            this.#cues.splice(i5, 0, cue);
          if (!(cue instanceof TextTrackCue)) {
            this[TextTrackSymbol.native]?.track.addCue(cue);
          }
          this.dispatchEvent(new DOMEvent("add-cue", { detail: cue, trigger }));
          if (isCueActive(cue, this.#currentTime)) {
            this[TextTrackSymbol.updateActiveCues](this.#currentTime, trigger);
          }
        }
        removeCue(cue, trigger) {
          const index = this.#cues.indexOf(cue);
          if (index >= 0) {
            const isActive = this.#activeCues.includes(cue);
            this.#cues.splice(index, 1);
            this[TextTrackSymbol.native]?.track.removeCue(cue);
            this.dispatchEvent(new DOMEvent("remove-cue", { detail: cue, trigger }));
            if (isActive) {
              this[TextTrackSymbol.updateActiveCues](this.#currentTime, trigger);
            }
          }
        }
        setMode(mode, trigger) {
          if (this.#mode === mode)
            return;
          this.#mode = mode;
          if (mode === "disabled") {
            this.#activeCues = [];
            this.#activeCuesChanged();
          } else if (this.readyState === 2) {
            this[TextTrackSymbol.updateActiveCues](this.#currentTime, trigger);
          } else {
            this.#load();
          }
          this.dispatchEvent(new DOMEvent("mode-change", { detail: this, trigger }));
          this[TextTrackSymbol.onModeChange]?.();
        }
        /** @internal */
        [TextTrackSymbol.updateActiveCues](currentTime, trigger) {
          this.#currentTime = currentTime;
          if (this.mode === "disabled" || !this.#cues.length)
            return;
          const activeCues = [];
          for (let i5 = 0, length = this.#cues.length; i5 < length; i5++) {
            const cue = this.#cues[i5];
            if (isCueActive(cue, currentTime))
              activeCues.push(cue);
          }
          let changed = activeCues.length !== this.#activeCues.length;
          if (!changed) {
            for (let i5 = 0; i5 < activeCues.length; i5++) {
              if (!this.#activeCues.includes(activeCues[i5])) {
                changed = true;
                break;
              }
            }
          }
          this.#activeCues = activeCues;
          if (changed)
            this.#activeCuesChanged(trigger);
        }
        /** @internal */
        [TextTrackSymbol.canLoad]() {
          this.#canLoad = true;
          if (this.#mode !== "disabled")
            this.#load();
        }
        #parseContent(init5) {
          Promise.resolve().then(() => (init_prod2(), prod_exports)).then(({ parseText: parseText2, VTTCue: VTTCue2, VTTRegion: VTTRegion2 }) => {
            if (!isString(init5.content) || init5.type === "json") {
              this.#parseJSON(init5.content, VTTCue2, VTTRegion2);
              if (this.readyState !== 3)
                this.#ready();
            } else {
              parseText2(init5.content, { type: init5.type }).then(({ cues, regions }) => {
                this.#cues = cues;
                this.#regions = regions;
                this.#ready();
              });
            }
          });
        }
        async #load() {
          if (!this.#canLoad || this[TextTrackSymbol.readyState] > 0)
            return;
          this[TextTrackSymbol.readyState] = 1;
          this.dispatchEvent(new DOMEvent("load-start"));
          if (!this.src) {
            this.#ready();
            return;
          }
          try {
            const { parseResponse: parseResponse2, VTTCue: VTTCue2, VTTRegion: VTTRegion2 } = await Promise.resolve().then(() => (init_prod2(), prod_exports)), crossOrigin = this[TextTrackSymbol.crossOrigin]?.();
            const response = fetch(this.src, {
              headers: this.type === "json" ? { "Content-Type": "application/json" } : void 0,
              credentials: getRequestCredentials(crossOrigin)
            });
            if (this.type === "json") {
              this.#parseJSON(await (await response).text(), VTTCue2, VTTRegion2);
            } else {
              const { errors, metadata, regions, cues } = await parseResponse2(response, {
                type: this.type,
                encoding: this.encoding
              });
              if (errors[0]?.code === 0) {
                throw errors[0];
              } else {
                this.#metadata = metadata;
                this.#regions = regions;
                this.#cues = cues;
              }
            }
            this.#ready();
          } catch (error) {
            this.#error(error);
          }
        }
        #ready() {
          this[TextTrackSymbol.readyState] = 2;
          if (!this.src || this.type !== "vtt") {
            const native = this[TextTrackSymbol.native];
            if (native && !native.managed) {
              for (const cue of this.#cues)
                native.track.addCue(cue);
            }
          }
          const loadEvent = new DOMEvent("load");
          this[TextTrackSymbol.updateActiveCues](this.#currentTime, loadEvent);
          this.dispatchEvent(loadEvent);
        }
        #error(error) {
          this[TextTrackSymbol.readyState] = 3;
          this.dispatchEvent(new DOMEvent("error", { detail: error }));
        }
        #parseJSON(json, VTTCue2, VTTRegion2) {
          try {
            const { regions, cues } = parseJSONCaptionsFile(json, VTTCue2, VTTRegion2);
            this.#regions = regions;
            this.#cues = cues;
          } catch (error) {
            this.#error(error);
          }
        }
        #activeCuesChanged(trigger) {
          this.dispatchEvent(new DOMEvent("cue-change", { trigger }));
        }
      };
      captionRE = /captions|subtitles/;
    }
  });

  // node_modules/.pnpm/vidstack@1.12.9/node_modules/vidstack/prod/chunks/vidstack-DXXgp8ue.js
  function updateFocusAttr(el, isFocused) {
    setAttribute(el, "data-focus", isFocused);
    setAttribute(el, "data-hocus", isFocused);
  }
  function updateHoverAttr(el, isHovering) {
    setAttribute(el, "data-hocus", isHovering);
    setAttribute(el, "data-hover", isHovering);
  }
  var $keyboard, FocusVisibleController;
  var init_vidstack_DXXgp8ue = __esm({
    "node_modules/.pnpm/vidstack@1.12.9/node_modules/vidstack/prod/chunks/vidstack-DXXgp8ue.js"() {
      init_live_reload();
      init_vidstack_CRlI3Mh7();
      $keyboard = signal(false);
      {
        listenEvent(document, "pointerdown", () => {
          $keyboard.set(false);
        });
        listenEvent(document, "keydown", (e8) => {
          if (e8.metaKey || e8.altKey || e8.ctrlKey)
            return;
          $keyboard.set(true);
        });
      }
      FocusVisibleController = class extends ViewController {
        #focused = signal(false);
        onConnect(el) {
          effect(() => {
            const events2 = new EventsController(el);
            if (!$keyboard()) {
              this.#focused.set(false);
              updateFocusAttr(el, false);
              events2.add("pointerenter", this.#onPointerEnter.bind(this)).add("pointerleave", this.#onPointerLeave.bind(this));
              return;
            }
            const active = document.activeElement === el;
            this.#focused.set(active);
            updateFocusAttr(el, active);
            events2.add("focus", this.#onFocus.bind(this)).add("blur", this.#onBlur.bind(this));
          });
        }
        focused() {
          return this.#focused();
        }
        #onFocus() {
          this.#focused.set(true);
          updateFocusAttr(this.el, true);
        }
        #onBlur() {
          this.#focused.set(false);
          updateFocusAttr(this.el, false);
        }
        #onPointerEnter() {
          updateHoverAttr(this.el, true);
        }
        #onPointerLeave() {
          updateHoverAttr(this.el, false);
        }
      };
    }
  });

  // node_modules/.pnpm/vidstack@1.12.9/node_modules/vidstack/prod/chunks/vidstack-C9vIqaYT.js
  function coerceToError(error) {
    return error instanceof Error ? error : Error(typeof error === "string" ? error : JSON.stringify(error));
  }
  function assert(condition, message) {
    if (!condition) {
      throw Error("Assertion failed.");
    }
  }
  var init_vidstack_C9vIqaYT = __esm({
    "node_modules/.pnpm/vidstack@1.12.9/node_modules/vidstack/prod/chunks/vidstack-C9vIqaYT.js"() {
      init_live_reload();
    }
  });

  // node_modules/.pnpm/vidstack@1.12.9/node_modules/vidstack/prod/chunks/vidstack-Dihypf8P.js
  function round2(num, decimalPlaces = 2) {
    return Number(num.toFixed(decimalPlaces));
  }
  function getNumberOfDecimalPlaces(num) {
    return String(num).split(".")[1]?.length ?? 0;
  }
  function clampNumber(min2, value, max2) {
    return Math.max(min2, Math.min(max2, value));
  }
  var init_vidstack_Dihypf8P = __esm({
    "node_modules/.pnpm/vidstack@1.12.9/node_modules/vidstack/prod/chunks/vidstack-Dihypf8P.js"() {
      init_live_reload();
    }
  });

  // node_modules/.pnpm/vidstack@1.12.9/node_modules/vidstack/prod/chunks/vidstack-C3qcqQM6.js
  function padNumberWithZeroes(num, expectedLength) {
    const str = String(num);
    const actualLength = str.length;
    const shouldPad = actualLength < expectedLength;
    if (shouldPad) {
      const padLength = expectedLength - actualLength;
      const padding = `0`.repeat(padLength);
      return `${padding}${num}`;
    }
    return str;
  }
  function parseTime(duration) {
    const hours = Math.trunc(duration / 3600);
    const minutes = Math.trunc(duration % 3600 / 60);
    const seconds = Math.trunc(duration % 60);
    const fraction = Number((duration - Math.trunc(duration)).toPrecision(3));
    return {
      hours,
      minutes,
      seconds,
      fraction
    };
  }
  function formatTime(duration, { padHrs = null, padMins = null, showHrs = false, showMs = false } = {}) {
    const { hours, minutes, seconds, fraction } = parseTime(duration), paddedHours = padHrs ? padNumberWithZeroes(hours, 2) : hours, paddedMinutes = padMins || isNull(padMins) && duration >= 3600 ? padNumberWithZeroes(minutes, 2) : minutes, paddedSeconds = padNumberWithZeroes(seconds, 2), paddedMs = showMs && fraction > 0 ? `.${String(fraction).replace(/^0?\./, "")}` : "", time = `${paddedMinutes}:${paddedSeconds}${paddedMs}`;
    return hours > 0 || showHrs ? `${paddedHours}:${time}` : time;
  }
  function formatSpokenTime(duration) {
    const spokenParts = [];
    const { hours, minutes, seconds } = parseTime(duration);
    if (hours > 0) {
      spokenParts.push(`${hours} hour`);
    }
    if (minutes > 0) {
      spokenParts.push(`${minutes} min`);
    }
    if (seconds > 0 || spokenParts.length === 0) {
      spokenParts.push(`${seconds} sec`);
    }
    return spokenParts.join(" ");
  }
  function calcRate(min2, max2, value) {
    const range = max2 - min2, offset2 = value - min2;
    return range > 0 ? offset2 / range : 0;
  }
  function getClampedValue(min2, max2, value, step) {
    return clampNumber(min2, round2(value, getNumberOfDecimalPlaces(step)), max2);
  }
  function getValueFromRate(min2, max2, rate, step) {
    const boundRate = clampNumber(0, rate, 1), range = max2 - min2, fill = range * boundRate, stepRatio = fill / step, steps = step * Math.round(stepRatio);
    return min2 + steps;
  }
  function updateSliderPreviewPlacement(el, {
    clamp: clamp5,
    offset: offset2,
    orientation
  }) {
    const computedStyle = getComputedStyle(el), width = parseFloat(computedStyle.width), height = parseFloat(computedStyle.height), styles = {
      top: null,
      right: null,
      bottom: null,
      left: null
    };
    styles[orientation === "horizontal" ? "bottom" : "left"] = `calc(100% + var(--media-slider-preview-offset, ${offset2}px))`;
    if (orientation === "horizontal") {
      const widthHalf = width / 2;
      if (!clamp5) {
        styles.left = `calc(var(--slider-pointer) - ${widthHalf}px)`;
      } else {
        const leftClamp = `max(0px, calc(var(--slider-pointer) - ${widthHalf}px))`, rightClamp = `calc(100% - ${width}px)`;
        styles.left = `min(${leftClamp}, ${rightClamp})`;
      }
    } else {
      const heightHalf = height / 2;
      if (!clamp5) {
        styles.bottom = `calc(var(--slider-pointer) - ${heightHalf}px)`;
      } else {
        const topClamp = `max(${heightHalf}px, calc(var(--slider-pointer) - ${heightHalf}px))`, bottomClamp = `calc(100% - ${height}px)`;
        styles.bottom = `min(${topClamp}, ${bottomClamp})`;
      }
    }
    Object.assign(el.style, styles);
  }
  function scrollIntoView(el, options) {
    const scrolls = r2(el, options);
    for (const { el: el2, top, left } of scrolls) {
      el2.scroll({ top, left, behavior: options.behavior });
    }
  }
  function scrollIntoCenter(el, options = {}) {
    scrollIntoView(el, {
      scrollMode: "if-needed",
      block: "center",
      inline: "center",
      ...options
    });
  }
  var ARIAKeyShortcuts, Popper, ToggleButtonController, AirPlayButton, PlayButton, CaptionButton, FullscreenButton, MuteButton, PIPButton, SeekButton, LiveButton, sliderState, IntersectionObserverController, sliderContext, sliderObserverContext, SliderKeyDirection, SliderEventsController, sliderValueFormatContext, SliderController, Slider, cache, pending, ThumbnailsLoader, Thumbnail, SliderValue, slidervalue__proto, SliderPreview, VolumeSlider, TimeSlider, menuContext, FOCUSABLE_ELEMENTS_SELECTOR, VALID_KEYS, MenuFocusController, __defProp2, __getOwnPropDesc2, __decorateClass, idCount, Menu, MenuButton, menubutton__proto, MenuItem, menuPortalContext, MenuItems, radioControllerContext, RadioGroupController, AudioRadioGroup, audioradiogroup__proto, CaptionsRadioGroup, captionsradiogroup__proto, DEFAULT_PLAYBACK_RATES, SpeedRadioGroup, speedradiogroup__proto, QualityRadioGroup, qualityradiogroup__proto, Time;
  var init_vidstack_C3qcqQM6 = __esm({
    "node_modules/.pnpm/vidstack@1.12.9/node_modules/vidstack/prod/chunks/vidstack-C3qcqQM6.js"() {
      init_live_reload();
      init_vidstack_CRlI3Mh7();
      init_vidstack_Cpte_fRf();
      init_vidstack_BOTZD4tC();
      init_vidstack_Ds_q5BGO();
      init_vidstack_B5628Ni3();
      init_vidstack_DXXgp8ue();
      init_vidstack_C9vIqaYT();
      init_vidstack_vDnjyKV8();
      init_vidstack_Dihypf8P();
      init_vidstack_DE4XvkHU();
      ARIAKeyShortcuts = class extends ViewController {
        #shortcut;
        constructor(shortcut) {
          super();
          this.#shortcut = shortcut;
        }
        onAttach(el) {
          const { $props, ariaKeys } = useMediaContext(), keys = el.getAttribute("aria-keyshortcuts");
          if (keys) {
            ariaKeys[this.#shortcut] = keys;
            {
              onDispose(() => {
                delete ariaKeys[this.#shortcut];
              });
            }
            return;
          }
          const shortcuts = $props.keyShortcuts()[this.#shortcut];
          if (shortcuts) {
            const keys2 = isArray(shortcuts) ? shortcuts.join(" ") : isString(shortcuts) ? shortcuts : shortcuts?.keys;
            el.setAttribute("aria-keyshortcuts", isArray(keys2) ? keys2.join(" ") : keys2);
          }
        }
      };
      Popper = class extends ViewController {
        #delegate;
        constructor(delegate) {
          super();
          this.#delegate = delegate;
          effect(this.#watchTrigger.bind(this));
        }
        onDestroy() {
          this.#stopAnimationEndListener?.();
          this.#stopAnimationEndListener = null;
        }
        #watchTrigger() {
          const trigger = this.#delegate.trigger();
          if (!trigger) {
            this.hide();
            return;
          }
          const show = this.show.bind(this), hide2 = this.hide.bind(this);
          this.#delegate.listen(trigger, show, hide2);
        }
        #showTimerId = -1;
        #hideRafId = -1;
        #stopAnimationEndListener = null;
        show(trigger) {
          this.#cancelShowing();
          window.cancelAnimationFrame(this.#hideRafId);
          this.#hideRafId = -1;
          this.#stopAnimationEndListener?.();
          this.#stopAnimationEndListener = null;
          this.#showTimerId = window.setTimeout(() => {
            this.#showTimerId = -1;
            const content = this.#delegate.content();
            if (content)
              content.style.removeProperty("display");
            peek(() => this.#delegate.onChange(true, trigger));
          }, this.#delegate.showDelay?.() ?? 0);
        }
        hide(trigger) {
          this.#cancelShowing();
          peek(() => this.#delegate.onChange(false, trigger));
          this.#hideRafId = requestAnimationFrame(() => {
            this.#cancelShowing();
            this.#hideRafId = -1;
            const content = this.#delegate.content();
            if (content) {
              const onHide = () => {
                content.style.display = "none";
                this.#stopAnimationEndListener = null;
              };
              const isAnimated = hasAnimation(content);
              if (isAnimated) {
                this.#stopAnimationEndListener?.();
                const stop = listenEvent(content, "animationend", onHide, { once: true });
                this.#stopAnimationEndListener = stop;
              } else {
                onHide();
              }
            }
          });
        }
        #cancelShowing() {
          window.clearTimeout(this.#showTimerId);
          this.#showTimerId = -1;
        }
      };
      ToggleButtonController = class extends ViewController {
        static props = {
          disabled: false
        };
        #delegate;
        constructor(delegate) {
          super();
          this.#delegate = delegate;
          new FocusVisibleController();
          if (delegate.keyShortcut) {
            new ARIAKeyShortcuts(delegate.keyShortcut);
          }
        }
        onSetup() {
          const { disabled } = this.$props;
          this.setAttributes({
            "data-pressed": this.#delegate.isPresssed,
            "aria-pressed": this.#isARIAPressed.bind(this),
            "aria-disabled": () => disabled() ? "true" : null
          });
        }
        onAttach(el) {
          setAttributeIfEmpty(el, "tabindex", "0");
          setAttributeIfEmpty(el, "role", "button");
          setAttributeIfEmpty(el, "type", "button");
        }
        onConnect(el) {
          const events2 = onPress(el, this.#onMaybePress.bind(this));
          for (const type of ["click", "touchstart"]) {
            events2.add(type, this.#onInteraction.bind(this), {
              passive: true
            });
          }
        }
        #isARIAPressed() {
          return ariaBool(this.#delegate.isPresssed());
        }
        #onPressed(event2) {
          if (isWriteSignal(this.#delegate.isPresssed)) {
            this.#delegate.isPresssed.set((p2) => !p2);
          }
        }
        #onMaybePress(event2) {
          const disabled = this.$props.disabled() || this.el.hasAttribute("data-disabled");
          if (disabled) {
            event2.preventDefault();
            event2.stopImmediatePropagation();
            return;
          }
          event2.preventDefault();
          (this.#delegate.onPress ?? this.#onPressed).call(this, event2);
        }
        #onInteraction(event2) {
          if (this.$props.disabled()) {
            event2.preventDefault();
            event2.stopImmediatePropagation();
          }
        }
      };
      AirPlayButton = class extends Component {
        static props = ToggleButtonController.props;
        #media;
        constructor() {
          super();
          new ToggleButtonController({
            isPresssed: this.#isPressed.bind(this),
            onPress: this.#onPress.bind(this)
          });
        }
        onSetup() {
          this.#media = useMediaContext();
          const { canAirPlay, isAirPlayConnected } = this.#media.$state;
          this.setAttributes({
            "data-active": isAirPlayConnected,
            "data-supported": canAirPlay,
            "data-state": this.#getState.bind(this),
            "aria-hidden": $ariaBool(() => !canAirPlay())
          });
        }
        onAttach(el) {
          el.setAttribute("data-media-tooltip", "airplay");
          setARIALabel(el, this.#getDefaultLabel.bind(this));
        }
        #onPress(event2) {
          const remote = this.#media.remote;
          remote.requestAirPlay(event2);
        }
        #isPressed() {
          const { remotePlaybackType, remotePlaybackState } = this.#media.$state;
          return remotePlaybackType() === "airplay" && remotePlaybackState() !== "disconnected";
        }
        #getState() {
          const { remotePlaybackType, remotePlaybackState } = this.#media.$state;
          return remotePlaybackType() === "airplay" && remotePlaybackState();
        }
        #getDefaultLabel() {
          const { remotePlaybackState } = this.#media.$state;
          return `AirPlay ${remotePlaybackState()}`;
        }
      };
      PlayButton = class extends Component {
        static props = ToggleButtonController.props;
        #media;
        constructor() {
          super();
          new ToggleButtonController({
            isPresssed: this.#isPressed.bind(this),
            keyShortcut: "togglePaused",
            onPress: this.#onPress.bind(this)
          });
        }
        onSetup() {
          this.#media = useMediaContext();
          const { paused, ended } = this.#media.$state;
          this.setAttributes({
            "data-paused": paused,
            "data-ended": ended
          });
        }
        onAttach(el) {
          el.setAttribute("data-media-tooltip", "play");
          setARIALabel(el, "Play");
        }
        #onPress(event2) {
          const remote = this.#media.remote;
          this.#isPressed() ? remote.pause(event2) : remote.play(event2);
        }
        #isPressed() {
          const { paused } = this.#media.$state;
          return !paused();
        }
      };
      CaptionButton = class extends Component {
        static props = ToggleButtonController.props;
        #media;
        constructor() {
          super();
          new ToggleButtonController({
            isPresssed: this.#isPressed.bind(this),
            keyShortcut: "toggleCaptions",
            onPress: this.#onPress.bind(this)
          });
        }
        onSetup() {
          this.#media = useMediaContext();
          this.setAttributes({
            "data-active": this.#isPressed.bind(this),
            "data-supported": () => !this.#isHidden(),
            "aria-hidden": $ariaBool(this.#isHidden.bind(this))
          });
        }
        onAttach(el) {
          el.setAttribute("data-media-tooltip", "caption");
          setARIALabel(el, "Captions");
        }
        #onPress(event2) {
          this.#media.remote.toggleCaptions(event2);
        }
        #isPressed() {
          const { textTrack } = this.#media.$state, track = textTrack();
          return !!track && isTrackCaptionKind(track);
        }
        #isHidden() {
          const { hasCaptions } = this.#media.$state;
          return !hasCaptions();
        }
      };
      FullscreenButton = class extends Component {
        static props = {
          ...ToggleButtonController.props,
          target: "prefer-media"
        };
        #media;
        constructor() {
          super();
          new ToggleButtonController({
            isPresssed: this.#isPressed.bind(this),
            keyShortcut: "toggleFullscreen",
            onPress: this.#onPress.bind(this)
          });
        }
        onSetup() {
          this.#media = useMediaContext();
          const { fullscreen } = this.#media.$state, isSupported = this.#isSupported.bind(this);
          this.setAttributes({
            "data-active": fullscreen,
            "data-supported": isSupported,
            "aria-hidden": $ariaBool(() => !isSupported())
          });
        }
        onAttach(el) {
          el.setAttribute("data-media-tooltip", "fullscreen");
          setARIALabel(el, "Fullscreen");
        }
        #onPress(event2) {
          const remote = this.#media.remote, target = this.$props.target();
          this.#isPressed() ? remote.exitFullscreen(target, event2) : remote.enterFullscreen(target, event2);
        }
        #isPressed() {
          const { fullscreen } = this.#media.$state;
          return fullscreen();
        }
        #isSupported() {
          const { canFullscreen } = this.#media.$state;
          return canFullscreen();
        }
      };
      MuteButton = class extends Component {
        static props = ToggleButtonController.props;
        #media;
        constructor() {
          super();
          new ToggleButtonController({
            isPresssed: this.#isPressed.bind(this),
            keyShortcut: "toggleMuted",
            onPress: this.#onPress.bind(this)
          });
        }
        onSetup() {
          this.#media = useMediaContext();
          this.setAttributes({
            "data-muted": this.#isPressed.bind(this),
            "data-state": this.#getState.bind(this)
          });
        }
        onAttach(el) {
          el.setAttribute("data-media-mute-button", "");
          el.setAttribute("data-media-tooltip", "mute");
          setARIALabel(el, "Mute");
        }
        #onPress(event2) {
          const remote = this.#media.remote;
          this.#isPressed() ? remote.unmute(event2) : remote.mute(event2);
        }
        #isPressed() {
          const { muted, volume } = this.#media.$state;
          return muted() || volume() === 0;
        }
        #getState() {
          const { muted, volume } = this.#media.$state, $volume = volume();
          if (muted() || $volume === 0)
            return "muted";
          else if ($volume >= 0.5)
            return "high";
          else if ($volume < 0.5)
            return "low";
        }
      };
      PIPButton = class extends Component {
        static props = ToggleButtonController.props;
        #media;
        constructor() {
          super();
          new ToggleButtonController({
            isPresssed: this.#isPressed.bind(this),
            keyShortcut: "togglePictureInPicture",
            onPress: this.#onPress.bind(this)
          });
        }
        onSetup() {
          this.#media = useMediaContext();
          const { pictureInPicture } = this.#media.$state, isSupported = this.#isSupported.bind(this);
          this.setAttributes({
            "data-active": pictureInPicture,
            "data-supported": isSupported,
            "aria-hidden": $ariaBool(() => !isSupported())
          });
        }
        onAttach(el) {
          el.setAttribute("data-media-tooltip", "pip");
          setARIALabel(el, "PiP");
        }
        #onPress(event2) {
          const remote = this.#media.remote;
          this.#isPressed() ? remote.exitPictureInPicture(event2) : remote.enterPictureInPicture(event2);
        }
        #isPressed() {
          const { pictureInPicture } = this.#media.$state;
          return pictureInPicture();
        }
        #isSupported() {
          const { canPictureInPicture } = this.#media.$state;
          return canPictureInPicture();
        }
      };
      SeekButton = class extends Component {
        static props = {
          disabled: false,
          seconds: 30
        };
        #media;
        constructor() {
          super();
          new FocusVisibleController();
        }
        onSetup() {
          this.#media = useMediaContext();
          const { seeking } = this.#media.$state, { seconds } = this.$props, isSupported = this.#isSupported.bind(this);
          this.setAttributes({
            seconds,
            "data-seeking": seeking,
            "data-supported": isSupported,
            "aria-hidden": $ariaBool(() => !isSupported())
          });
        }
        onAttach(el) {
          setAttributeIfEmpty(el, "tabindex", "0");
          setAttributeIfEmpty(el, "role", "button");
          setAttributeIfEmpty(el, "type", "button");
          el.setAttribute("data-media-tooltip", "seek");
          setARIALabel(el, this.#getDefaultLabel.bind(this));
        }
        onConnect(el) {
          onPress(el, this.#onPress.bind(this));
        }
        #isSupported() {
          const { canSeek } = this.#media.$state;
          return canSeek();
        }
        #getDefaultLabel() {
          const { seconds } = this.$props;
          return `Seek ${seconds() > 0 ? "forward" : "backward"} ${seconds()} seconds`;
        }
        #onPress(event2) {
          const { seconds, disabled } = this.$props;
          if (disabled())
            return;
          const { currentTime } = this.#media.$state, seekTo = currentTime() + seconds();
          this.#media.remote.seek(seekTo, event2);
        }
      };
      LiveButton = class extends Component {
        static props = {
          disabled: false
        };
        #media;
        constructor() {
          super();
          new FocusVisibleController();
        }
        onSetup() {
          this.#media = useMediaContext();
          const { disabled } = this.$props, { live, liveEdge } = this.#media.$state, isHidden = () => !live();
          this.setAttributes({
            "data-edge": liveEdge,
            "data-hidden": isHidden,
            "aria-disabled": $ariaBool(() => disabled() || liveEdge()),
            "aria-hidden": $ariaBool(isHidden)
          });
        }
        onAttach(el) {
          setAttributeIfEmpty(el, "tabindex", "0");
          setAttributeIfEmpty(el, "role", "button");
          setAttributeIfEmpty(el, "type", "button");
          el.setAttribute("data-media-tooltip", "live");
        }
        onConnect(el) {
          onPress(el, this.#onPress.bind(this));
        }
        #onPress(event2) {
          const { disabled } = this.$props, { liveEdge } = this.#media.$state;
          if (disabled() || liveEdge())
            return;
          this.#media.remote.seekToLiveEdge(event2);
        }
      };
      sliderState = new State({
        min: 0,
        max: 100,
        value: 0,
        step: 1,
        pointerValue: 0,
        focused: false,
        dragging: false,
        pointing: false,
        hidden: false,
        get active() {
          return this.dragging || this.focused || this.pointing;
        },
        get fillRate() {
          return calcRate(this.min, this.max, this.value);
        },
        get fillPercent() {
          return this.fillRate * 100;
        },
        get pointerRate() {
          return calcRate(this.min, this.max, this.pointerValue);
        },
        get pointerPercent() {
          return this.pointerRate * 100;
        }
      });
      IntersectionObserverController = class extends ViewController {
        #init;
        #observer;
        constructor(init5) {
          super();
          this.#init = init5;
        }
        onConnect(el) {
          this.#observer = new IntersectionObserver((entries) => {
            this.#init.callback?.(entries, this.#observer);
          }, this.#init);
          this.#observer.observe(el);
          onDispose(this.#onDisconnect.bind(this));
        }
        /**
         * Disconnect any active intersection observers.
         */
        #onDisconnect() {
          this.#observer?.disconnect();
          this.#observer = void 0;
        }
      };
      sliderContext = createContext();
      sliderObserverContext = createContext();
      SliderKeyDirection = {
        Left: -1,
        ArrowLeft: -1,
        Up: 1,
        ArrowUp: 1,
        Right: 1,
        ArrowRight: 1,
        Down: -1,
        ArrowDown: -1
      };
      SliderEventsController = class extends ViewController {
        #delegate;
        #media;
        #observer;
        constructor(delegate, media) {
          super();
          this.#delegate = delegate;
          this.#media = media;
        }
        onSetup() {
          if (hasProvidedContext(sliderObserverContext)) {
            this.#observer = useContext(sliderObserverContext);
          }
        }
        onConnect(el) {
          effect(this.#attachEventListeners.bind(this, el));
          effect(this.#attachPointerListeners.bind(this, el));
          if (this.#delegate.swipeGesture)
            effect(this.#watchSwipeGesture.bind(this));
        }
        #watchSwipeGesture() {
          const { pointer } = this.#media.$state;
          if (pointer() !== "coarse" || !this.#delegate.swipeGesture()) {
            this.#provider = null;
            return;
          }
          this.#provider = this.#media.player.el?.querySelector(
            "media-provider,[data-media-provider]"
          );
          if (!this.#provider)
            return;
          new EventsController(this.#provider).add("touchstart", this.#onTouchStart.bind(this), {
            passive: true
          }).add("touchmove", this.#onTouchMove.bind(this), { passive: false });
        }
        #provider = null;
        #touch = null;
        #touchStartValue = null;
        #onTouchStart(event2) {
          this.#touch = event2.touches[0];
        }
        #onTouchMove(event2) {
          if (isNull(this.#touch) || isTouchPinchEvent(event2))
            return;
          const touch = event2.touches[0], xDiff = touch.clientX - this.#touch.clientX, yDiff = touch.clientY - this.#touch.clientY, isDragging = this.$state.dragging();
          if (!isDragging && Math.abs(yDiff) > 5) {
            return;
          }
          if (isDragging)
            return;
          event2.preventDefault();
          if (Math.abs(xDiff) > 20) {
            this.#touch = touch;
            this.#touchStartValue = this.$state.value();
            this.#onStartDragging(this.#touchStartValue, event2);
          }
        }
        #attachEventListeners(el) {
          const { hidden } = this.$props;
          new EventsController(el).add("focus", this.#onFocus.bind(this)).add("keyup", this.#onKeyUp.bind(this)).add("keydown", this.#onKeyDown.bind(this));
          if (hidden() || this.#delegate.isDisabled())
            return;
          new EventsController(el).add("pointerenter", this.#onPointerEnter.bind(this)).add("pointermove", this.#onPointerMove.bind(this)).add("pointerleave", this.#onPointerLeave.bind(this)).add("pointerdown", this.#onPointerDown.bind(this));
        }
        #attachPointerListeners(el) {
          if (this.#delegate.isDisabled() || !this.$state.dragging())
            return;
          new EventsController(document).add("pointerup", this.#onDocumentPointerUp.bind(this), { capture: true }).add("pointermove", this.#onDocumentPointerMove.bind(this)).add("touchmove", this.#onDocumentTouchMove.bind(this), {
            passive: false
          });
        }
        #onFocus() {
          this.#updatePointerValue(this.$state.value());
        }
        #updateValue(newValue, trigger) {
          const { value, min: min2, max: max2, dragging } = this.$state;
          const clampedValue = Math.max(min2(), Math.min(newValue, max2()));
          value.set(clampedValue);
          const event2 = this.createEvent("value-change", { detail: clampedValue, trigger });
          this.dispatch(event2);
          this.#delegate.onValueChange?.(event2);
          if (dragging()) {
            const event22 = this.createEvent("drag-value-change", { detail: clampedValue, trigger });
            this.dispatch(event22);
            this.#delegate.onDragValueChange?.(event22);
          }
        }
        #updatePointerValue(value, trigger) {
          const { pointerValue, dragging } = this.$state;
          pointerValue.set(value);
          this.dispatch("pointer-value-change", { detail: value, trigger });
          if (dragging()) {
            this.#updateValue(value, trigger);
          }
        }
        #getPointerValue(event2) {
          let thumbPositionRate, rect = this.el.getBoundingClientRect(), { min: min2, max: max2 } = this.$state;
          if (this.$props.orientation() === "vertical") {
            const { bottom: trackBottom, height: trackHeight } = rect;
            thumbPositionRate = (trackBottom - event2.clientY) / trackHeight;
          } else {
            if (this.#touch && isNumber(this.#touchStartValue)) {
              const { width } = this.#provider.getBoundingClientRect(), rate = (event2.clientX - this.#touch.clientX) / width, range = max2() - min2(), diff = range * Math.abs(rate);
              thumbPositionRate = (rate < 0 ? this.#touchStartValue - diff : this.#touchStartValue + diff) / range;
            } else {
              const { left: trackLeft, width: trackWidth } = rect;
              thumbPositionRate = (event2.clientX - trackLeft) / trackWidth;
            }
          }
          return Math.max(
            min2(),
            Math.min(
              max2(),
              this.#delegate.roundValue(
                getValueFromRate(min2(), max2(), thumbPositionRate, this.#delegate.getStep())
              )
            )
          );
        }
        #onPointerEnter(event2) {
          this.$state.pointing.set(true);
        }
        #onPointerMove(event2) {
          const { dragging } = this.$state;
          if (dragging())
            return;
          this.#updatePointerValue(this.#getPointerValue(event2), event2);
        }
        #onPointerLeave(event2) {
          this.$state.pointing.set(false);
        }
        #onPointerDown(event2) {
          if (event2.button !== 0)
            return;
          const value = this.#getPointerValue(event2);
          this.#onStartDragging(value, event2);
          this.#updatePointerValue(value, event2);
        }
        #onStartDragging(value, trigger) {
          const { dragging } = this.$state;
          if (dragging())
            return;
          dragging.set(true);
          this.#media.remote.pauseControls(trigger);
          const event2 = this.createEvent("drag-start", { detail: value, trigger });
          this.dispatch(event2);
          this.#delegate.onDragStart?.(event2);
          this.#observer?.onDragStart?.();
        }
        #onStopDragging(value, trigger) {
          const { dragging } = this.$state;
          if (!dragging())
            return;
          dragging.set(false);
          this.#media.remote.resumeControls(trigger);
          const event2 = this.createEvent("drag-end", { detail: value, trigger });
          this.dispatch(event2);
          this.#delegate.onDragEnd?.(event2);
          this.#touch = null;
          this.#touchStartValue = null;
          this.#observer?.onDragEnd?.();
        }
        // -------------------------------------------------------------------------------------------
        // Keyboard Events
        // -------------------------------------------------------------------------------------------
        #lastDownKey;
        #repeatedKeys = false;
        #onKeyDown(event2) {
          const isValidKey = Object.keys(SliderKeyDirection).includes(event2.key);
          if (!isValidKey)
            return;
          const { key: key2 } = event2, jumpValue = this.#calcJumpValue(event2);
          if (!isNull(jumpValue)) {
            this.#updatePointerValue(jumpValue, event2);
            this.#updateValue(jumpValue, event2);
            return;
          }
          const newValue = this.#calcNewKeyValue(event2);
          if (!this.#repeatedKeys) {
            this.#repeatedKeys = key2 === this.#lastDownKey;
            if (!this.$state.dragging() && this.#repeatedKeys) {
              this.#onStartDragging(newValue, event2);
            }
          }
          this.#updatePointerValue(newValue, event2);
          this.#lastDownKey = key2;
        }
        #onKeyUp(event2) {
          const isValidKey = Object.keys(SliderKeyDirection).includes(event2.key);
          if (!isValidKey || !isNull(this.#calcJumpValue(event2)))
            return;
          const newValue = this.#repeatedKeys ? this.$state.pointerValue() : this.#calcNewKeyValue(event2);
          this.#updateValue(newValue, event2);
          this.#onStopDragging(newValue, event2);
          this.#lastDownKey = "";
          this.#repeatedKeys = false;
        }
        #calcJumpValue(event2) {
          let key2 = event2.key, { min: min2, max: max2 } = this.$state;
          if (key2 === "Home" || key2 === "PageUp") {
            return min2();
          } else if (key2 === "End" || key2 === "PageDown") {
            return max2();
          } else if (!event2.metaKey && /^[0-9]$/.test(key2)) {
            return (max2() - min2()) / 10 * Number(key2);
          }
          return null;
        }
        #calcNewKeyValue(event2) {
          const { key: key2, shiftKey } = event2;
          event2.preventDefault();
          event2.stopPropagation();
          const { shiftKeyMultiplier } = this.$props;
          const { min: min2, max: max2, value, pointerValue } = this.$state, step = this.#delegate.getStep(), keyStep = this.#delegate.getKeyStep();
          const modifiedStep = !shiftKey ? keyStep : keyStep * shiftKeyMultiplier(), direction = Number(SliderKeyDirection[key2]), diff = modifiedStep * direction, currentValue = this.#repeatedKeys ? pointerValue() : this.#delegate.getValue?.() ?? value(), steps = (currentValue + diff) / step;
          return Math.max(min2(), Math.min(max2(), Number((step * steps).toFixed(3))));
        }
        // -------------------------------------------------------------------------------------------
        // Document (Pointer Events)
        // -------------------------------------------------------------------------------------------
        #onDocumentPointerUp(event2) {
          if (event2.button !== 0)
            return;
          event2.preventDefault();
          event2.stopImmediatePropagation();
          const value = this.#getPointerValue(event2);
          this.#updatePointerValue(value, event2);
          this.#onStopDragging(value, event2);
        }
        #onDocumentTouchMove(event2) {
          event2.preventDefault();
        }
        #onDocumentPointerMove = functionThrottle(
          (event2) => {
            this.#updatePointerValue(this.#getPointerValue(event2), event2);
          },
          20,
          { leading: true }
        );
      };
      sliderValueFormatContext = createContext(() => ({}));
      SliderController = class extends ViewController {
        static props = {
          hidden: false,
          disabled: false,
          step: 1,
          keyStep: 1,
          orientation: "horizontal",
          shiftKeyMultiplier: 5
        };
        #media;
        #delegate;
        #isVisible = signal(true);
        #isIntersecting = signal(true);
        constructor(delegate) {
          super();
          this.#delegate = delegate;
        }
        onSetup() {
          this.#media = useMediaContext();
          const focus = new FocusVisibleController();
          focus.attach(this);
          this.$state.focused = focus.focused.bind(focus);
          if (!hasProvidedContext(sliderValueFormatContext)) {
            provideContext(sliderValueFormatContext, {
              default: "value"
            });
          }
          provideContext(sliderContext, {
            orientation: this.$props.orientation,
            disabled: this.#delegate.isDisabled,
            preview: signal(null)
          });
          effect(this.#watchValue.bind(this));
          effect(this.#watchStep.bind(this));
          effect(this.#watchDisabled.bind(this));
          this.#setupAttrs();
          new SliderEventsController(this.#delegate, this.#media).attach(this);
          new IntersectionObserverController({
            callback: this.#onIntersectionChange.bind(this)
          }).attach(this);
        }
        onAttach(el) {
          setAttributeIfEmpty(el, "role", "slider");
          setAttributeIfEmpty(el, "tabindex", "0");
          setAttributeIfEmpty(el, "autocomplete", "off");
          effect(this.#watchCSSVars.bind(this));
        }
        onConnect(el) {
          onDispose(observeVisibility(el, this.#isVisible.set));
          effect(this.#watchHidden.bind(this));
        }
        #onIntersectionChange(entries) {
          this.#isIntersecting.set(entries[0].isIntersecting);
        }
        // -------------------------------------------------------------------------------------------
        // Watch
        // -------------------------------------------------------------------------------------------
        #watchHidden() {
          const { hidden } = this.$props;
          this.$state.hidden.set(hidden() || !this.#isVisible() || !this.#isIntersecting.bind(this));
        }
        #watchValue() {
          const { dragging, value, min: min2, max: max2 } = this.$state;
          if (peek(dragging))
            return;
          value.set(getClampedValue(min2(), max2(), value(), this.#delegate.getStep()));
        }
        #watchStep() {
          this.$state.step.set(this.#delegate.getStep());
        }
        #watchDisabled() {
          if (!this.#delegate.isDisabled())
            return;
          const { dragging, pointing } = this.$state;
          dragging.set(false);
          pointing.set(false);
        }
        // -------------------------------------------------------------------------------------------
        // ARIA
        // -------------------------------------------------------------------------------------------
        #getARIADisabled() {
          return ariaBool(this.#delegate.isDisabled());
        }
        // -------------------------------------------------------------------------------------------
        // Attributes
        // -------------------------------------------------------------------------------------------
        #setupAttrs() {
          const { orientation } = this.$props, { dragging, active, pointing } = this.$state;
          this.setAttributes({
            "data-dragging": dragging,
            "data-pointing": pointing,
            "data-active": active,
            "aria-disabled": this.#getARIADisabled.bind(this),
            "aria-valuemin": this.#delegate.aria.valueMin ?? this.$state.min,
            "aria-valuemax": this.#delegate.aria.valueMax ?? this.$state.max,
            "aria-valuenow": this.#delegate.aria.valueNow,
            "aria-valuetext": this.#delegate.aria.valueText,
            "aria-orientation": orientation
          });
        }
        #watchCSSVars() {
          const { fillPercent, pointerPercent } = this.$state;
          this.#updateSliderVars(round2(fillPercent(), 3), round2(pointerPercent(), 3));
        }
        #updateSliderVars = animationFrameThrottle((fillPercent, pointerPercent) => {
          this.el?.style.setProperty("--slider-fill", fillPercent + "%");
          this.el?.style.setProperty("--slider-pointer", pointerPercent + "%");
        });
      };
      Slider = class extends Component {
        static props = {
          ...SliderController.props,
          min: 0,
          max: 100,
          value: 0
        };
        static state = sliderState;
        constructor() {
          super();
          new SliderController({
            getStep: this.$props.step,
            getKeyStep: this.$props.keyStep,
            roundValue: Math.round,
            isDisabled: this.$props.disabled,
            aria: {
              valueNow: this.#getARIAValueNow.bind(this),
              valueText: this.#getARIAValueText.bind(this)
            }
          });
        }
        onSetup() {
          effect(this.#watchValue.bind(this));
          effect(this.#watchMinMax.bind(this));
        }
        // -------------------------------------------------------------------------------------------
        // Props
        // -------------------------------------------------------------------------------------------
        #getARIAValueNow() {
          const { value } = this.$state;
          return Math.round(value());
        }
        #getARIAValueText() {
          const { value, max: max2 } = this.$state;
          return round2(value() / max2() * 100, 2) + "%";
        }
        // -------------------------------------------------------------------------------------------
        // Watch
        // -------------------------------------------------------------------------------------------
        #watchValue() {
          const { value } = this.$props;
          this.$state.value.set(value());
        }
        #watchMinMax() {
          const { min: min2, max: max2 } = this.$props;
          this.$state.min.set(min2());
          this.$state.max.set(max2());
        }
      };
      cache = /* @__PURE__ */ new Map();
      pending = /* @__PURE__ */ new Map();
      ThumbnailsLoader = class _ThumbnailsLoader {
        #media;
        #src;
        #crossOrigin;
        $images = signal([]);
        static create(src, crossOrigin) {
          const media = useMediaContext();
          return new _ThumbnailsLoader(src, crossOrigin, media);
        }
        constructor(src, crossOrigin, media) {
          this.#src = src;
          this.#crossOrigin = crossOrigin;
          this.#media = media;
          effect(this.#onLoadCues.bind(this));
        }
        #onLoadCues() {
          const { canLoad } = this.#media.$state;
          if (!canLoad())
            return;
          const src = this.#src();
          if (!src)
            return;
          if (isString(src) && cache.has(src)) {
            const cues = cache.get(src);
            cache.delete(src);
            cache.set(src, cues);
            if (cache.size > 99) {
              const firstKey = cache.keys().next().value;
              cache.delete(firstKey);
            }
            this.$images.set(cache.get(src));
          } else if (isString(src)) {
            const crossOrigin = this.#crossOrigin(), currentKey = src + "::" + crossOrigin;
            if (!pending.has(currentKey)) {
              const promise = new Promise(async (resolve, reject) => {
                try {
                  const response = await fetch(src, {
                    credentials: getRequestCredentials(crossOrigin)
                  }), isJSON = response.headers.get("content-type") === "application/json";
                  if (isJSON) {
                    const json = await response.json();
                    if (isArray(json)) {
                      if (json[0] && "text" in json[0]) {
                        resolve(this.#processVTTCues(json));
                      } else {
                        for (let i5 = 0; i5 < json.length; i5++) {
                          const image = json[i5];
                          assert(isObject3(image), false);
                          assert(
                            "url" in image && isString(image.url),
                            false
                          );
                          assert(
                            "startTime" in image && isNumber(image.startTime),
                            false
                          );
                        }
                        resolve(json);
                      }
                    } else {
                      resolve(this.#processStoryboard(json));
                    }
                    return;
                  }
                  Promise.resolve().then(() => (init_prod2(), prod_exports)).then(async ({ parseResponse: parseResponse2 }) => {
                    try {
                      const { cues } = await parseResponse2(response);
                      resolve(this.#processVTTCues(cues));
                    } catch (e8) {
                      reject(e8);
                    }
                  });
                } catch (e8) {
                  reject(e8);
                }
              }).then((images) => {
                cache.set(currentKey, images);
                return images;
              }).catch((error) => {
                this.#onError(src, error);
              }).finally(() => {
                if (isString(currentKey))
                  pending.delete(currentKey);
              });
              pending.set(currentKey, promise);
            }
            pending.get(currentKey)?.then((images) => {
              this.$images.set(images || []);
            });
          } else if (isArray(src)) {
            try {
              this.$images.set(this.#processImages(src));
            } catch (error) {
              this.#onError(src, error);
            }
          } else {
            try {
              this.$images.set(this.#processStoryboard(src));
            } catch (error) {
              this.#onError(src, error);
            }
          }
          return () => {
            this.$images.set([]);
          };
        }
        #processImages(images) {
          const baseURL = this.#resolveBaseUrl();
          return images.map((img, i5) => {
            assert(
              img.url && isString(img.url)
            );
            assert(
              "startTime" in img && isNumber(img.startTime)
            );
            return {
              ...img,
              url: isString(img.url) ? this.#resolveURL(img.url, baseURL) : img.url
            };
          });
        }
        #processStoryboard(board) {
          assert(isString(board.url));
          assert(isArray(board.tiles) && board.tiles?.length);
          const url = new URL(board.url), images = [];
          const tileWidth = "tile_width" in board ? board.tile_width : board.tileWidth, tileHeight = "tile_height" in board ? board.tile_height : board.tileHeight;
          for (const tile of board.tiles) {
            images.push({
              url,
              startTime: "start" in tile ? tile.start : tile.startTime,
              width: tileWidth,
              height: tileHeight,
              coords: { x: tile.x, y: tile.y }
            });
          }
          return images;
        }
        #processVTTCues(cues) {
          for (let i5 = 0; i5 < cues.length; i5++) {
            const cue = cues[i5];
            assert(
              "startTime" in cue && isNumber(cue.startTime)
            );
            assert(
              "text" in cue && isString(cue.text)
            );
          }
          const images = [], baseURL = this.#resolveBaseUrl();
          for (const cue of cues) {
            const [url, hash] = cue.text.split("#"), data = this.#resolveData(hash);
            images.push({
              url: this.#resolveURL(url, baseURL),
              startTime: cue.startTime,
              endTime: cue.endTime,
              width: data?.w,
              height: data?.h,
              coords: data && isNumber(data.x) && isNumber(data.y) ? { x: data.x, y: data.y } : void 0
            });
          }
          return images;
        }
        #resolveBaseUrl() {
          let baseURL = peek(this.#src);
          if (!isString(baseURL) || !/^https?:/.test(baseURL)) {
            return location.href;
          }
          return baseURL;
        }
        #resolveURL(src, baseURL) {
          return /^https?:/.test(src) ? new URL(src) : new URL(src, baseURL);
        }
        #resolveData(hash) {
          if (!hash)
            return {};
          const [hashProps, values] = hash.split("="), hashValues = values?.split(","), data = {};
          if (!hashProps || !hashValues) {
            return null;
          }
          for (let i5 = 0; i5 < hashProps.length; i5++) {
            const value = +hashValues[i5];
            if (!isNaN(value))
              data[hashProps[i5]] = value;
          }
          return data;
        }
        #onError(src, error) {
          return;
        }
      };
      Thumbnail = class extends Component {
        static props = {
          src: null,
          time: 0,
          crossOrigin: null
        };
        static state = new State({
          src: "",
          img: null,
          thumbnails: [],
          activeThumbnail: null,
          crossOrigin: null,
          loading: false,
          error: null,
          hidden: false
        });
        media;
        #loader;
        #styleResets = [];
        onSetup() {
          this.media = useMediaContext();
          this.#loader = ThumbnailsLoader.create(this.$props.src, this.$state.crossOrigin);
          this.#watchCrossOrigin();
          this.setAttributes({
            "data-loading": this.#isLoading.bind(this),
            "data-error": this.#hasError.bind(this),
            "data-hidden": this.$state.hidden,
            "aria-hidden": $ariaBool(this.$state.hidden)
          });
        }
        onConnect(el) {
          effect(this.#watchImg.bind(this));
          effect(this.#watchHidden.bind(this));
          effect(this.#watchCrossOrigin.bind(this));
          effect(this.#onLoadStart.bind(this));
          effect(this.#onFindActiveThumbnail.bind(this));
          effect(this.#resize.bind(this));
        }
        #watchImg() {
          const img = this.$state.img();
          if (!img)
            return;
          new EventsController(img).add("load", this.#onLoaded.bind(this)).add("error", this.#onError.bind(this));
        }
        #watchCrossOrigin() {
          const { crossOrigin: crossOriginProp } = this.$props, { crossOrigin: crossOriginState } = this.$state, { crossOrigin: mediaCrossOrigin } = this.media.$state, crossOrigin = crossOriginProp() !== null ? crossOriginProp() : mediaCrossOrigin();
          crossOriginState.set(crossOrigin === true ? "anonymous" : crossOrigin);
        }
        #onLoadStart() {
          const { src, loading, error } = this.$state;
          if (src()) {
            loading.set(true);
            error.set(null);
          }
          return () => {
            this.#resetStyles();
            loading.set(false);
            error.set(null);
          };
        }
        #onLoaded() {
          const { loading, error } = this.$state;
          this.#resize();
          loading.set(false);
          error.set(null);
        }
        #onError(event2) {
          const { loading, error } = this.$state;
          loading.set(false);
          error.set(event2);
        }
        #isLoading() {
          const { loading, hidden } = this.$state;
          return !hidden() && loading();
        }
        #hasError() {
          const { error } = this.$state;
          return !isNull(error());
        }
        #watchHidden() {
          const { hidden } = this.$state, { duration } = this.media.$state, images = this.#loader.$images();
          hidden.set(this.#hasError() || !Number.isFinite(duration()) || images.length === 0);
        }
        getTime() {
          return this.$props.time();
        }
        #onFindActiveThumbnail() {
          let images = this.#loader.$images();
          if (!images.length)
            return;
          let time = this.getTime(), { src, activeThumbnail } = this.$state, activeIndex = -1, activeImage = null;
          for (let i5 = images.length - 1; i5 >= 0; i5--) {
            const image = images[i5];
            if (time >= image.startTime && (!image.endTime || time < image.endTime)) {
              activeIndex = i5;
              break;
            }
          }
          if (images[activeIndex]) {
            activeImage = images[activeIndex];
          }
          activeThumbnail.set(activeImage);
          src.set(activeImage?.url.href || "");
        }
        #resize() {
          if (!this.scope || this.$state.hidden())
            return;
          const rootEl = this.el, imgEl = this.$state.img(), thumbnail = this.$state.activeThumbnail();
          if (!imgEl || !thumbnail || !rootEl)
            return;
          let width = thumbnail.width ?? imgEl.naturalWidth, height = thumbnail?.height ?? imgEl.naturalHeight, {
            maxWidth,
            maxHeight,
            minWidth,
            minHeight,
            width: elWidth,
            height: elHeight
          } = getComputedStyle(this.el);
          if (minWidth === "100%")
            minWidth = parseFloat(elWidth) + "";
          if (minHeight === "100%")
            minHeight = parseFloat(elHeight) + "";
          let minRatio = Math.max(parseInt(minWidth) / width, parseInt(minHeight) / height), maxRatio = Math.min(
            Math.max(parseInt(minWidth), parseInt(maxWidth)) / width,
            Math.max(parseInt(minHeight), parseInt(maxHeight)) / height
          ), scale = !isNaN(maxRatio) && maxRatio < 1 ? maxRatio : minRatio > 1 ? minRatio : 1;
          this.#style(rootEl, "--thumbnail-width", `${width * scale}px`);
          this.#style(rootEl, "--thumbnail-height", `${height * scale}px`);
          this.#style(imgEl, "width", `${imgEl.naturalWidth * scale}px`);
          this.#style(imgEl, "height", `${imgEl.naturalHeight * scale}px`);
          this.#style(
            imgEl,
            "transform",
            thumbnail.coords ? `translate(-${thumbnail.coords.x * scale}px, -${thumbnail.coords.y * scale}px)` : ""
          );
          this.#style(imgEl, "max-width", "none");
        }
        #style(el, name, value) {
          el.style.setProperty(name, value);
          this.#styleResets.push(() => el.style.removeProperty(name));
        }
        #resetStyles() {
          for (const reset of this.#styleResets)
            reset();
          this.#styleResets = [];
        }
      };
      SliderValue = class extends Component {
        static props = {
          type: "pointer",
          format: null,
          showHours: false,
          showMs: false,
          padHours: null,
          padMinutes: null,
          decimalPlaces: 2
        };
        #format;
        #text;
        #slider;
        onSetup() {
          this.#slider = useState(Slider.state);
          this.#format = useContext(sliderValueFormatContext);
          this.#text = computed(this.getValueText.bind(this));
        }
        /**
         * Returns the current value formatted as text based on prop settings.
         */
        getValueText() {
          const {
            type,
            format: $format,
            decimalPlaces,
            padHours,
            padMinutes,
            showHours,
            showMs
          } = this.$props, { value: sliderValue, pointerValue, min: min2, max: max2 } = this.#slider, format = $format?.() ?? this.#format.default;
          const value = type() === "current" ? sliderValue() : pointerValue();
          if (format === "percent") {
            const range = max2() - min2();
            const percent = value / range * 100;
            return (this.#format.percent ?? round2)(percent, decimalPlaces()) + "%";
          } else if (format === "time") {
            return (this.#format.time ?? formatTime)(value, {
              padHrs: padHours(),
              padMins: padMinutes(),
              showHrs: showHours(),
              showMs: showMs()
            });
          } else {
            return (this.#format.value?.(value) ?? value.toFixed(2)) + "";
          }
        }
      };
      slidervalue__proto = SliderValue.prototype;
      method(slidervalue__proto, "getValueText");
      SliderPreview = class extends Component {
        static props = {
          offset: 0,
          noClamp: false
        };
        #slider;
        onSetup() {
          this.#slider = useContext(sliderContext);
          const { active } = useState(Slider.state);
          this.setAttributes({
            "data-visible": active
          });
        }
        onAttach(el) {
          Object.assign(el.style, {
            position: "absolute",
            top: 0,
            left: 0,
            width: "max-content"
          });
        }
        onConnect(el) {
          const { preview } = this.#slider;
          preview.set(el);
          onDispose(() => preview.set(null));
          effect(this.#updatePlacement.bind(this));
          const resize = new ResizeObserver(this.#updatePlacement.bind(this));
          resize.observe(el);
          onDispose(() => resize.disconnect());
        }
        #updatePlacement = animationFrameThrottle(() => {
          const { disabled, orientation } = this.#slider;
          if (disabled())
            return;
          const el = this.el, { offset: offset2, noClamp } = this.$props;
          if (!el)
            return;
          updateSliderPreviewPlacement(el, {
            clamp: !noClamp(),
            offset: offset2(),
            orientation: orientation()
          });
        });
      };
      VolumeSlider = class extends Component {
        static props = {
          ...SliderController.props,
          keyStep: 5,
          shiftKeyMultiplier: 2
        };
        static state = sliderState;
        #media;
        onSetup() {
          this.#media = useMediaContext();
          const { audioGain } = this.#media.$state;
          provideContext(sliderValueFormatContext, {
            default: "percent",
            value(value) {
              return (value * (audioGain() ?? 1)).toFixed(2);
            },
            percent(value) {
              return Math.round(value * (audioGain() ?? 1));
            }
          });
          new SliderController({
            getStep: this.$props.step,
            getKeyStep: this.$props.keyStep,
            roundValue: Math.round,
            isDisabled: this.#isDisabled.bind(this),
            aria: {
              valueMax: this.#getARIAValueMax.bind(this),
              valueNow: this.#getARIAValueNow.bind(this),
              valueText: this.#getARIAValueText.bind(this)
            },
            onDragValueChange: this.#onDragValueChange.bind(this),
            onValueChange: this.#onValueChange.bind(this)
          }).attach(this);
          effect(this.#watchVolume.bind(this));
        }
        onAttach(el) {
          el.setAttribute("data-media-volume-slider", "");
          setAttributeIfEmpty(el, "aria-label", "Volume");
          const { canSetVolume } = this.#media.$state;
          this.setAttributes({
            "data-supported": canSetVolume,
            "aria-hidden": $ariaBool(() => !canSetVolume())
          });
        }
        #getARIAValueNow() {
          const { value } = this.$state, { audioGain } = this.#media.$state;
          return Math.round(value() * (audioGain() ?? 1));
        }
        #getARIAValueText() {
          const { value, max: max2 } = this.$state, { audioGain } = this.#media.$state;
          return round2(value() / max2() * (audioGain() ?? 1) * 100, 2) + "%";
        }
        #getARIAValueMax() {
          const { audioGain } = this.#media.$state;
          return this.$state.max() * (audioGain() ?? 1);
        }
        #isDisabled() {
          const { disabled } = this.$props, { canSetVolume } = this.#media.$state;
          return disabled() || !canSetVolume();
        }
        #watchVolume() {
          const { muted, volume } = this.#media.$state;
          const newValue = muted() ? 0 : volume() * 100;
          this.$state.value.set(newValue);
          this.dispatch("value-change", { detail: newValue });
        }
        #throttleVolumeChange = functionThrottle(this.#onVolumeChange.bind(this), 25);
        #onVolumeChange(event2) {
          if (!event2.trigger)
            return;
          const mediaVolume = round2(event2.detail / 100, 3);
          this.#media.remote.changeVolume(mediaVolume, event2);
        }
        #onValueChange(event2) {
          this.#throttleVolumeChange(event2);
        }
        #onDragValueChange(event2) {
          this.#throttleVolumeChange(event2);
        }
      };
      TimeSlider = class extends Component {
        static props = {
          ...SliderController.props,
          step: 0.1,
          keyStep: 5,
          shiftKeyMultiplier: 2,
          pauseWhileDragging: false,
          noSwipeGesture: false,
          seekingRequestThrottle: 100
        };
        static state = sliderState;
        #media;
        #dispatchSeeking;
        #chapter = signal(null);
        constructor() {
          super();
          const { noSwipeGesture } = this.$props;
          new SliderController({
            swipeGesture: () => !noSwipeGesture(),
            getValue: this.#getValue.bind(this),
            getStep: this.#getStep.bind(this),
            getKeyStep: this.#getKeyStep.bind(this),
            roundValue: this.#roundValue,
            isDisabled: this.#isDisabled.bind(this),
            aria: {
              valueNow: this.#getARIAValueNow.bind(this),
              valueText: this.#getARIAValueText.bind(this)
            },
            onDragStart: this.#onDragStart.bind(this),
            onDragValueChange: this.#onDragValueChange.bind(this),
            onDragEnd: this.#onDragEnd.bind(this),
            onValueChange: this.#onValueChange.bind(this)
          });
        }
        onSetup() {
          this.#media = useMediaContext();
          provideContext(sliderValueFormatContext, {
            default: "time",
            value: this.#formatValue.bind(this),
            time: this.#formatTime.bind(this)
          });
          this.setAttributes({
            "data-chapters": this.#hasChapters.bind(this)
          });
          this.setStyles({
            "--slider-progress": this.#calcBufferedPercent.bind(this)
          });
          effect(this.#watchCurrentTime.bind(this));
          effect(this.#watchSeekingThrottle.bind(this));
        }
        onAttach(el) {
          el.setAttribute("data-media-time-slider", "");
          setAttributeIfEmpty(el, "aria-label", "Seek");
        }
        onConnect(el) {
          effect(this.#watchPreviewing.bind(this));
          watchActiveTextTrack(this.#media.textTracks, "chapters", this.#chapter.set);
        }
        #calcBufferedPercent() {
          const { bufferedEnd, duration } = this.#media.$state;
          return round2(Math.min(bufferedEnd() / Math.max(duration(), 1), 1) * 100, 3) + "%";
        }
        #hasChapters() {
          const { duration } = this.#media.$state;
          return this.#chapter()?.cues.length && Number.isFinite(duration()) && duration() > 0;
        }
        #watchSeekingThrottle() {
          this.#dispatchSeeking = functionThrottle(
            this.#seeking.bind(this),
            this.$props.seekingRequestThrottle()
          );
        }
        #watchCurrentTime() {
          if (this.$state.hidden())
            return;
          const { value, dragging } = this.$state, newValue = this.#getValue();
          if (!peek(dragging)) {
            value.set(newValue);
            this.dispatch("value-change", { detail: newValue });
          }
        }
        #watchPreviewing() {
          const player = this.#media.player.el, { preview } = useContext(sliderContext);
          player && preview() && setAttribute(player, "data-preview", this.$state.active());
        }
        #seeking(time, event2) {
          this.#media.remote.seeking(time, event2);
        }
        #seek(time, percent, event2) {
          this.#dispatchSeeking.cancel();
          const { live } = this.#media.$state;
          if (live() && percent >= 99) {
            this.#media.remote.seekToLiveEdge(event2);
            return;
          }
          this.#media.remote.seek(time, event2);
        }
        #playingBeforeDragStart = false;
        #onDragStart(event2) {
          const { pauseWhileDragging } = this.$props;
          if (pauseWhileDragging()) {
            const { paused } = this.#media.$state;
            this.#playingBeforeDragStart = !paused();
            this.#media.remote.pause(event2);
          }
        }
        #onDragValueChange(event2) {
          this.#dispatchSeeking(this.#percentToTime(event2.detail), event2);
        }
        #onDragEnd(event2) {
          const { seeking } = this.#media.$state;
          if (!peek(seeking))
            this.#seeking(this.#percentToTime(event2.detail), event2);
          const percent = event2.detail;
          this.#seek(this.#percentToTime(percent), percent, event2);
          const { pauseWhileDragging } = this.$props;
          if (pauseWhileDragging() && this.#playingBeforeDragStart) {
            this.#media.remote.play(event2);
            this.#playingBeforeDragStart = false;
          }
        }
        #onValueChange(event2) {
          const { dragging } = this.$state;
          if (dragging() || !event2.trigger)
            return;
          this.#onDragEnd(event2);
        }
        // -------------------------------------------------------------------------------------------
        // Props
        // -------------------------------------------------------------------------------------------
        #getValue() {
          const { currentTime } = this.#media.$state;
          return this.#timeToPercent(currentTime());
        }
        #getStep() {
          const value = this.$props.step() / this.#media.$state.duration() * 100;
          return Number.isFinite(value) ? value : 1;
        }
        #getKeyStep() {
          const value = this.$props.keyStep() / this.#media.$state.duration() * 100;
          return Number.isFinite(value) ? value : 1;
        }
        #roundValue(value) {
          return round2(value, 3);
        }
        #isDisabled() {
          const { disabled } = this.$props, { canSeek } = this.#media.$state;
          return disabled() || !canSeek();
        }
        // -------------------------------------------------------------------------------------------
        // ARIA
        // -------------------------------------------------------------------------------------------
        #getARIAValueNow() {
          const { value } = this.$state;
          return Math.round(value());
        }
        #getARIAValueText() {
          const time = this.#percentToTime(this.$state.value()), { duration } = this.#media.$state;
          return Number.isFinite(time) ? `${formatSpokenTime(time)} out of ${formatSpokenTime(duration())}` : "live";
        }
        // -------------------------------------------------------------------------------------------
        // Format
        // -------------------------------------------------------------------------------------------
        #percentToTime(percent) {
          const { duration } = this.#media.$state;
          return round2(percent / 100 * duration(), 5);
        }
        #timeToPercent(time) {
          const { liveEdge, duration } = this.#media.$state, rate = Math.max(0, Math.min(1, liveEdge() ? 1 : Math.min(time, duration()) / duration()));
          return Number.isNaN(rate) ? 0 : Number.isFinite(rate) ? rate * 100 : 100;
        }
        #formatValue(percent) {
          const time = this.#percentToTime(percent), { live, duration } = this.#media.$state;
          return Number.isFinite(time) ? (live() ? time - duration() : time).toFixed(0) : "LIVE";
        }
        #formatTime(percent, options) {
          const time = this.#percentToTime(percent), { live, duration } = this.#media.$state, value = live() ? time - duration() : time;
          return Number.isFinite(time) ? `${value < 0 ? "-" : ""}${formatTime(Math.abs(value), options)}` : "LIVE";
        }
      };
      menuContext = createContext();
      FOCUSABLE_ELEMENTS_SELECTOR = /* @__PURE__ */ [
        "a[href]",
        "[tabindex]",
        "input",
        "select",
        "button"
      ].map((selector3) => `${selector3}:not([aria-hidden='true'])`).join(",");
      VALID_KEYS = /* @__PURE__ */ new Set([
        "Escape",
        "Tab",
        "ArrowUp",
        "ArrowDown",
        "Home",
        "PageUp",
        "End",
        "PageDown",
        "Enter",
        " "
      ]);
      MenuFocusController = class {
        #index = -1;
        #el = null;
        #elements = [];
        #delegate;
        get items() {
          return this.#elements;
        }
        constructor(delegate) {
          this.#delegate = delegate;
        }
        attachMenu(el) {
          listenEvent(el, "focus", this.#onFocus.bind(this));
          this.#el = el;
          onDispose(() => {
            this.#el = null;
          });
        }
        listen() {
          if (!this.#el)
            return;
          this.update();
          new EventsController(this.#el).add("keyup", this.#onKeyUp.bind(this)).add("keydown", this.#onKeyDown.bind(this));
          onDispose(() => {
            this.#index = -1;
            this.#elements = [];
          });
        }
        update() {
          this.#index = 0;
          this.#elements = this.#getFocusableElements();
        }
        scroll(index = this.#findActiveIndex()) {
          const element = this.#elements[index];
          if (element) {
            requestAnimationFrame(() => {
              requestAnimationFrame(() => {
                scrollIntoCenter(element, {
                  behavior: "smooth",
                  boundary: (el) => {
                    return !el.hasAttribute("data-root");
                  }
                });
              });
            });
          }
        }
        focusActive(scroll = true) {
          const index = this.#findActiveIndex();
          this.#focusAt(index >= 0 ? index : 0, scroll);
        }
        #focusAt(index, scroll = true) {
          this.#index = index;
          if (this.#elements[index]) {
            this.#elements[index].focus({ preventScroll: true });
            if (scroll)
              this.scroll(index);
          } else {
            this.#el?.focus({ preventScroll: true });
          }
        }
        #findActiveIndex() {
          return this.#elements.findIndex(
            (el) => document.activeElement === el || el.getAttribute("role") === "menuitemradio" && el.getAttribute("aria-checked") === "true"
          );
        }
        #onFocus() {
          if (this.#index >= 0)
            return;
          this.update();
          this.focusActive();
        }
        #validateKeyEvent(event2) {
          const el = event2.target;
          if (wasEnterKeyPressed(event2) && el instanceof Element) {
            const role = el.getAttribute("role");
            return !/a|input|select|button/.test(el.localName) && !role;
          }
          return VALID_KEYS.has(event2.key);
        }
        #onKeyUp(event2) {
          if (!this.#validateKeyEvent(event2))
            return;
          event2.stopPropagation();
          event2.preventDefault();
        }
        #onKeyDown(event2) {
          if (!this.#validateKeyEvent(event2))
            return;
          event2.stopPropagation();
          event2.preventDefault();
          switch (event2.key) {
            case "Escape":
              this.#delegate.closeMenu(event2);
              break;
            case "Tab":
              this.#focusAt(this.#nextIndex(event2.shiftKey ? -1 : 1));
              break;
            case "ArrowUp":
              this.#focusAt(this.#nextIndex(-1));
              break;
            case "ArrowDown":
              this.#focusAt(this.#nextIndex(1));
              break;
            case "Home":
            case "PageUp":
              this.#focusAt(0);
              break;
            case "End":
            case "PageDown":
              this.#focusAt(this.#elements.length - 1);
              break;
          }
        }
        #nextIndex(delta) {
          let index = this.#index;
          do {
            index = (index + delta + this.#elements.length) % this.#elements.length;
          } while (this.#elements[index]?.offsetParent === null);
          return index;
        }
        #getFocusableElements() {
          if (!this.#el)
            return [];
          const focusableElements = this.#el.querySelectorAll(FOCUSABLE_ELEMENTS_SELECTOR), elements = [];
          const is = (node) => {
            return node.getAttribute("role") === "menu";
          };
          for (const el of focusableElements) {
            if (isHTMLElement2(el) && el.offsetParent !== null && // does not have display: none
            isElementParent(this.#el, el, is)) {
              elements.push(el);
            }
          }
          return elements;
        }
      };
      __defProp2 = Object.defineProperty;
      __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
      __decorateClass = (decorators, target, key2, kind) => {
        var result = __getOwnPropDesc2(target, key2);
        for (var i5 = decorators.length - 1, decorator; i5 >= 0; i5--)
          if (decorator = decorators[i5])
            result = decorator(target, key2, result) || result;
        if (result)
          __defProp2(target, key2, result);
        return result;
      };
      idCount = 0;
      Menu = class extends Component {
        static props = {
          showDelay: 0
        };
        #media;
        #menuId;
        #menuButtonId;
        #expanded = signal(false);
        #disabled = signal(false);
        #trigger = signal(null);
        #content = signal(null);
        #parentMenu;
        #submenus = /* @__PURE__ */ new Set();
        #menuObserver = null;
        #popper;
        #focus;
        #isSliderActive = false;
        #isTriggerDisabled = signal(false);
        #transitionCallbacks = /* @__PURE__ */ new Set();
        get triggerElement() {
          return this.#trigger();
        }
        get contentElement() {
          return this.#content();
        }
        get isSubmenu() {
          return !!this.#parentMenu;
        }
        constructor() {
          super();
          const { showDelay } = this.$props;
          this.#popper = new Popper({
            trigger: this.#trigger,
            content: this.#content,
            showDelay,
            listen: (trigger, show, hide2) => {
              onPress(trigger, (event2) => {
                if (this.#expanded())
                  hide2(event2);
                else
                  show(event2);
              });
              const closeTarget = this.#getCloseTarget();
              if (closeTarget) {
                onPress(closeTarget, (event2) => {
                  event2.stopPropagation();
                  hide2(event2);
                });
              }
            },
            onChange: this.#onExpandedChange.bind(this)
          });
        }
        onSetup() {
          this.#media = useMediaContext();
          const currentIdCount = ++idCount;
          this.#menuId = `media-menu-${currentIdCount}`;
          this.#menuButtonId = `media-menu-button-${currentIdCount}`;
          this.#focus = new MenuFocusController({
            closeMenu: this.close.bind(this)
          });
          if (hasProvidedContext(menuContext)) {
            this.#parentMenu = useContext(menuContext);
          }
          this.#observeSliders();
          this.setAttributes({
            "data-open": this.#expanded,
            "data-root": !this.isSubmenu,
            "data-submenu": this.isSubmenu,
            "data-disabled": this.#isDisabled.bind(this)
          });
          provideContext(menuContext, {
            button: this.#trigger,
            content: this.#content,
            expanded: this.#expanded,
            hint: signal(""),
            submenu: !!this.#parentMenu,
            disable: this.#disable.bind(this),
            attachMenuButton: this.#attachMenuButton.bind(this),
            attachMenuItems: this.#attachMenuItems.bind(this),
            attachObserver: this.#attachObserver.bind(this),
            disableMenuButton: this.#disableMenuButton.bind(this),
            addSubmenu: this.#addSubmenu.bind(this),
            onTransitionEvent: (callback) => {
              this.#transitionCallbacks.add(callback);
              onDispose(() => {
                this.#transitionCallbacks.delete(callback);
              });
            }
          });
        }
        onAttach(el) {
          el.style.setProperty("display", "contents");
        }
        onConnect(el) {
          effect(this.#watchExpanded.bind(this));
          if (this.isSubmenu) {
            this.#parentMenu?.addSubmenu(this);
          }
        }
        onDestroy() {
          this.#trigger.set(null);
          this.#content.set(null);
          this.#menuObserver = null;
          this.#transitionCallbacks.clear();
        }
        #observeSliders() {
          let sliderActiveTimer = -1, parentSliderObserver = hasProvidedContext(sliderObserverContext) ? useContext(sliderObserverContext) : null;
          provideContext(sliderObserverContext, {
            onDragStart: () => {
              parentSliderObserver?.onDragStart?.();
              window.clearTimeout(sliderActiveTimer);
              sliderActiveTimer = -1;
              this.#isSliderActive = true;
            },
            onDragEnd: () => {
              parentSliderObserver?.onDragEnd?.();
              sliderActiveTimer = window.setTimeout(() => {
                this.#isSliderActive = false;
                sliderActiveTimer = -1;
              }, 300);
            }
          });
        }
        #watchExpanded() {
          const expanded = this.#isExpanded();
          if (!this.isSubmenu)
            this.#onResize();
          this.#updateMenuItemsHidden(expanded);
          if (!expanded)
            return;
          effect(() => {
            const { height } = this.#media.$state, content = this.#content();
            content && setStyle(content, "--player-height", height() + "px");
          });
          this.#focus.listen();
          this.listen("pointerup", this.#onPointerUp.bind(this));
          listenEvent(window, "pointerup", this.#onWindowPointerUp.bind(this));
        }
        #attachMenuButton(button) {
          const el = button.el, isMenuItem = this.isSubmenu, isARIADisabled = $ariaBool(this.#isDisabled.bind(this));
          setAttributeIfEmpty(el, "tabindex", isMenuItem ? "-1" : "0");
          setAttributeIfEmpty(el, "role", isMenuItem ? "menuitem" : "button");
          setAttribute(el, "id", this.#menuButtonId);
          setAttribute(el, "aria-haspopup", "menu");
          setAttribute(el, "aria-expanded", "false");
          setAttribute(el, "data-root", !this.isSubmenu);
          setAttribute(el, "data-submenu", this.isSubmenu);
          const watchAttrs = () => {
            setAttribute(el, "data-open", this.#expanded());
            setAttribute(el, "aria-disabled", isARIADisabled());
          };
          effect(watchAttrs);
          this.#trigger.set(el);
          onDispose(() => {
            this.#trigger.set(null);
          });
        }
        #attachMenuItems(items) {
          const el = items.el;
          el.style.setProperty("display", "none");
          setAttribute(el, "id", this.#menuId);
          setAttributeIfEmpty(el, "role", "menu");
          setAttributeIfEmpty(el, "tabindex", "-1");
          setAttribute(el, "data-root", !this.isSubmenu);
          setAttribute(el, "data-submenu", this.isSubmenu);
          this.#content.set(el);
          onDispose(() => this.#content.set(null));
          const watchAttrs = () => setAttribute(el, "data-open", this.#expanded());
          effect(watchAttrs);
          this.#focus.attachMenu(el);
          this.#updateMenuItemsHidden(false);
          const onTransition = this.#onResizeTransition.bind(this);
          if (!this.isSubmenu) {
            items.listen("transitionstart", onTransition);
            items.listen("transitionend", onTransition);
            items.listen("animationend", this.#onResize);
            items.listen("vds-menu-resize", this.#onResize);
          } else {
            this.#parentMenu?.onTransitionEvent(onTransition);
          }
        }
        #attachObserver(observer) {
          this.#menuObserver = observer;
        }
        #updateMenuItemsHidden(expanded) {
          const content = peek(this.#content);
          if (content)
            setAttribute(content, "aria-hidden", ariaBool(!expanded));
        }
        #disableMenuButton(disabled) {
          this.#isTriggerDisabled.set(disabled);
        }
        #wasKeyboardExpand = false;
        #onExpandedChange(isExpanded, event2) {
          this.#wasKeyboardExpand = isKeyboardEvent(event2);
          event2?.stopPropagation();
          if (this.#expanded() === isExpanded)
            return;
          if (this.#isDisabled()) {
            if (isExpanded)
              this.#popper.hide(event2);
            return;
          }
          this.el?.dispatchEvent(
            new Event("vds-menu-resize", {
              bubbles: true,
              composed: true
            })
          );
          const trigger = this.#trigger(), content = this.#content();
          if (trigger) {
            setAttribute(trigger, "aria-controls", isExpanded && this.#menuId);
            setAttribute(trigger, "aria-expanded", ariaBool(isExpanded));
          }
          if (content)
            setAttribute(content, "aria-labelledby", isExpanded && this.#menuButtonId);
          this.#expanded.set(isExpanded);
          this.#toggleMediaControls(event2);
          tick();
          if (this.#wasKeyboardExpand) {
            if (isExpanded)
              content?.focus();
            else
              trigger?.focus();
            for (const el of [this.el, content]) {
              el && el.setAttribute("data-keyboard", "");
            }
          } else {
            for (const el of [this.el, content]) {
              el && el.removeAttribute("data-keyboard");
            }
          }
          this.dispatch(isExpanded ? "open" : "close", { trigger: event2 });
          if (isExpanded) {
            if (!this.isSubmenu && this.#media.activeMenu !== this) {
              this.#media.activeMenu?.close(event2);
              this.#media.activeMenu = this;
            }
            this.#menuObserver?.onOpen?.(event2);
          } else {
            if (this.isSubmenu) {
              for (const el of this.#submenus)
                el.close(event2);
            } else {
              this.#media.activeMenu = null;
            }
            this.#menuObserver?.onClose?.(event2);
          }
          if (isExpanded) {
            requestAnimationFrame(this.#updateFocus.bind(this));
          }
        }
        #updateFocus() {
          if (this.#isTransitionActive || this.#isSubmenuOpen)
            return;
          this.#focus.update();
          requestAnimationFrame(() => {
            if (this.#wasKeyboardExpand) {
              this.#focus.focusActive();
            } else {
              this.#focus.scroll();
            }
          });
        }
        #isExpanded() {
          return !this.#isDisabled() && this.#expanded();
        }
        #isDisabled() {
          return this.#disabled() || this.#isTriggerDisabled();
        }
        #disable(disabled) {
          this.#disabled.set(disabled);
        }
        #onPointerUp(event2) {
          const content = this.#content();
          if (this.#isSliderActive || content && isEventInside(content, event2)) {
            return;
          }
          event2.stopPropagation();
        }
        #onWindowPointerUp(event2) {
          const content = this.#content();
          if (this.#isSliderActive || content && isEventInside(content, event2)) {
            return;
          }
          this.close(event2);
        }
        #getCloseTarget() {
          const target = this.el?.querySelector('[data-part="close-target"]');
          return this.el && target && isElementParent(this.el, target, (node) => node.getAttribute("role") === "menu") ? target : null;
        }
        #toggleMediaControls(trigger) {
          if (this.isSubmenu)
            return;
          if (this.#expanded())
            this.#media.remote.pauseControls(trigger);
          else
            this.#media.remote.resumeControls(trigger);
        }
        #addSubmenu(menu) {
          this.#submenus.add(menu);
          new EventsController(menu).add("open", this.#onSubmenuOpenBind).add("close", this.#onSubmenuCloseBind);
          onDispose(this.#removeSubmenuBind);
        }
        #removeSubmenuBind = this.#removeSubmenu.bind(this);
        #removeSubmenu(menu) {
          this.#submenus.delete(menu);
        }
        #isSubmenuOpen = false;
        #onSubmenuOpenBind = this.#onSubmenuOpen.bind(this);
        #onSubmenuOpen(event2) {
          this.#isSubmenuOpen = true;
          const content = this.#content();
          if (this.isSubmenu) {
            this.triggerElement?.setAttribute("aria-hidden", "true");
          }
          for (const target of this.#submenus) {
            if (target !== event2.target) {
              for (const el of [target.el, target.triggerElement]) {
                el?.setAttribute("aria-hidden", "true");
              }
            }
          }
          if (content) {
            const el = event2.target.el;
            for (const child of content.children) {
              if (child.contains(el)) {
                child.setAttribute("data-open", "");
              } else if (child !== el) {
                child.setAttribute("data-hidden", "");
              }
            }
          }
        }
        #onSubmenuCloseBind = this.#onSubmenuClose.bind(this);
        #onSubmenuClose(event2) {
          this.#isSubmenuOpen = false;
          const content = this.#content();
          if (this.isSubmenu) {
            this.triggerElement?.setAttribute("aria-hidden", "false");
          }
          for (const target of this.#submenus) {
            for (const el of [target.el, target.triggerElement]) {
              el?.setAttribute("aria-hidden", "false");
            }
          }
          if (content) {
            for (const child of content.children) {
              child.removeAttribute("data-open");
              child.removeAttribute("data-hidden");
            }
          }
        }
        #onResize = animationFrameThrottle(() => {
          const content = peek(this.#content);
          if (!content || false)
            return;
          let height = 0, styles = getComputedStyle(content), children = [...content.children];
          for (const prop2 of ["paddingTop", "paddingBottom", "borderTopWidth", "borderBottomWidth"]) {
            height += parseFloat(styles[prop2]) || 0;
          }
          for (const child of children) {
            if (isHTMLElement2(child) && child.style.display === "contents") {
              children.push(...child.children);
            } else if (child.nodeType === 3) {
              height += parseFloat(getComputedStyle(child).fontSize);
            } else if (isHTMLElement2(child)) {
              if (!isElementVisible(child))
                continue;
              const style = getComputedStyle(child);
              height += child.offsetHeight + (parseFloat(style.marginTop) || 0) + (parseFloat(style.marginBottom) || 0);
            }
          }
          setStyle(content, "--menu-height", height + "px");
        });
        #isTransitionActive = false;
        #onResizeTransition(event2) {
          const content = this.#content();
          if (content && event2.propertyName === "height") {
            this.#isTransitionActive = event2.type === "transitionstart";
            setAttribute(content, "data-transition", this.#isTransitionActive ? "height" : null);
            if (this.#expanded())
              this.#updateFocus();
          }
          for (const callback of this.#transitionCallbacks)
            callback(event2);
        }
        open(trigger) {
          if (peek(this.#expanded))
            return;
          this.#popper.show(trigger);
          tick();
        }
        close(trigger) {
          if (!peek(this.#expanded))
            return;
          this.#popper.hide(trigger);
          tick();
        }
      };
      __decorateClass([
        prop
      ], Menu.prototype, "triggerElement");
      __decorateClass([
        prop
      ], Menu.prototype, "contentElement");
      __decorateClass([
        prop
      ], Menu.prototype, "isSubmenu");
      __decorateClass([
        method
      ], Menu.prototype, "open");
      __decorateClass([
        method
      ], Menu.prototype, "close");
      MenuButton = class extends Component {
        static props = {
          disabled: false
        };
        #menu;
        #hintEl = signal(null);
        get expanded() {
          return this.#menu?.expanded() ?? false;
        }
        constructor() {
          super();
          new FocusVisibleController();
        }
        onSetup() {
          this.#menu = useContext(menuContext);
        }
        onAttach(el) {
          this.#menu.attachMenuButton(this);
          effect(this.#watchDisabled.bind(this));
          setAttributeIfEmpty(el, "type", "button");
        }
        onConnect(el) {
          effect(this.#watchHintEl.bind(this));
          this.#onMutation();
          const mutations = new MutationObserver(this.#onMutation.bind(this));
          mutations.observe(el, { attributeFilter: ["data-part"], childList: true, subtree: true });
          onDispose(() => mutations.disconnect());
          onPress(el, (trigger) => {
            this.dispatch("select", { trigger });
          });
        }
        #watchDisabled() {
          this.#menu.disableMenuButton(this.$props.disabled());
        }
        #watchHintEl() {
          const el = this.#hintEl();
          if (!el)
            return;
          effect(() => {
            const text = this.#menu.hint();
            if (text)
              el.textContent = text;
          });
        }
        #onMutation() {
          const hintEl = this.el?.querySelector('[data-part="hint"]');
          this.#hintEl.set(hintEl ?? null);
        }
      };
      menubutton__proto = MenuButton.prototype;
      prop(menubutton__proto, "expanded");
      MenuItem = class extends MenuButton {
      };
      menuPortalContext = createContext();
      MenuItems = class extends Component {
        static props = {
          placement: null,
          offset: 0,
          alignOffset: 0
        };
        #menu;
        constructor() {
          super();
          new FocusVisibleController();
          const { placement } = this.$props;
          this.setAttributes({
            "data-placement": placement
          });
        }
        onAttach(el) {
          this.#menu = useContext(menuContext);
          this.#menu.attachMenuItems(this);
          if (hasProvidedContext(menuPortalContext)) {
            const portal = useContext(menuPortalContext);
            if (portal) {
              provideContext(menuPortalContext, null);
              portal.attach(el);
              onDispose(() => portal.attach(null));
            }
          }
        }
        onConnect(el) {
          effect(this.#watchPlacement.bind(this));
        }
        #watchPlacement() {
          const { expanded } = this.#menu;
          if (!this.el || !expanded())
            return;
          const placement = this.$props.placement();
          if (!placement)
            return;
          Object.assign(this.el.style, {
            position: "absolute",
            top: 0,
            left: 0,
            width: "max-content"
          });
          const { offset: mainOffset, alignOffset } = this.$props;
          onDispose(
            autoPlacement2(this.el, this.#getButton(), placement, {
              offsetVarName: "media-menu",
              xOffset: alignOffset(),
              yOffset: mainOffset()
            })
          );
          onDispose(this.#hide.bind(this));
        }
        #hide() {
          if (!this.el)
            return;
          this.el.removeAttribute("style");
          this.el.style.display = "none";
        }
        #getButton() {
          return this.#menu.button();
        }
      };
      radioControllerContext = createContext();
      RadioGroupController = class extends ViewController {
        #group = /* @__PURE__ */ new Set();
        #value = signal("");
        #controller = null;
        onValueChange;
        get values() {
          return Array.from(this.#group).map((radio) => radio.value());
        }
        get value() {
          return this.#value();
        }
        set value(value) {
          this.#onChange(value);
        }
        onSetup() {
          provideContext(radioControllerContext, {
            add: this.#addRadio.bind(this),
            remove: this.#removeRadio.bind(this)
          });
        }
        onAttach(el) {
          const isMenuItem = hasProvidedContext(menuContext);
          if (!isMenuItem)
            setAttributeIfEmpty(el, "role", "radiogroup");
          this.setAttributes({ value: this.#value });
        }
        onDestroy() {
          this.#group.clear();
        }
        #addRadio(radio) {
          if (this.#group.has(radio))
            return;
          this.#group.add(radio);
          radio.onCheck = this.#onChangeBind;
          radio.check(radio.value() === this.#value());
        }
        #removeRadio(radio) {
          radio.onCheck = null;
          this.#group.delete(radio);
        }
        #onChangeBind = this.#onChange.bind(this);
        #onChange(newValue, trigger) {
          const currentValue = peek(this.#value);
          if (!newValue || newValue === currentValue)
            return;
          const currentRadio = this.#findRadio(currentValue), newRadio = this.#findRadio(newValue);
          currentRadio?.check(false, trigger);
          newRadio?.check(true, trigger);
          this.#value.set(newValue);
          this.onValueChange?.(newValue, trigger);
        }
        #findRadio(newValue) {
          for (const radio of this.#group) {
            if (newValue === peek(radio.value))
              return radio;
          }
          return null;
        }
      };
      AudioRadioGroup = class extends Component {
        static props = {
          emptyLabel: "Default"
        };
        #menu;
        #media;
        #controller;
        get value() {
          return this.#controller.value;
        }
        get disabled() {
          const { audioTracks } = this.#media.$state;
          return audioTracks().length <= 1;
        }
        constructor() {
          super();
          this.#controller = new RadioGroupController();
          this.#controller.onValueChange = this.#onValueChange.bind(this);
        }
        onSetup() {
          this.#media = useMediaContext();
          if (hasProvidedContext(menuContext)) {
            this.#menu = useContext(menuContext);
          }
        }
        onConnect(el) {
          effect(this.#watchValue.bind(this));
          effect(this.#watchControllerDisabled.bind(this));
          effect(this.#watchHintText.bind(this));
        }
        getOptions() {
          const { audioTracks } = this.#media.$state;
          return audioTracks().map((track) => ({
            track,
            label: track.label,
            value: track.label.toLowerCase()
          }));
        }
        #watchValue() {
          this.#controller.value = this.#getValue();
        }
        #watchHintText() {
          const { emptyLabel } = this.$props, { audioTrack } = this.#media.$state, track = audioTrack();
          this.#menu?.hint.set(track?.label ?? emptyLabel());
        }
        #watchControllerDisabled() {
          this.#menu?.disable(this.disabled);
        }
        #getValue() {
          const { audioTrack } = this.#media.$state;
          const track = audioTrack();
          return track ? track.label.toLowerCase() : "";
        }
        #onValueChange(value, trigger) {
          if (this.disabled)
            return;
          const index = this.#media.audioTracks.toArray().findIndex((track) => track.label.toLowerCase() === value);
          if (index >= 0) {
            const track = this.#media.audioTracks[index];
            this.#media.remote.changeAudioTrack(index, trigger);
            this.dispatch("change", { detail: track, trigger });
          }
        }
      };
      audioradiogroup__proto = AudioRadioGroup.prototype;
      prop(audioradiogroup__proto, "value");
      prop(audioradiogroup__proto, "disabled");
      method(audioradiogroup__proto, "getOptions");
      CaptionsRadioGroup = class extends Component {
        static props = {
          offLabel: "Off"
        };
        #media;
        #menu;
        #controller;
        get value() {
          return this.#controller.value;
        }
        get disabled() {
          const { hasCaptions } = this.#media.$state;
          return !hasCaptions();
        }
        constructor() {
          super();
          this.#controller = new RadioGroupController();
          this.#controller.onValueChange = this.#onValueChange.bind(this);
        }
        onSetup() {
          this.#media = useMediaContext();
          if (hasProvidedContext(menuContext)) {
            this.#menu = useContext(menuContext);
          }
        }
        onConnect(el) {
          super.onConnect?.(el);
          effect(this.#watchValue.bind(this));
          effect(this.#watchControllerDisabled.bind(this));
          effect(this.#watchHintText.bind(this));
        }
        getOptions() {
          const { offLabel } = this.$props, { textTracks } = this.#media.$state;
          return [
            { value: "off", label: offLabel },
            ...textTracks().filter(isTrackCaptionKind).map((track) => ({
              track,
              label: track.label,
              value: this.#getTrackValue(track)
            }))
          ];
        }
        #watchValue() {
          this.#controller.value = this.#getValue();
        }
        #watchHintText() {
          const { offLabel } = this.$props, { textTrack } = this.#media.$state, track = textTrack();
          this.#menu?.hint.set(
            track && isTrackCaptionKind(track) && track.mode === "showing" ? track.label : offLabel()
          );
        }
        #watchControllerDisabled() {
          this.#menu?.disable(this.disabled);
        }
        #getValue() {
          const { textTrack } = this.#media.$state, track = textTrack();
          return track && isTrackCaptionKind(track) && track.mode === "showing" ? this.#getTrackValue(track) : "off";
        }
        #onValueChange(value, trigger) {
          if (this.disabled)
            return;
          if (value === "off") {
            const track = this.#media.textTracks.selected;
            if (track) {
              const index2 = this.#media.textTracks.indexOf(track);
              this.#media.remote.changeTextTrackMode(index2, "disabled", trigger);
              this.dispatch("change", { detail: null, trigger });
            }
            return;
          }
          const index = this.#media.textTracks.toArray().findIndex((track) => this.#getTrackValue(track) === value);
          if (index >= 0) {
            const track = this.#media.textTracks[index];
            this.#media.remote.changeTextTrackMode(index, "showing", trigger);
            this.dispatch("change", { detail: track, trigger });
          }
        }
        #getTrackValue(track) {
          return track.id + ":" + track.kind + "-" + track.label.toLowerCase();
        }
      };
      captionsradiogroup__proto = CaptionsRadioGroup.prototype;
      prop(captionsradiogroup__proto, "value");
      prop(captionsradiogroup__proto, "disabled");
      method(captionsradiogroup__proto, "getOptions");
      DEFAULT_PLAYBACK_RATES = [0.25, 0.5, 0.75, 1, 1.25, 1.5, 1.75, 2];
      SpeedRadioGroup = class extends Component {
        static props = {
          normalLabel: "Normal",
          rates: DEFAULT_PLAYBACK_RATES
        };
        #media;
        #menu;
        #controller;
        get value() {
          return this.#controller.value;
        }
        get disabled() {
          const { rates } = this.$props, { canSetPlaybackRate } = this.#media.$state;
          return !canSetPlaybackRate() || rates().length === 0;
        }
        constructor() {
          super();
          this.#controller = new RadioGroupController();
          this.#controller.onValueChange = this.#onValueChange.bind(this);
        }
        onSetup() {
          this.#media = useMediaContext();
          if (hasProvidedContext(menuContext)) {
            this.#menu = useContext(menuContext);
          }
        }
        onConnect(el) {
          effect(this.#watchValue.bind(this));
          effect(this.#watchHintText.bind(this));
          effect(this.#watchControllerDisabled.bind(this));
        }
        getOptions() {
          const { rates, normalLabel } = this.$props;
          return rates().map((rate) => ({
            label: rate === 1 ? normalLabel : rate + "\xD7",
            value: rate.toString()
          }));
        }
        #watchValue() {
          this.#controller.value = this.#getValue();
        }
        #watchHintText() {
          const { normalLabel } = this.$props, { playbackRate } = this.#media.$state, rate = playbackRate();
          this.#menu?.hint.set(rate === 1 ? normalLabel() : rate + "\xD7");
        }
        #watchControllerDisabled() {
          this.#menu?.disable(this.disabled);
        }
        #getValue() {
          const { playbackRate } = this.#media.$state;
          return playbackRate().toString();
        }
        #onValueChange(value, trigger) {
          if (this.disabled)
            return;
          const rate = +value;
          this.#media.remote.changePlaybackRate(rate, trigger);
          this.dispatch("change", { detail: rate, trigger });
        }
      };
      speedradiogroup__proto = SpeedRadioGroup.prototype;
      prop(speedradiogroup__proto, "value");
      prop(speedradiogroup__proto, "disabled");
      method(speedradiogroup__proto, "getOptions");
      QualityRadioGroup = class extends Component {
        static props = {
          autoLabel: "Auto",
          hideBitrate: false,
          sort: "descending"
        };
        #media;
        #menu;
        #controller;
        get value() {
          return this.#controller.value;
        }
        get disabled() {
          const { canSetQuality, qualities } = this.#media.$state;
          return !canSetQuality() || qualities().length <= 1;
        }
        #sortedQualities = computed(() => {
          const { sort } = this.$props, { qualities } = this.#media.$state;
          return sortVideoQualities(qualities(), sort() === "descending");
        });
        constructor() {
          super();
          this.#controller = new RadioGroupController();
          this.#controller.onValueChange = this.#onValueChange.bind(this);
        }
        onSetup() {
          this.#media = useMediaContext();
          if (hasProvidedContext(menuContext)) {
            this.#menu = useContext(menuContext);
          }
        }
        onConnect(el) {
          effect(this.#watchValue.bind(this));
          effect(this.#watchControllerDisabled.bind(this));
          effect(this.#watchHintText.bind(this));
        }
        getOptions() {
          const { autoLabel, hideBitrate } = this.$props;
          return [
            { value: "auto", label: autoLabel },
            ...this.#sortedQualities().map((quality) => {
              const bitrate = quality.bitrate && quality.bitrate >= 0 ? `${round2(quality.bitrate / 1e6, 2)} Mbps` : null;
              return {
                quality,
                label: quality.height + "p",
                value: this.#getQualityId(quality),
                bitrate: () => !hideBitrate() ? bitrate : null
              };
            })
          ];
        }
        #watchValue() {
          this.#controller.value = this.#getValue();
        }
        #watchHintText() {
          const { autoLabel } = this.$props, { autoQuality, quality } = this.#media.$state, qualityText = quality() ? quality().height + "p" : "";
          this.#menu?.hint.set(
            !autoQuality() ? qualityText : autoLabel() + (qualityText ? ` (${qualityText})` : "")
          );
        }
        #watchControllerDisabled() {
          this.#menu?.disable(this.disabled);
        }
        #onValueChange(value, trigger) {
          if (this.disabled)
            return;
          if (value === "auto") {
            this.#media.remote.changeQuality(-1, trigger);
            this.dispatch("change", { detail: "auto", trigger });
            return;
          }
          const { qualities } = this.#media.$state, index = peek(qualities).findIndex((quality) => this.#getQualityId(quality) === value);
          if (index >= 0) {
            const quality = peek(qualities)[index];
            this.#media.remote.changeQuality(index, trigger);
            this.dispatch("change", { detail: quality, trigger });
          }
        }
        #getValue() {
          const { quality, autoQuality } = this.#media.$state;
          if (autoQuality())
            return "auto";
          const currentQuality = quality();
          return currentQuality ? this.#getQualityId(currentQuality) : "auto";
        }
        #getQualityId(quality) {
          return quality.height + "_" + quality.bitrate;
        }
      };
      qualityradiogroup__proto = QualityRadioGroup.prototype;
      prop(qualityradiogroup__proto, "value");
      prop(qualityradiogroup__proto, "disabled");
      method(qualityradiogroup__proto, "getOptions");
      Time = class extends Component {
        static props = {
          type: "current",
          showHours: false,
          padHours: null,
          padMinutes: null,
          remainder: false,
          toggle: false,
          hidden: false
        };
        static state = new State({
          timeText: "",
          hidden: false
        });
        #media;
        #invert = signal(null);
        #isVisible = signal(true);
        #isIntersecting = signal(true);
        onSetup() {
          this.#media = useMediaContext();
          this.#watchTime();
          const { type } = this.$props;
          this.setAttributes({
            "data-type": type,
            "data-remainder": this.#shouldInvert.bind(this)
          });
          new IntersectionObserverController({
            callback: this.#onIntersectionChange.bind(this)
          }).attach(this);
        }
        onAttach(el) {
          if (!el.hasAttribute("role"))
            effect(this.#watchRole.bind(this));
          effect(this.#watchTime.bind(this));
        }
        onConnect(el) {
          onDispose(observeVisibility(el, this.#isVisible.set));
          effect(this.#watchHidden.bind(this));
          effect(this.#watchToggle.bind(this));
        }
        #onIntersectionChange(entries) {
          this.#isIntersecting.set(entries[0].isIntersecting);
        }
        #watchHidden() {
          const { hidden } = this.$props;
          this.$state.hidden.set(hidden() || !this.#isVisible() || !this.#isIntersecting());
        }
        #watchToggle() {
          if (!this.$props.toggle()) {
            this.#invert.set(null);
            return;
          }
          if (this.el) {
            onPress(this.el, this.#onToggle.bind(this));
          }
        }
        #watchTime() {
          const { hidden, timeText } = this.$state, { duration } = this.#media.$state;
          if (hidden())
            return;
          const { type, padHours, padMinutes, showHours } = this.$props, seconds = this.#getSeconds(type()), $duration = duration(), shouldInvert = this.#shouldInvert();
          if (!Number.isFinite(seconds + $duration)) {
            timeText.set("LIVE");
            return;
          }
          const time = shouldInvert ? Math.max(0, $duration - seconds) : seconds, formattedTime = formatTime(time, {
            padHrs: padHours(),
            padMins: padMinutes(),
            showHrs: showHours()
          });
          timeText.set((shouldInvert ? "-" : "") + formattedTime);
        }
        #watchRole() {
          if (!this.el)
            return;
          const { toggle } = this.$props;
          setAttribute(this.el, "role", toggle() ? "timer" : null);
          setAttribute(this.el, "tabindex", toggle() ? 0 : null);
        }
        #getSeconds(type) {
          const { bufferedEnd, duration, currentTime } = this.#media.$state;
          switch (type) {
            case "buffered":
              return bufferedEnd();
            case "duration":
              return duration();
            default:
              return currentTime();
          }
        }
        #shouldInvert() {
          return this.$props.remainder() && this.#invert() !== false;
        }
        #onToggle(event2) {
          event2.preventDefault();
          if (this.#invert() === null) {
            this.#invert.set(!this.$props.remainder());
            return;
          }
          this.#invert.set((v2) => !v2);
        }
      };
    }
  });

  // node_modules/.pnpm/lit-html@2.8.0/node_modules/lit-html/lit-html.js
  function P(t6, i5) {
    if (!Array.isArray(t6) || !t6.hasOwnProperty("raw"))
      throw Error("invalid template strings array");
    return void 0 !== e4 ? e4.createHTML(i5) : i5;
  }
  function S(t6, i5, s5 = t6, e8) {
    var o7, n6, l6, h5;
    if (i5 === T)
      return i5;
    let r5 = void 0 !== e8 ? null === (o7 = s5._$Co) || void 0 === o7 ? void 0 : o7[e8] : s5._$Cl;
    const u2 = d(i5) ? void 0 : i5._$litDirective$;
    return (null == r5 ? void 0 : r5.constructor) !== u2 && (null === (n6 = null == r5 ? void 0 : r5._$AO) || void 0 === n6 || n6.call(r5, false), void 0 === u2 ? r5 = void 0 : (r5 = new u2(t6), r5._$AT(t6, s5, e8)), void 0 !== e8 ? (null !== (l6 = (h5 = s5)._$Co) && void 0 !== l6 ? l6 : h5._$Co = [])[e8] = r5 : s5._$Cl = r5), void 0 !== r5 && (i5 = S(t6, r5._$AS(t6, i5.values), r5, e8)), i5;
  }
  var t3, i2, s2, e4, o3, n3, l3, h2, r3, u, d, c2, v, a2, f, _, m, p, g, $2, y, w, x, b, T, A, E, C, V, N, M, R, k, H, I, L, z, Z, j, B;
  var init_lit_html = __esm({
    "node_modules/.pnpm/lit-html@2.8.0/node_modules/lit-html/lit-html.js"() {
      init_live_reload();
      i2 = window;
      s2 = i2.trustedTypes;
      e4 = s2 ? s2.createPolicy("lit-html", { createHTML: (t6) => t6 }) : void 0;
      o3 = "$lit$";
      n3 = `lit$${(Math.random() + "").slice(9)}$`;
      l3 = "?" + n3;
      h2 = `<${l3}>`;
      r3 = document;
      u = () => r3.createComment("");
      d = (t6) => null === t6 || "object" != typeof t6 && "function" != typeof t6;
      c2 = Array.isArray;
      v = (t6) => c2(t6) || "function" == typeof (null == t6 ? void 0 : t6[Symbol.iterator]);
      a2 = "[ 	\n\f\r]";
      f = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g;
      _ = /-->/g;
      m = />/g;
      p = RegExp(`>|${a2}(?:([^\\s"'>=/]+)(${a2}*=${a2}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g");
      g = /'/g;
      $2 = /"/g;
      y = /^(?:script|style|textarea|title)$/i;
      w = (t6) => (i5, ...s5) => ({ _$litType$: t6, strings: i5, values: s5 });
      x = w(1);
      b = w(2);
      T = Symbol.for("lit-noChange");
      A = Symbol.for("lit-nothing");
      E = /* @__PURE__ */ new WeakMap();
      C = r3.createTreeWalker(r3, 129, null, false);
      V = (t6, i5) => {
        const s5 = t6.length - 1, e8 = [];
        let l6, r5 = 2 === i5 ? "<svg>" : "", u2 = f;
        for (let i6 = 0; i6 < s5; i6++) {
          const s6 = t6[i6];
          let d2, c4, v2 = -1, a4 = 0;
          for (; a4 < s6.length && (u2.lastIndex = a4, c4 = u2.exec(s6), null !== c4); )
            a4 = u2.lastIndex, u2 === f ? "!--" === c4[1] ? u2 = _ : void 0 !== c4[1] ? u2 = m : void 0 !== c4[2] ? (y.test(c4[2]) && (l6 = RegExp("</" + c4[2], "g")), u2 = p) : void 0 !== c4[3] && (u2 = p) : u2 === p ? ">" === c4[0] ? (u2 = null != l6 ? l6 : f, v2 = -1) : void 0 === c4[1] ? v2 = -2 : (v2 = u2.lastIndex - c4[2].length, d2 = c4[1], u2 = void 0 === c4[3] ? p : '"' === c4[3] ? $2 : g) : u2 === $2 || u2 === g ? u2 = p : u2 === _ || u2 === m ? u2 = f : (u2 = p, l6 = void 0);
          const w2 = u2 === p && t6[i6 + 1].startsWith("/>") ? " " : "";
          r5 += u2 === f ? s6 + h2 : v2 >= 0 ? (e8.push(d2), s6.slice(0, v2) + o3 + s6.slice(v2) + n3 + w2) : s6 + n3 + (-2 === v2 ? (e8.push(void 0), i6) : w2);
        }
        return [P(t6, r5 + (t6[s5] || "<?>") + (2 === i5 ? "</svg>" : "")), e8];
      };
      N = class _N {
        constructor({ strings: t6, _$litType$: i5 }, e8) {
          let h5;
          this.parts = [];
          let r5 = 0, d2 = 0;
          const c4 = t6.length - 1, v2 = this.parts, [a4, f2] = V(t6, i5);
          if (this.el = _N.createElement(a4, e8), C.currentNode = this.el.content, 2 === i5) {
            const t7 = this.el.content, i6 = t7.firstChild;
            i6.remove(), t7.append(...i6.childNodes);
          }
          for (; null !== (h5 = C.nextNode()) && v2.length < c4; ) {
            if (1 === h5.nodeType) {
              if (h5.hasAttributes()) {
                const t7 = [];
                for (const i6 of h5.getAttributeNames())
                  if (i6.endsWith(o3) || i6.startsWith(n3)) {
                    const s5 = f2[d2++];
                    if (t7.push(i6), void 0 !== s5) {
                      const t8 = h5.getAttribute(s5.toLowerCase() + o3).split(n3), i7 = /([.?@])?(.*)/.exec(s5);
                      v2.push({ type: 1, index: r5, name: i7[2], strings: t8, ctor: "." === i7[1] ? H : "?" === i7[1] ? L : "@" === i7[1] ? z : k });
                    } else
                      v2.push({ type: 6, index: r5 });
                  }
                for (const i6 of t7)
                  h5.removeAttribute(i6);
              }
              if (y.test(h5.tagName)) {
                const t7 = h5.textContent.split(n3), i6 = t7.length - 1;
                if (i6 > 0) {
                  h5.textContent = s2 ? s2.emptyScript : "";
                  for (let s5 = 0; s5 < i6; s5++)
                    h5.append(t7[s5], u()), C.nextNode(), v2.push({ type: 2, index: ++r5 });
                  h5.append(t7[i6], u());
                }
              }
            } else if (8 === h5.nodeType)
              if (h5.data === l3)
                v2.push({ type: 2, index: r5 });
              else {
                let t7 = -1;
                for (; -1 !== (t7 = h5.data.indexOf(n3, t7 + 1)); )
                  v2.push({ type: 7, index: r5 }), t7 += n3.length - 1;
              }
            r5++;
          }
        }
        static createElement(t6, i5) {
          const s5 = r3.createElement("template");
          return s5.innerHTML = t6, s5;
        }
      };
      M = class {
        constructor(t6, i5) {
          this._$AV = [], this._$AN = void 0, this._$AD = t6, this._$AM = i5;
        }
        get parentNode() {
          return this._$AM.parentNode;
        }
        get _$AU() {
          return this._$AM._$AU;
        }
        u(t6) {
          var i5;
          const { el: { content: s5 }, parts: e8 } = this._$AD, o7 = (null !== (i5 = null == t6 ? void 0 : t6.creationScope) && void 0 !== i5 ? i5 : r3).importNode(s5, true);
          C.currentNode = o7;
          let n6 = C.nextNode(), l6 = 0, h5 = 0, u2 = e8[0];
          for (; void 0 !== u2; ) {
            if (l6 === u2.index) {
              let i6;
              2 === u2.type ? i6 = new R(n6, n6.nextSibling, this, t6) : 1 === u2.type ? i6 = new u2.ctor(n6, u2.name, u2.strings, this, t6) : 6 === u2.type && (i6 = new Z(n6, this, t6)), this._$AV.push(i6), u2 = e8[++h5];
            }
            l6 !== (null == u2 ? void 0 : u2.index) && (n6 = C.nextNode(), l6++);
          }
          return C.currentNode = r3, o7;
        }
        v(t6) {
          let i5 = 0;
          for (const s5 of this._$AV)
            void 0 !== s5 && (void 0 !== s5.strings ? (s5._$AI(t6, s5, i5), i5 += s5.strings.length - 2) : s5._$AI(t6[i5])), i5++;
        }
      };
      R = class _R {
        constructor(t6, i5, s5, e8) {
          var o7;
          this.type = 2, this._$AH = A, this._$AN = void 0, this._$AA = t6, this._$AB = i5, this._$AM = s5, this.options = e8, this._$Cp = null === (o7 = null == e8 ? void 0 : e8.isConnected) || void 0 === o7 || o7;
        }
        get _$AU() {
          var t6, i5;
          return null !== (i5 = null === (t6 = this._$AM) || void 0 === t6 ? void 0 : t6._$AU) && void 0 !== i5 ? i5 : this._$Cp;
        }
        get parentNode() {
          let t6 = this._$AA.parentNode;
          const i5 = this._$AM;
          return void 0 !== i5 && 11 === (null == t6 ? void 0 : t6.nodeType) && (t6 = i5.parentNode), t6;
        }
        get startNode() {
          return this._$AA;
        }
        get endNode() {
          return this._$AB;
        }
        _$AI(t6, i5 = this) {
          t6 = S(this, t6, i5), d(t6) ? t6 === A || null == t6 || "" === t6 ? (this._$AH !== A && this._$AR(), this._$AH = A) : t6 !== this._$AH && t6 !== T && this._(t6) : void 0 !== t6._$litType$ ? this.g(t6) : void 0 !== t6.nodeType ? this.$(t6) : v(t6) ? this.T(t6) : this._(t6);
        }
        k(t6) {
          return this._$AA.parentNode.insertBefore(t6, this._$AB);
        }
        $(t6) {
          this._$AH !== t6 && (this._$AR(), this._$AH = this.k(t6));
        }
        _(t6) {
          this._$AH !== A && d(this._$AH) ? this._$AA.nextSibling.data = t6 : this.$(r3.createTextNode(t6)), this._$AH = t6;
        }
        g(t6) {
          var i5;
          const { values: s5, _$litType$: e8 } = t6, o7 = "number" == typeof e8 ? this._$AC(t6) : (void 0 === e8.el && (e8.el = N.createElement(P(e8.h, e8.h[0]), this.options)), e8);
          if ((null === (i5 = this._$AH) || void 0 === i5 ? void 0 : i5._$AD) === o7)
            this._$AH.v(s5);
          else {
            const t7 = new M(o7, this), i6 = t7.u(this.options);
            t7.v(s5), this.$(i6), this._$AH = t7;
          }
        }
        _$AC(t6) {
          let i5 = E.get(t6.strings);
          return void 0 === i5 && E.set(t6.strings, i5 = new N(t6)), i5;
        }
        T(t6) {
          c2(this._$AH) || (this._$AH = [], this._$AR());
          const i5 = this._$AH;
          let s5, e8 = 0;
          for (const o7 of t6)
            e8 === i5.length ? i5.push(s5 = new _R(this.k(u()), this.k(u()), this, this.options)) : s5 = i5[e8], s5._$AI(o7), e8++;
          e8 < i5.length && (this._$AR(s5 && s5._$AB.nextSibling, e8), i5.length = e8);
        }
        _$AR(t6 = this._$AA.nextSibling, i5) {
          var s5;
          for (null === (s5 = this._$AP) || void 0 === s5 || s5.call(this, false, true, i5); t6 && t6 !== this._$AB; ) {
            const i6 = t6.nextSibling;
            t6.remove(), t6 = i6;
          }
        }
        setConnected(t6) {
          var i5;
          void 0 === this._$AM && (this._$Cp = t6, null === (i5 = this._$AP) || void 0 === i5 || i5.call(this, t6));
        }
      };
      k = class {
        constructor(t6, i5, s5, e8, o7) {
          this.type = 1, this._$AH = A, this._$AN = void 0, this.element = t6, this.name = i5, this._$AM = e8, this.options = o7, s5.length > 2 || "" !== s5[0] || "" !== s5[1] ? (this._$AH = Array(s5.length - 1).fill(new String()), this.strings = s5) : this._$AH = A;
        }
        get tagName() {
          return this.element.tagName;
        }
        get _$AU() {
          return this._$AM._$AU;
        }
        _$AI(t6, i5 = this, s5, e8) {
          const o7 = this.strings;
          let n6 = false;
          if (void 0 === o7)
            t6 = S(this, t6, i5, 0), n6 = !d(t6) || t6 !== this._$AH && t6 !== T, n6 && (this._$AH = t6);
          else {
            const e9 = t6;
            let l6, h5;
            for (t6 = o7[0], l6 = 0; l6 < o7.length - 1; l6++)
              h5 = S(this, e9[s5 + l6], i5, l6), h5 === T && (h5 = this._$AH[l6]), n6 || (n6 = !d(h5) || h5 !== this._$AH[l6]), h5 === A ? t6 = A : t6 !== A && (t6 += (null != h5 ? h5 : "") + o7[l6 + 1]), this._$AH[l6] = h5;
          }
          n6 && !e8 && this.j(t6);
        }
        j(t6) {
          t6 === A ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, null != t6 ? t6 : "");
        }
      };
      H = class extends k {
        constructor() {
          super(...arguments), this.type = 3;
        }
        j(t6) {
          this.element[this.name] = t6 === A ? void 0 : t6;
        }
      };
      I = s2 ? s2.emptyScript : "";
      L = class extends k {
        constructor() {
          super(...arguments), this.type = 4;
        }
        j(t6) {
          t6 && t6 !== A ? this.element.setAttribute(this.name, I) : this.element.removeAttribute(this.name);
        }
      };
      z = class extends k {
        constructor(t6, i5, s5, e8, o7) {
          super(t6, i5, s5, e8, o7), this.type = 5;
        }
        _$AI(t6, i5 = this) {
          var s5;
          if ((t6 = null !== (s5 = S(this, t6, i5, 0)) && void 0 !== s5 ? s5 : A) === T)
            return;
          const e8 = this._$AH, o7 = t6 === A && e8 !== A || t6.capture !== e8.capture || t6.once !== e8.once || t6.passive !== e8.passive, n6 = t6 !== A && (e8 === A || o7);
          o7 && this.element.removeEventListener(this.name, this, e8), n6 && this.element.addEventListener(this.name, this, t6), this._$AH = t6;
        }
        handleEvent(t6) {
          var i5, s5;
          "function" == typeof this._$AH ? this._$AH.call(null !== (s5 = null === (i5 = this.options) || void 0 === i5 ? void 0 : i5.host) && void 0 !== s5 ? s5 : this.element, t6) : this._$AH.handleEvent(t6);
        }
      };
      Z = class {
        constructor(t6, i5, s5) {
          this.element = t6, this.type = 6, this._$AN = void 0, this._$AM = i5, this.options = s5;
        }
        get _$AU() {
          return this._$AM._$AU;
        }
        _$AI(t6) {
          S(this, t6);
        }
      };
      j = { O: o3, P: n3, A: l3, C: 1, M: V, L: M, R: v, D: S, I: R, V: k, H: L, N: z, U: H, F: Z };
      B = i2.litHtmlPolyfillSupport;
      null == B || B(N, R), (null !== (t3 = i2.litHtmlVersions) && void 0 !== t3 ? t3 : i2.litHtmlVersions = []).push("2.8.0");
    }
  });

  // node_modules/.pnpm/vidstack@1.12.9/node_modules/vidstack/prod/chunks/vidstack-BOLMn4nu.js
  function renderMenuItemsTemplate(el, onCreate) {
    requestScopedAnimationFrame(() => {
      if (!el.connectScope)
        return;
      const template = el.querySelector("template");
      if (!template)
        return;
      effect(() => {
        const options = el.getOptions();
        cloneTemplate(template, options.length, (radio, i5) => {
          const { label, value } = options[i5], labelEl = radio.querySelector(`[data-part="label"]`);
          radio.setAttribute("value", value);
          if (labelEl) {
            if (isString(label)) {
              labelEl.textContent = label;
            } else {
              effect(() => {
                labelEl.textContent = label();
              });
            }
          }
          onCreate?.(radio, options[i5], i5);
        });
      });
    });
  }
  var imgTemplate, MediaThumbnailElement, MediaTimeElement, MediaAirPlayButtonElement, MediaCaptionButtonElement, MediaFullscreenButtonElement, MediaLiveButtonElement, MediaMuteButtonElement, MediaPIPButtonElement, MediaPlayButtonElement, MediaSeekButtonElement, MediaAudioRadioGroupElement, MediaCaptionsRadioGroupElement, MediaMenuElement, MediaMenuButtonElement, MediaMenuItemElement, MediaMenuItemsElement, MediaSpeedRadioGroupElement, MediaQualityRadioGroupElement, MediaSliderValueElement, MediaTimeSliderElement, MediaSliderPreviewElement, MediaVolumeSliderElement;
  var init_vidstack_BOLMn4nu = __esm({
    "node_modules/.pnpm/vidstack@1.12.9/node_modules/vidstack/prod/chunks/vidstack-BOLMn4nu.js"() {
      init_live_reload();
      init_vidstack_CRlI3Mh7();
      init_vidstack_C3qcqQM6();
      init_vidstack_Ds_q5BGO();
      init_vidstack_Cpte_fRf();
      imgTemplate = /* @__PURE__ */ createTemplate(
        '<img loading="eager" decoding="async" aria-hidden="true">'
      );
      MediaThumbnailElement = class extends Host(HTMLElement, Thumbnail) {
        static tagName = "media-thumbnail";
        static attrs = {
          crossOrigin: "crossorigin"
        };
        #media;
        #img = this.#createImg();
        onSetup() {
          this.#media = useMediaContext();
          this.$state.img.set(this.#img);
        }
        onConnect() {
          const { src, crossOrigin } = this.$state;
          if (this.#img.parentNode !== this) {
            this.prepend(this.#img);
          }
          effect(() => {
            setAttribute(this.#img, "src", src());
            setAttribute(this.#img, "crossorigin", crossOrigin());
          });
        }
        #createImg() {
          return cloneTemplateContent(imgTemplate);
        }
      };
      MediaTimeElement = class extends Host(HTMLElement, Time) {
        static tagName = "media-time";
        onConnect() {
          effect(() => {
            this.textContent = this.$state.timeText();
          });
        }
      };
      MediaAirPlayButtonElement = class extends Host(HTMLElement, AirPlayButton) {
        static tagName = "media-airplay-button";
      };
      MediaCaptionButtonElement = class extends Host(HTMLElement, CaptionButton) {
        static tagName = "media-caption-button";
      };
      MediaFullscreenButtonElement = class extends Host(HTMLElement, FullscreenButton) {
        static tagName = "media-fullscreen-button";
      };
      MediaLiveButtonElement = class extends Host(HTMLElement, LiveButton) {
        static tagName = "media-live-button";
      };
      MediaMuteButtonElement = class extends Host(HTMLElement, MuteButton) {
        static tagName = "media-mute-button";
      };
      MediaPIPButtonElement = class extends Host(HTMLElement, PIPButton) {
        static tagName = "media-pip-button";
      };
      MediaPlayButtonElement = class extends Host(HTMLElement, PlayButton) {
        static tagName = "media-play-button";
      };
      MediaSeekButtonElement = class extends Host(HTMLElement, SeekButton) {
        static tagName = "media-seek-button";
      };
      MediaAudioRadioGroupElement = class extends Host(HTMLElement, AudioRadioGroup) {
        static tagName = "media-audio-radio-group";
        onConnect() {
          renderMenuItemsTemplate(this);
        }
      };
      MediaCaptionsRadioGroupElement = class extends Host(HTMLElement, CaptionsRadioGroup) {
        static tagName = "media-captions-radio-group";
        onConnect() {
          renderMenuItemsTemplate(this);
        }
      };
      MediaMenuElement = class extends Host(HTMLElement, Menu) {
        static tagName = "media-menu";
      };
      MediaMenuButtonElement = class extends Host(HTMLElement, MenuButton) {
        static tagName = "media-menu-button";
      };
      MediaMenuItemElement = class extends Host(HTMLElement, MenuItem) {
        static tagName = "media-menu-item";
      };
      MediaMenuItemsElement = class extends Host(HTMLElement, MenuItems) {
        static tagName = "media-menu-items";
      };
      MediaSpeedRadioGroupElement = class extends Host(HTMLElement, SpeedRadioGroup) {
        static tagName = "media-speed-radio-group";
        onConnect() {
          renderMenuItemsTemplate(this);
        }
      };
      MediaQualityRadioGroupElement = class extends Host(HTMLElement, QualityRadioGroup) {
        static tagName = "media-quality-radio-group";
        onConnect() {
          renderMenuItemsTemplate(this, (el, option) => {
            const bitrate = option.bitrate, bitrateEl = el.querySelector('[data-part="bitrate"]');
            if (bitrate && bitrateEl) {
              effect(() => {
                bitrateEl.textContent = bitrate() || "";
              });
            }
          });
        }
      };
      MediaSliderValueElement = class extends Host(HTMLElement, SliderValue) {
        static tagName = "media-slider-value";
        static attrs = {
          padMinutes: {
            converter: BOOLEAN
          }
        };
        onConnect() {
          effect(() => {
            this.textContent = this.getValueText();
          });
        }
      };
      MediaTimeSliderElement = class extends Host(HTMLElement, TimeSlider) {
        static tagName = "media-time-slider";
      };
      MediaSliderPreviewElement = class extends Host(HTMLElement, SliderPreview) {
        static tagName = "media-slider-preview";
      };
      MediaVolumeSliderElement = class extends Host(HTMLElement, VolumeSlider) {
        static tagName = "media-volume-slider";
      };
    }
  });

  // node_modules/.pnpm/vidstack@1.12.9/node_modules/vidstack/prod/chunks/vidstack-BmMUBVGQ.js
  function getTimeRangesStart(range) {
    if (!range.length)
      return null;
    let min2 = range.start(0);
    for (let i5 = 1; i5 < range.length; i5++) {
      const value = range.start(i5);
      if (value < min2)
        min2 = value;
    }
    return min2;
  }
  function getTimeRangesEnd(range) {
    if (!range.length)
      return null;
    let max2 = range.end(0);
    for (let i5 = 1; i5 < range.length; i5++) {
      const value = range.end(i5);
      if (value > max2)
        max2 = value;
    }
    return max2;
  }
  function normalizeTimeIntervals(intervals) {
    if (intervals.length <= 1) {
      return intervals;
    }
    intervals.sort((a4, b2) => a4[0] - b2[0]);
    let normalized = [], current = intervals[0];
    for (let i5 = 1; i5 < intervals.length; i5++) {
      const next = intervals[i5];
      if (current[1] >= next[0] - 1) {
        current = [current[0], Math.max(current[1], next[1])];
      } else {
        normalized.push(current);
        current = next;
      }
    }
    normalized.push(current);
    return normalized;
  }
  function updateTimeIntervals(intervals, interval, value) {
    let start = interval[0], end = interval[1];
    if (value < start) {
      return [value, -1];
    } else if (value === start) {
      return interval;
    } else if (start === -1) {
      interval[0] = value;
      return interval;
    } else if (value > start) {
      interval[1] = value;
      if (end === -1)
        intervals.push(interval);
    }
    normalizeTimeIntervals(intervals);
    return interval;
  }
  var TimeRange;
  var init_vidstack_BmMUBVGQ = __esm({
    "node_modules/.pnpm/vidstack@1.12.9/node_modules/vidstack/prod/chunks/vidstack-BmMUBVGQ.js"() {
      init_live_reload();
      init_vidstack_CRlI3Mh7();
      TimeRange = class {
        #ranges;
        get length() {
          return this.#ranges.length;
        }
        constructor(start, end) {
          if (isArray(start)) {
            this.#ranges = start;
          } else if (!isUndefined(start) && !isUndefined(end)) {
            this.#ranges = [[start, end]];
          } else {
            this.#ranges = [];
          }
        }
        start(index) {
          return this.#ranges[index][0] ?? Infinity;
        }
        end(index) {
          return this.#ranges[index][1] ?? Infinity;
        }
      };
    }
  });

  // node_modules/.pnpm/vidstack@1.12.9/node_modules/vidstack/prod/chunks/vidstack-D5EzK014.js
  var ADD, REMOVE, RESET, SELECT, READONLY, SET_READONLY, ON_RESET, ON_REMOVE, ON_USER_SELECT, ListSymbol;
  var init_vidstack_D5EzK014 = __esm({
    "node_modules/.pnpm/vidstack@1.12.9/node_modules/vidstack/prod/chunks/vidstack-D5EzK014.js"() {
      init_live_reload();
      ADD = Symbol(0);
      REMOVE = Symbol(0);
      RESET = Symbol(0);
      SELECT = Symbol(0);
      READONLY = Symbol(0);
      SET_READONLY = Symbol(0);
      ON_RESET = Symbol(0);
      ON_REMOVE = Symbol(0);
      ON_USER_SELECT = Symbol(0);
      ListSymbol = {
        add: ADD,
        remove: REMOVE,
        reset: RESET,
        select: SELECT,
        readonly: READONLY,
        setReadonly: SET_READONLY,
        onReset: ON_RESET,
        onRemove: ON_REMOVE,
        onUserSelect: ON_USER_SELECT
      };
    }
  });

  // node_modules/.pnpm/vidstack@1.12.9/node_modules/vidstack/prod/chunks/vidstack-B01xzxC4.js
  var SET_AUTO, ENABLE_AUTO, QualitySymbol;
  var init_vidstack_B01xzxC4 = __esm({
    "node_modules/.pnpm/vidstack@1.12.9/node_modules/vidstack/prod/chunks/vidstack-B01xzxC4.js"() {
      init_live_reload();
      SET_AUTO = Symbol(0);
      ENABLE_AUTO = Symbol(0);
      QualitySymbol = {
        setAuto: SET_AUTO,
        enableAuto: ENABLE_AUTO
      };
    }
  });

  // node_modules/.pnpm/vidstack@1.12.9/node_modules/vidstack/prod/chunks/vidstack-DSYpsFWk.js
  var RAFLoop;
  var init_vidstack_DSYpsFWk = __esm({
    "node_modules/.pnpm/vidstack@1.12.9/node_modules/vidstack/prod/chunks/vidstack-DSYpsFWk.js"() {
      init_live_reload();
      init_vidstack_CRlI3Mh7();
      RAFLoop = class {
        #id;
        #callback;
        constructor(callback) {
          this.#callback = callback;
        }
        start() {
          if (!isUndefined(this.#id))
            return;
          this.#loop();
        }
        stop() {
          if (isNumber(this.#id))
            window.cancelAnimationFrame(this.#id);
          this.#id = void 0;
        }
        #loop() {
          this.#id = window.requestAnimationFrame(() => {
            if (isUndefined(this.#id))
              return;
            this.#callback();
            this.#loop();
          });
        }
      };
    }
  });

  // node_modules/.pnpm/vidstack@1.12.9/node_modules/vidstack/prod/providers/vidstack-html.js
  function getOrCreateAudioCtx() {
    return audioContext ??= new AudioContext();
  }
  function createGainNode() {
    const audioCtx = getOrCreateAudioCtx(), gainNode = audioCtx.createGain();
    gainNode.connect(audioCtx.destination);
    gainNodes.push(gainNode);
    return gainNode;
  }
  function createElementSource(el, gainNode) {
    const audioCtx = getOrCreateAudioCtx(), src = audioCtx.createMediaElementSource(el);
    if (gainNode) {
      src.connect(gainNode);
    }
    elAudioSources.push(src);
    return src;
  }
  function destroyGainNode(node) {
    const idx = gainNodes.indexOf(node);
    if (idx !== -1) {
      gainNodes.splice(idx, 1);
      node.disconnect();
      freeAudioCtxWhenAllResourcesFreed();
    }
  }
  function destroyElementSource(src) {
    const idx = elAudioSources.indexOf(src);
    if (idx !== -1) {
      elAudioSources.splice(idx, 1);
      src.disconnect();
      freeAudioCtxWhenAllResourcesFreed();
    }
  }
  function freeAudioCtxWhenAllResourcesFreed() {
    if (audioContext && gainNodes.length === 0 && elAudioSources.length === 0) {
      audioContext.close().then(() => {
        audioContext = null;
      });
    }
  }
  function determinePageState(event2) {
    if (event2?.type === "blur" || document.visibilityState === "hidden")
      return "hidden";
    if (document.hasFocus())
      return "active";
    return "passive";
  }
  var audioContext, gainNodes, elAudioSources, AudioGain, PAGE_EVENTS, PageVisibility, HTMLMediaEvents, NativeAudioTracks, HTMLMediaProvider;
  var init_vidstack_html = __esm({
    "node_modules/.pnpm/vidstack@1.12.9/node_modules/vidstack/prod/providers/vidstack-html.js"() {
      init_live_reload();
      init_vidstack_DyMkFGuS();
      init_vidstack_CRlI3Mh7();
      init_vidstack_DSYpsFWk();
      init_vidstack_Dihypf8P();
      init_vidstack_D5EzK014();
      audioContext = null;
      gainNodes = [];
      elAudioSources = [];
      AudioGain = class {
        #media;
        #onChange;
        #gainNode = null;
        #srcAudioNode = null;
        get currentGain() {
          return this.#gainNode?.gain?.value ?? null;
        }
        get supported() {
          return true;
        }
        constructor(media, onChange) {
          this.#media = media;
          this.#onChange = onChange;
        }
        setGain(gain) {
          const currGain = this.currentGain;
          if (gain === this.currentGain) {
            return;
          }
          if (gain === 1 && currGain !== 1) {
            this.removeGain();
            return;
          }
          if (!this.#gainNode) {
            this.#gainNode = createGainNode();
            if (this.#srcAudioNode) {
              this.#srcAudioNode.connect(this.#gainNode);
            }
          }
          if (!this.#srcAudioNode) {
            this.#srcAudioNode = createElementSource(this.#media, this.#gainNode);
          }
          this.#gainNode.gain.value = gain;
          this.#onChange(gain);
        }
        removeGain() {
          if (!this.#gainNode)
            return;
          if (this.#srcAudioNode) {
            this.#srcAudioNode.connect(getOrCreateAudioCtx().destination);
          }
          this.#destroyGainNode();
          this.#onChange(null);
        }
        destroy() {
          this.#destroySrcNode();
          this.#destroyGainNode();
        }
        #destroySrcNode() {
          if (!this.#srcAudioNode)
            return;
          try {
            destroyElementSource(this.#srcAudioNode);
          } catch (e8) {
          } finally {
            this.#srcAudioNode = null;
          }
        }
        #destroyGainNode() {
          if (!this.#gainNode)
            return;
          try {
            destroyGainNode(this.#gainNode);
          } catch (e8) {
          } finally {
            this.#gainNode = null;
          }
        }
      };
      PAGE_EVENTS = ["focus", "blur", "visibilitychange", "pageshow", "pagehide"];
      PageVisibility = class {
        #state = signal(determinePageState());
        #visibility = signal(document.visibilityState);
        #safariBeforeUnloadTimeout;
        connect() {
          const events2 = new EventsController(window), handlePageEvent = this.#handlePageEvent.bind(this);
          for (const eventType of PAGE_EVENTS) {
            events2.add(eventType, handlePageEvent);
          }
          if (IS_SAFARI) {
            events2.add("beforeunload", (event2) => {
              this.#safariBeforeUnloadTimeout = setTimeout(() => {
                if (!(event2.defaultPrevented || event2.returnValue.length > 0)) {
                  this.#state.set("hidden");
                  this.#visibility.set("hidden");
                }
              }, 0);
            });
          }
        }
        /**
         * The current page state. Important to note we only account for a subset of page states, as
         * the rest aren't valuable to the player at the moment.
         *
         * - **active:** A page is in the active state if it is visible and has input focus.
         * - **passive:** A page is in the passive state if it is visible and does not have input focus.
         * - **hidden:** A page is in the hidden state if it is not visible.
         *
         * @see https://developers.google.com/web/updates/2018/07/page-lifecycle-api#states
         */
        get pageState() {
          return this.#state();
        }
        /**
         * The current document visibility state.
         *
         * - **visible:** The page content may be at least partially visible. In practice, this means that
         * the page is the foreground tab of a non-minimized window.
         * - **hidden:** The page content is not visible to the user. In practice this means that the
         * document is either a background tab or part of a minimized window, or the OS screen lock is
         * active.
         *
         * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/visibilityState
         */
        get visibility() {
          return this.#visibility();
        }
        #handlePageEvent(event2) {
          if (IS_SAFARI)
            window.clearTimeout(this.#safariBeforeUnloadTimeout);
          if (event2.type !== "blur" || this.#state() === "active") {
            this.#state.set(determinePageState(event2));
            this.#visibility.set(document.visibilityState == "hidden" ? "hidden" : "visible");
          }
        }
      };
      HTMLMediaEvents = class {
        #provider;
        #ctx;
        #waiting = false;
        #attachedLoadStart = false;
        #attachedCanPlay = false;
        #timeRAF = new RAFLoop(this.#onAnimationFrame.bind(this));
        #pageVisibility = new PageVisibility();
        #events;
        get #media() {
          return this.#provider.media;
        }
        constructor(provider, ctx) {
          this.#provider = provider;
          this.#ctx = ctx;
          this.#events = new EventsController(provider.media);
          this.#attachInitialListeners();
          this.#pageVisibility.connect();
          effect(this.#attachTimeUpdate.bind(this));
          onDispose(this.#onDispose.bind(this));
        }
        #onDispose() {
          this.#attachedLoadStart = false;
          this.#attachedCanPlay = false;
          this.#timeRAF.stop();
          this.#events.abort();
          this.#devHandlers?.clear();
        }
        /**
         * The `timeupdate` event fires surprisingly infrequently during playback, meaning your progress
         * bar (or whatever else is synced to the currentTime) moves in a choppy fashion. This helps
         * resolve that by retrieving time updates in a request animation frame loop.
         */
        #lastSeenTime = 0;
        #seekedTo = -1;
        #onAnimationFrame() {
          const newTime = this.#media.currentTime;
          const didStutter = IS_SAFARI && newTime - this.#seekedTo < 0.35;
          if (!didStutter && this.#lastSeenTime !== newTime) {
            this.#updateCurrentTime(newTime);
            this.#lastSeenTime = newTime;
          }
        }
        #attachInitialListeners() {
          this.#attachEventListener("loadstart", this.#onLoadStart);
          this.#attachEventListener("abort", this.#onAbort);
          this.#attachEventListener("emptied", this.#onEmptied);
          this.#attachEventListener("error", this.#onError);
          this.#attachEventListener("volumechange", this.#onVolumeChange);
        }
        #attachLoadStartListeners() {
          if (this.#attachedLoadStart)
            return;
          this.#attachEventListener("loadeddata", this.#onLoadedData);
          this.#attachEventListener("loadedmetadata", this.#onLoadedMetadata);
          this.#attachEventListener("canplay", this.#onCanPlay);
          this.#attachEventListener("canplaythrough", this.#onCanPlayThrough);
          this.#attachEventListener("durationchange", this.#onDurationChange);
          this.#attachEventListener("play", this.#onPlay);
          this.#attachEventListener("progress", this.#onProgress);
          this.#attachEventListener("stalled", this.#onStalled);
          this.#attachEventListener("suspend", this.#onSuspend);
          this.#attachEventListener("ratechange", this.#onRateChange);
          this.#attachedLoadStart = true;
        }
        #attachCanPlayListeners() {
          if (this.#attachedCanPlay)
            return;
          this.#attachEventListener("pause", this.#onPause);
          this.#attachEventListener("playing", this.#onPlaying);
          this.#attachEventListener("seeked", this.#onSeeked);
          this.#attachEventListener("seeking", this.#onSeeking);
          this.#attachEventListener("ended", this.#onEnded);
          this.#attachEventListener("waiting", this.#onWaiting);
          this.#attachedCanPlay = true;
        }
        #devHandlers = void 0;
        #handleDevEvent = void 0;
        #attachEventListener(eventType, handler) {
          this.#events.add(eventType, handler.bind(this));
        }
        #onDevEvent(event2) {
          return;
        }
        #updateCurrentTime(time, trigger) {
          const newTime = Math.min(time, this.#ctx.$state.seekableEnd());
          this.#ctx.notify("time-change", newTime, trigger);
        }
        #onLoadStart(event2) {
          if (this.#media.networkState === 3) {
            this.#onAbort(event2);
            return;
          }
          this.#attachLoadStartListeners();
          this.#ctx.notify("load-start", void 0, event2);
        }
        #onAbort(event2) {
          this.#ctx.notify("abort", void 0, event2);
        }
        #onEmptied() {
          this.#ctx.notify("emptied", void 0, event);
        }
        #onLoadedData(event2) {
          this.#ctx.notify("loaded-data", void 0, event2);
        }
        #onLoadedMetadata(event2) {
          this.#lastSeenTime = 0;
          this.#seekedTo = -1;
          this.#attachCanPlayListeners();
          this.#ctx.notify("loaded-metadata", void 0, event2);
          if (IS_IOS || IS_SAFARI && isHLSSrc(this.#ctx.$state.source())) {
            this.#ctx.delegate.ready(this.#getCanPlayDetail(), event2);
          }
        }
        #getCanPlayDetail() {
          return {
            provider: peek(this.#ctx.$provider),
            duration: this.#media.duration,
            buffered: this.#media.buffered,
            seekable: this.#media.seekable
          };
        }
        #onPlay(event2) {
          if (!this.#ctx.$state.canPlay)
            return;
          this.#ctx.notify("play", void 0, event2);
        }
        #onPause(event2) {
          if (this.#media.readyState === 1 && !this.#waiting)
            return;
          this.#waiting = false;
          this.#timeRAF.stop();
          this.#ctx.notify("pause", void 0, event2);
        }
        #onCanPlay(event2) {
          this.#ctx.delegate.ready(this.#getCanPlayDetail(), event2);
        }
        #onCanPlayThrough(event2) {
          if (this.#ctx.$state.started())
            return;
          this.#ctx.notify("can-play-through", this.#getCanPlayDetail(), event2);
        }
        #onPlaying(event2) {
          if (this.#media.paused)
            return;
          this.#waiting = false;
          this.#ctx.notify("playing", void 0, event2);
          this.#timeRAF.start();
        }
        #onStalled(event2) {
          this.#ctx.notify("stalled", void 0, event2);
          if (this.#media.readyState < 3) {
            this.#waiting = true;
            this.#ctx.notify("waiting", void 0, event2);
          }
        }
        #onWaiting(event2) {
          if (this.#media.readyState < 3) {
            this.#waiting = true;
            this.#ctx.notify("waiting", void 0, event2);
          }
        }
        #onEnded(event2) {
          this.#timeRAF.stop();
          this.#updateCurrentTime(this.#media.duration, event2);
          this.#ctx.notify("end", void 0, event2);
          if (this.#ctx.$state.loop()) {
            const hasCustomControls = isNil(this.#media.controls);
            if (hasCustomControls)
              this.#media.controls = false;
          }
        }
        #attachTimeUpdate() {
          const isPaused = this.#ctx.$state.paused(), isPageHidden = this.#pageVisibility.visibility === "hidden", shouldListenToTimeUpdates = isPaused || isPageHidden;
          if (shouldListenToTimeUpdates) {
            listenEvent(this.#media, "timeupdate", this.#onTimeUpdate.bind(this));
          }
        }
        #onTimeUpdate(event2) {
          this.#updateCurrentTime(this.#media.currentTime, event2);
        }
        #onDurationChange(event2) {
          if (this.#ctx.$state.ended()) {
            this.#updateCurrentTime(this.#media.duration, event2);
          }
          this.#ctx.notify("duration-change", this.#media.duration, event2);
        }
        #onVolumeChange(event2) {
          const detail = {
            volume: this.#media.volume,
            muted: this.#media.muted
          };
          this.#ctx.notify("volume-change", detail, event2);
        }
        #onSeeked(event2) {
          this.#seekedTo = this.#media.currentTime;
          this.#updateCurrentTime(this.#media.currentTime, event2);
          this.#ctx.notify("seeked", this.#media.currentTime, event2);
          if (Math.trunc(this.#media.currentTime) === Math.trunc(this.#media.duration) && getNumberOfDecimalPlaces(this.#media.duration) > getNumberOfDecimalPlaces(this.#media.currentTime)) {
            this.#updateCurrentTime(this.#media.duration, event2);
            if (!this.#media.ended) {
              this.#ctx.player.dispatch(
                new DOMEvent("media-play-request", {
                  trigger: event2
                })
              );
            }
          }
        }
        #onSeeking(event2) {
          this.#ctx.notify("seeking", this.#media.currentTime, event2);
        }
        #onProgress(event2) {
          const detail = {
            buffered: this.#media.buffered,
            seekable: this.#media.seekable
          };
          this.#ctx.notify("progress", detail, event2);
        }
        #onSuspend(event2) {
          this.#ctx.notify("suspend", void 0, event2);
        }
        #onRateChange(event2) {
          this.#ctx.notify("rate-change", this.#media.playbackRate, event2);
        }
        #onError(event2) {
          const error = this.#media.error;
          if (!error)
            return;
          const detail = {
            message: error.message,
            code: error.code,
            mediaError: error
          };
          this.#ctx.notify("error", detail, event2);
        }
      };
      NativeAudioTracks = class {
        #provider;
        #ctx;
        get #nativeTracks() {
          return this.#provider.media.audioTracks;
        }
        constructor(provider, ctx) {
          this.#provider = provider;
          this.#ctx = ctx;
          this.#nativeTracks.onaddtrack = this.#onAddNativeTrack.bind(this);
          this.#nativeTracks.onremovetrack = this.#onRemoveNativeTrack.bind(this);
          this.#nativeTracks.onchange = this.#onChangeNativeTrack.bind(this);
          listenEvent(this.#ctx.audioTracks, "change", this.#onChangeTrack.bind(this));
        }
        #onAddNativeTrack(event2) {
          const nativeTrack = event2.track;
          if (nativeTrack.label === "")
            return;
          const id = nativeTrack.id.toString() || `native-audio-${this.#ctx.audioTracks.length}`, audioTrack = {
            id,
            label: nativeTrack.label,
            language: nativeTrack.language,
            kind: nativeTrack.kind,
            selected: false
          };
          this.#ctx.audioTracks[ListSymbol.add](audioTrack, event2);
          if (nativeTrack.enabled)
            audioTrack.selected = true;
        }
        #onRemoveNativeTrack(event2) {
          const track = this.#ctx.audioTracks.getById(event2.track.id);
          if (track)
            this.#ctx.audioTracks[ListSymbol.remove](track, event2);
        }
        #onChangeNativeTrack(event2) {
          let enabledTrack = this.#getEnabledNativeTrack();
          if (!enabledTrack)
            return;
          const track = this.#ctx.audioTracks.getById(enabledTrack.id);
          if (track)
            this.#ctx.audioTracks[ListSymbol.select](track, true, event2);
        }
        #getEnabledNativeTrack() {
          return Array.from(this.#nativeTracks).find((track) => track.enabled);
        }
        #onChangeTrack(event2) {
          const { current } = event2.detail;
          if (!current)
            return;
          const track = this.#nativeTracks.getTrackById(current.id);
          if (track) {
            const prev = this.#getEnabledNativeTrack();
            if (prev)
              prev.enabled = false;
            track.enabled = true;
          }
        }
      };
      HTMLMediaProvider = class {
        constructor(media, ctx) {
          this.media = media;
          this.ctx = ctx;
          this.audioGain = new AudioGain(media, (gain) => {
            this.ctx.notify("audio-gain-change", gain);
          });
        }
        scope = createScope();
        currentSrc = null;
        audioGain;
        setup() {
          new HTMLMediaEvents(this, this.ctx);
          if ("audioTracks" in this.media)
            new NativeAudioTracks(this, this.ctx);
          onDispose(() => {
            this.audioGain.destroy();
            this.media.srcObject = null;
            this.media.removeAttribute("src");
            for (const source of this.media.querySelectorAll("source"))
              source.remove();
            this.media.load();
          });
        }
        get type() {
          return "";
        }
        setPlaybackRate(rate) {
          this.media.playbackRate = rate;
        }
        async play() {
          return this.media.play();
        }
        async pause() {
          return this.media.pause();
        }
        setMuted(muted) {
          this.media.muted = muted;
        }
        setVolume(volume) {
          this.media.volume = volume;
        }
        setCurrentTime(time) {
          this.media.currentTime = time;
        }
        setPlaysInline(inline2) {
          setAttribute(this.media, "playsinline", inline2);
        }
        async loadSource({ src, type }, preload2) {
          this.media.preload = preload2 || "";
          if (isMediaStream(src)) {
            this.removeSource();
            this.media.srcObject = src;
          } else {
            this.media.srcObject = null;
            if (isString(src)) {
              if (type !== "?") {
                this.appendSource({ src, type });
              } else {
                this.removeSource();
                this.media.src = this.#appendMediaFragment(src);
              }
            } else {
              this.removeSource();
              this.media.src = window.URL.createObjectURL(src);
            }
          }
          this.media.load();
          this.currentSrc = { src, type };
        }
        /**
         * Append source so it works when requesting AirPlay since hls.js will remove it.
         */
        appendSource(src, defaultType) {
          const prevSource = this.media.querySelector("source[data-vds]"), source = prevSource ?? document.createElement("source");
          setAttribute(source, "src", this.#appendMediaFragment(src.src));
          setAttribute(source, "type", src.type !== "?" ? src.type : defaultType);
          setAttribute(source, "data-vds", "");
          if (!prevSource)
            this.media.append(source);
        }
        removeSource() {
          this.media.querySelector("source[data-vds]")?.remove();
        }
        #appendMediaFragment(src) {
          const { clipStartTime, clipEndTime } = this.ctx.$state, startTime = clipStartTime(), endTime = clipEndTime();
          if (startTime > 0 && endTime > 0) {
            return `${src}#t=${startTime},${endTime}`;
          } else if (startTime > 0) {
            return `${src}#t=${startTime}`;
          } else if (endTime > 0) {
            return `${src}#t=0,${endTime}`;
          }
          return src;
        }
      };
    }
  });

  // node_modules/.pnpm/vidstack@1.12.9/node_modules/vidstack/prod/chunks/vidstack-CSv7rfHP.js
  var HTMLRemotePlaybackAdapter, HTMLAirPlayAdapter;
  var init_vidstack_CSv7rfHP = __esm({
    "node_modules/.pnpm/vidstack@1.12.9/node_modules/vidstack/prod/chunks/vidstack-CSv7rfHP.js"() {
      init_live_reload();
      init_vidstack_CRlI3Mh7();
      HTMLRemotePlaybackAdapter = class {
        #media;
        #ctx;
        #state;
        #supported = signal(false);
        get supported() {
          return this.#supported();
        }
        constructor(media, ctx) {
          this.#media = media;
          this.#ctx = ctx;
          this.#setup();
        }
        #setup() {
          if (!this.#media?.remote || !this.canPrompt)
            return;
          this.#media.remote.watchAvailability((available) => {
            this.#supported.set(available);
          }).catch(() => {
            this.#supported.set(false);
          });
          effect(this.#watchSupported.bind(this));
        }
        #watchSupported() {
          if (!this.#supported())
            return;
          const events2 = ["connecting", "connect", "disconnect"], onStateChange = this.#onStateChange.bind(this);
          onStateChange();
          listenEvent(this.#media, "playing", onStateChange);
          const remoteEvents = new EventsController(this.#media.remote);
          for (const type of events2) {
            remoteEvents.add(type, onStateChange);
          }
        }
        async prompt() {
          if (!this.supported)
            throw Error("Not supported on this platform.");
          if (this.type === "airplay" && this.#media.webkitShowPlaybackTargetPicker) {
            return this.#media.webkitShowPlaybackTargetPicker();
          }
          return this.#media.remote.prompt();
        }
        #onStateChange(event2) {
          const state = this.#media.remote.state;
          if (state === this.#state)
            return;
          const detail = { type: this.type, state };
          this.#ctx.notify("remote-playback-change", detail, event2);
          this.#state = state;
        }
      };
      HTMLAirPlayAdapter = class extends HTMLRemotePlaybackAdapter {
        type = "airplay";
        get canPrompt() {
          return "WebKitPlaybackTargetAvailabilityEvent" in window;
        }
      };
    }
  });

  // node_modules/.pnpm/vidstack@1.12.9/node_modules/vidstack/prod/providers/vidstack-audio.js
  var vidstack_audio_exports = {};
  __export(vidstack_audio_exports, {
    AudioProvider: () => AudioProvider
  });
  var AudioProvider;
  var init_vidstack_audio = __esm({
    "node_modules/.pnpm/vidstack@1.12.9/node_modules/vidstack/prod/providers/vidstack-audio.js"() {
      init_live_reload();
      init_vidstack_CRlI3Mh7();
      init_vidstack_html();
      init_vidstack_CSv7rfHP();
      AudioProvider = class extends HTMLMediaProvider {
        $$PROVIDER_TYPE = "AUDIO";
        get type() {
          return "audio";
        }
        airPlay;
        constructor(audio, ctx) {
          super(audio, ctx);
          scoped(() => {
            this.airPlay = new HTMLAirPlayAdapter(this.media, ctx);
          }, this.scope);
        }
        setup() {
          super.setup();
          if (this.type === "audio")
            this.ctx.notify("provider-setup", this);
        }
        /**
         * The native HTML `<audio>` element.
         *
         * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLAudioElement}
         */
        get audio() {
          return this.media;
        }
      };
    }
  });

  // node_modules/.pnpm/vidstack@1.12.9/node_modules/vidstack/prod/providers/vidstack-video.js
  var vidstack_video_exports = {};
  __export(vidstack_video_exports, {
    VideoProvider: () => VideoProvider
  });
  function findTextTrackElement(video, track) {
    return Array.from(video.children).find((el) => el.track === track);
  }
  var NativeHLSTextTracks, VideoPictureInPicture, VideoPresentation, FullscreenPresentationAdapter, PIPPresentationAdapter, VideoProvider;
  var init_vidstack_video = __esm({
    "node_modules/.pnpm/vidstack@1.12.9/node_modules/vidstack/prod/providers/vidstack-video.js"() {
      init_live_reload();
      init_vidstack_CRlI3Mh7();
      init_vidstack_DyMkFGuS();
      init_vidstack_html();
      init_vidstack_CSv7rfHP();
      init_vidstack_B5628Ni3();
      NativeHLSTextTracks = class {
        #video;
        #ctx;
        constructor(video, ctx) {
          this.#video = video;
          this.#ctx = ctx;
          video.textTracks.onaddtrack = this.#onAddTrack.bind(this);
          onDispose(this.#onDispose.bind(this));
        }
        #onAddTrack(event2) {
          const nativeTrack = event2.track;
          if (!nativeTrack || findTextTrackElement(this.#video, nativeTrack))
            return;
          const track = new TextTrack({
            id: nativeTrack.id,
            kind: nativeTrack.kind,
            label: nativeTrack.label ?? "",
            language: nativeTrack.language,
            type: "vtt"
          });
          track[TextTrackSymbol.native] = { track: nativeTrack };
          track[TextTrackSymbol.readyState] = 2;
          track[TextTrackSymbol.nativeHLS] = true;
          let lastIndex = 0;
          const onCueChange = (event22) => {
            if (!nativeTrack.cues)
              return;
            for (let i5 = lastIndex; i5 < nativeTrack.cues.length; i5++) {
              track.addCue(nativeTrack.cues[i5], event22);
              lastIndex++;
            }
          };
          onCueChange(event2);
          nativeTrack.oncuechange = onCueChange;
          this.#ctx.textTracks.add(track, event2);
          track.setMode(nativeTrack.mode, event2);
        }
        #onDispose() {
          this.#video.textTracks.onaddtrack = null;
          for (const track of this.#ctx.textTracks) {
            const nativeTrack = track[TextTrackSymbol.native]?.track;
            if (nativeTrack?.oncuechange)
              nativeTrack.oncuechange = null;
          }
        }
      };
      VideoPictureInPicture = class {
        #video;
        #media;
        constructor(video, media) {
          this.#video = video;
          this.#media = media;
          new EventsController(video).add("enterpictureinpicture", this.#onEnter.bind(this)).add("leavepictureinpicture", this.#onExit.bind(this));
        }
        get active() {
          return document.pictureInPictureElement === this.#video;
        }
        get supported() {
          return canUsePictureInPicture(this.#video);
        }
        async enter() {
          return this.#video.requestPictureInPicture();
        }
        exit() {
          return document.exitPictureInPicture();
        }
        #onEnter(event2) {
          this.#onChange(true, event2);
        }
        #onExit(event2) {
          this.#onChange(false, event2);
        }
        #onChange = (active, event2) => {
          this.#media.notify("picture-in-picture-change", active, event2);
        };
      };
      VideoPresentation = class {
        #video;
        #media;
        #mode = "inline";
        get mode() {
          return this.#mode;
        }
        constructor(video, media) {
          this.#video = video;
          this.#media = media;
          listenEvent(video, "webkitpresentationmodechanged", this.#onModeChange.bind(this));
        }
        get supported() {
          return canUseVideoPresentation(this.#video);
        }
        async setPresentationMode(mode) {
          if (this.#mode === mode)
            return;
          this.#video.webkitSetPresentationMode(mode);
        }
        #onModeChange(event2) {
          const prevMode = this.#mode;
          this.#mode = this.#video.webkitPresentationMode;
          this.#media.player?.dispatch(
            new DOMEvent("video-presentation-change", {
              detail: this.#mode,
              trigger: event2
            })
          );
          ["fullscreen", "picture-in-picture"].forEach((type) => {
            if (this.#mode === type || prevMode === type) {
              this.#media.notify(`${type}-change`, this.#mode === type, event2);
            }
          });
        }
      };
      FullscreenPresentationAdapter = class {
        #presentation;
        get active() {
          return this.#presentation.mode === "fullscreen";
        }
        get supported() {
          return this.#presentation.supported;
        }
        constructor(presentation) {
          this.#presentation = presentation;
        }
        async enter() {
          this.#presentation.setPresentationMode("fullscreen");
        }
        async exit() {
          this.#presentation.setPresentationMode("inline");
        }
      };
      PIPPresentationAdapter = class {
        #presentation;
        get active() {
          return this.#presentation.mode === "picture-in-picture";
        }
        get supported() {
          return this.#presentation.supported;
        }
        constructor(presentation) {
          this.#presentation = presentation;
        }
        async enter() {
          this.#presentation.setPresentationMode("picture-in-picture");
        }
        async exit() {
          this.#presentation.setPresentationMode("inline");
        }
      };
      VideoProvider = class extends HTMLMediaProvider {
        $$PROVIDER_TYPE = "VIDEO";
        get type() {
          return "video";
        }
        airPlay;
        fullscreen;
        pictureInPicture;
        constructor(video, ctx) {
          super(video, ctx);
          scoped(() => {
            this.airPlay = new HTMLAirPlayAdapter(video, ctx);
            if (canUseVideoPresentation(video)) {
              const presentation = new VideoPresentation(video, ctx);
              this.fullscreen = new FullscreenPresentationAdapter(presentation);
              this.pictureInPicture = new PIPPresentationAdapter(presentation);
            } else if (canUsePictureInPicture(video)) {
              this.pictureInPicture = new VideoPictureInPicture(video, ctx);
            }
          }, this.scope);
        }
        setup() {
          super.setup();
          if (canPlayHLSNatively(this.video)) {
            new NativeHLSTextTracks(this.video, this.ctx);
          }
          this.ctx.textRenderers.attachVideo(this.video);
          onDispose(() => {
            this.ctx.textRenderers.attachVideo(null);
          });
          if (this.type === "video")
            this.ctx.notify("provider-setup", this);
        }
        /**
         * The native HTML `<video>` element.
         *
         * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLVideoElement}
         */
        get video() {
          return this.media;
        }
      };
    }
  });

  // node_modules/.pnpm/vidstack@1.12.9/node_modules/vidstack/prod/providers/vidstack-hls.js
  var vidstack_hls_exports = {};
  __export(vidstack_hls_exports, {
    HLSProvider: () => HLSProvider
  });
  async function importHLS(loader, callbacks = {}) {
    if (isUndefined(loader))
      return void 0;
    callbacks.onLoadStart?.();
    if (loader.prototype && loader.prototype !== Function) {
      callbacks.onLoaded?.(loader);
      return loader;
    }
    try {
      const ctor = (await loader())?.default;
      if (ctor && !!ctor.isSupported) {
        callbacks.onLoaded?.(ctor);
      } else {
        throw Error(
          false ? "[vidstack] failed importing `hls.js`. Dynamic import returned invalid constructor." : ""
        );
      }
      return ctor;
    } catch (err) {
      callbacks.onLoadError?.(err);
    }
    return void 0;
  }
  async function loadHLSScript(src, callbacks = {}) {
    if (!isString(src))
      return void 0;
    callbacks.onLoadStart?.();
    try {
      await loadScript(src);
      if (!isFunction(window.Hls)) {
        throw Error(
          false ? "[vidstack] failed loading `hls.js`. Could not find a valid `Hls` constructor on window" : ""
        );
      }
      const ctor = window.Hls;
      callbacks.onLoaded?.(ctor);
      return ctor;
    } catch (err) {
      callbacks.onLoadError?.(err);
    }
    return void 0;
  }
  var toDOMEventType, HLSController, HLSLibLoader, JS_DELIVR_CDN, HLSProvider;
  var init_vidstack_hls = __esm({
    "node_modules/.pnpm/vidstack@1.12.9/node_modules/vidstack/prod/providers/vidstack-hls.js"() {
      init_live_reload();
      init_vidstack_vDnjyKV8();
      init_vidstack_DyMkFGuS();
      init_vidstack_video();
      init_vidstack_CRlI3Mh7();
      init_vidstack_B01xzxC4();
      init_vidstack_B5628Ni3();
      init_vidstack_D5EzK014();
      init_vidstack_DSYpsFWk();
      init_vidstack_C9vIqaYT();
      toDOMEventType = (type) => camelToKebabCase(type);
      HLSController = class {
        #video;
        #ctx;
        #instance = null;
        #stopLiveSync = null;
        config = {};
        #callbacks = /* @__PURE__ */ new Set();
        get instance() {
          return this.#instance;
        }
        constructor(video, ctx) {
          this.#video = video;
          this.#ctx = ctx;
        }
        setup(ctor) {
          const { streamType } = this.#ctx.$state;
          const isLive = peek(streamType).includes("live"), isLiveLowLatency = peek(streamType).includes("ll-");
          this.#instance = new ctor({
            lowLatencyMode: isLiveLowLatency,
            backBufferLength: isLiveLowLatency ? 4 : isLive ? 8 : void 0,
            renderTextTracksNatively: false,
            ...this.config
          });
          const dispatcher = this.#dispatchHLSEvent.bind(this);
          for (const event2 of Object.values(ctor.Events))
            this.#instance.on(event2, dispatcher);
          this.#instance.on(ctor.Events.ERROR, this.#onError.bind(this));
          for (const callback of this.#callbacks)
            callback(this.#instance);
          this.#ctx.player.dispatch("hls-instance", {
            detail: this.#instance
          });
          this.#instance.attachMedia(this.#video);
          this.#instance.on(ctor.Events.AUDIO_TRACK_SWITCHED, this.#onAudioSwitch.bind(this));
          this.#instance.on(ctor.Events.LEVEL_SWITCHED, this.#onLevelSwitched.bind(this));
          this.#instance.on(ctor.Events.LEVEL_LOADED, this.#onLevelLoaded.bind(this));
          this.#instance.on(ctor.Events.NON_NATIVE_TEXT_TRACKS_FOUND, this.#onTracksFound.bind(this));
          this.#instance.on(ctor.Events.CUES_PARSED, this.#onCuesParsed.bind(this));
          this.#ctx.qualities[QualitySymbol.enableAuto] = this.#enableAutoQuality.bind(this);
          listenEvent(this.#ctx.qualities, "change", this.#onUserQualityChange.bind(this));
          listenEvent(this.#ctx.audioTracks, "change", this.#onUserAudioChange.bind(this));
          this.#stopLiveSync = effect(this.#liveSync.bind(this));
        }
        #createDOMEvent(type, data) {
          return new DOMEvent(toDOMEventType(type), { detail: data });
        }
        #liveSync() {
          if (!this.#ctx.$state.live())
            return;
          const raf = new RAFLoop(this.#liveSyncPosition.bind(this));
          raf.start();
          return raf.stop.bind(raf);
        }
        #liveSyncPosition() {
          this.#ctx.$state.liveSyncPosition.set(this.#instance?.liveSyncPosition ?? Infinity);
        }
        #dispatchHLSEvent(type, data) {
          this.#ctx.player?.dispatch(this.#createDOMEvent(type, data));
        }
        #onTracksFound(eventType, data) {
          const event2 = this.#createDOMEvent(eventType, data);
          let currentTrack = -1;
          for (let i5 = 0; i5 < data.tracks.length; i5++) {
            const nonNativeTrack = data.tracks[i5], init5 = nonNativeTrack.subtitleTrack ?? nonNativeTrack.closedCaptions, track = new TextTrack({
              id: `hls-${nonNativeTrack.kind}-${i5}`,
              src: init5?.url,
              label: nonNativeTrack.label,
              language: init5?.lang,
              kind: nonNativeTrack.kind,
              default: nonNativeTrack.default
            });
            track[TextTrackSymbol.readyState] = 2;
            track[TextTrackSymbol.onModeChange] = () => {
              if (track.mode === "showing") {
                this.#instance.subtitleTrack = i5;
                currentTrack = i5;
              } else if (currentTrack === i5) {
                this.#instance.subtitleTrack = -1;
                currentTrack = -1;
              }
            };
            this.#ctx.textTracks.add(track, event2);
          }
        }
        #onCuesParsed(eventType, data) {
          const index = this.#instance?.subtitleTrack, track = this.#ctx.textTracks.getById(`hls-${data.type}-${index}`);
          if (!track)
            return;
          const event2 = this.#createDOMEvent(eventType, data);
          for (const cue of data.cues) {
            cue.positionAlign = "auto";
            track.addCue(cue, event2);
          }
        }
        #onAudioSwitch(eventType, data) {
          const track = this.#ctx.audioTracks[data.id];
          if (track) {
            const trigger = this.#createDOMEvent(eventType, data);
            this.#ctx.audioTracks[ListSymbol.select](track, true, trigger);
          }
        }
        #onLevelSwitched(eventType, data) {
          const quality = this.#ctx.qualities[data.level];
          if (quality) {
            const trigger = this.#createDOMEvent(eventType, data);
            this.#ctx.qualities[ListSymbol.select](quality, true, trigger);
          }
        }
        #onLevelLoaded(eventType, data) {
          if (this.#ctx.$state.canPlay())
            return;
          const { type, live, totalduration: duration, targetduration } = data.details, trigger = this.#createDOMEvent(eventType, data);
          this.#ctx.notify(
            "stream-type-change",
            live ? type === "EVENT" && Number.isFinite(duration) && targetduration >= 10 ? "live:dvr" : "live" : "on-demand",
            trigger
          );
          this.#ctx.notify("duration-change", duration, trigger);
          const media = this.#instance.media;
          if (this.#instance.currentLevel === -1) {
            this.#ctx.qualities[QualitySymbol.setAuto](true, trigger);
          }
          for (const remoteTrack of this.#instance.audioTracks) {
            const localTrack = {
              id: remoteTrack.id.toString(),
              label: remoteTrack.name,
              language: remoteTrack.lang || "",
              kind: "main"
            };
            this.#ctx.audioTracks[ListSymbol.add](localTrack, trigger);
          }
          for (const level of this.#instance.levels) {
            const videoQuality = {
              id: level.id?.toString() ?? level.height + "p",
              width: level.width,
              height: level.height,
              codec: level.codecSet,
              bitrate: level.bitrate
            };
            this.#ctx.qualities[ListSymbol.add](videoQuality, trigger);
          }
          media.dispatchEvent(new DOMEvent("canplay", { trigger }));
        }
        #onError(eventType, data) {
          if (data.fatal) {
            switch (data.type) {
              case "mediaError":
                this.#instance?.recoverMediaError();
                break;
              default:
                this.#onFatalError(data.error);
                break;
            }
          }
        }
        #onFatalError(error) {
          this.#ctx.notify("error", {
            message: error.message,
            code: 1,
            error
          });
        }
        #enableAutoQuality() {
          if (this.#instance)
            this.#instance.currentLevel = -1;
        }
        #onUserQualityChange() {
          const { qualities } = this.#ctx;
          if (!this.#instance || qualities.auto)
            return;
          this.#instance[qualities.switch + "Level"] = qualities.selectedIndex;
          if (IS_CHROME) {
            this.#video.currentTime = this.#video.currentTime;
          }
        }
        #onUserAudioChange() {
          const { audioTracks } = this.#ctx;
          if (this.#instance && this.#instance.audioTrack !== audioTracks.selectedIndex) {
            this.#instance.audioTrack = audioTracks.selectedIndex;
          }
        }
        onInstance(callback) {
          this.#callbacks.add(callback);
          return () => this.#callbacks.delete(callback);
        }
        loadSource(src) {
          if (!isString(src.src))
            return;
          this.#instance?.loadSource(src.src);
        }
        destroy() {
          this.#instance?.destroy();
          this.#instance = null;
          this.#stopLiveSync?.();
          this.#stopLiveSync = null;
        }
      };
      HLSLibLoader = class {
        #lib;
        #ctx;
        #callback;
        constructor(lib, ctx, callback) {
          this.#lib = lib;
          this.#ctx = ctx;
          this.#callback = callback;
          this.#startLoading();
        }
        async #startLoading() {
          const callbacks = {
            onLoadStart: this.#onLoadStart.bind(this),
            onLoaded: this.#onLoaded.bind(this),
            onLoadError: this.#onLoadError.bind(this)
          };
          let ctor = await loadHLSScript(this.#lib, callbacks);
          if (isUndefined(ctor) && !isString(this.#lib))
            ctor = await importHLS(this.#lib, callbacks);
          if (!ctor)
            return null;
          if (!ctor.isSupported()) {
            const message = "[vidstack] `hls.js` is not supported in this environment";
            this.#ctx.player.dispatch(new DOMEvent("hls-unsupported"));
            this.#ctx.notify("error", { message, code: 4 });
            return null;
          }
          return ctor;
        }
        #onLoadStart() {
          this.#ctx.player.dispatch(new DOMEvent("hls-lib-load-start"));
        }
        #onLoaded(ctor) {
          this.#ctx.player.dispatch(
            new DOMEvent("hls-lib-loaded", {
              detail: ctor
            })
          );
          this.#callback(ctor);
        }
        #onLoadError(e8) {
          const error = coerceToError(e8);
          this.#ctx.player.dispatch(
            new DOMEvent("hls-lib-load-error", {
              detail: error
            })
          );
          this.#ctx.notify("error", {
            message: error.message,
            code: 4,
            error
          });
        }
      };
      JS_DELIVR_CDN = "https://cdn.jsdelivr.net";
      HLSProvider = class extends VideoProvider {
        $$PROVIDER_TYPE = "HLS";
        #ctor = null;
        #controller = new HLSController(this.video, this.ctx);
        /**
         * The `hls.js` constructor.
         */
        get ctor() {
          return this.#ctor;
        }
        /**
         * The current `hls.js` instance.
         */
        get instance() {
          return this.#controller.instance;
        }
        /**
         * Whether `hls.js` is supported in this environment.
         */
        static supported = isHLSSupported();
        get type() {
          return "hls";
        }
        get canLiveSync() {
          return true;
        }
        #library = `${JS_DELIVR_CDN}/npm/hls.js@^1.5.0/dist/hls${".min.js"}`;
        /**
         * The `hls.js` configuration object.
         *
         * @see {@link https://github.com/video-dev/hls.js/blob/master/docs/API.md#fine-tuning}
         */
        get config() {
          return this.#controller.config;
        }
        set config(config3) {
          this.#controller.config = config3;
        }
        /**
         * The `hls.js` constructor (supports dynamic imports) or a URL of where it can be found.
         *
         * @defaultValue `https://cdn.jsdelivr.net/npm/hls.js@^1.0.0/dist/hls.min.js`
         */
        get library() {
          return this.#library;
        }
        set library(library) {
          this.#library = library;
        }
        preconnect() {
          if (!isString(this.#library))
            return;
          preconnect(this.#library);
        }
        setup() {
          super.setup();
          new HLSLibLoader(this.#library, this.ctx, (ctor) => {
            this.#ctor = ctor;
            this.#controller.setup(ctor);
            this.ctx.notify("provider-setup", this);
            const src = peek(this.ctx.$state.source);
            if (src)
              this.loadSource(src);
          });
        }
        async loadSource(src, preload2) {
          if (!isString(src.src)) {
            this.removeSource();
            return;
          }
          this.media.preload = preload2 || "";
          this.appendSource(src, "application/x-mpegurl");
          this.#controller.loadSource(src);
          this.currentSrc = src;
        }
        /**
         * The given callback is invoked when a new `hls.js` instance is created and right before it's
         * attached to media.
         */
        onInstance(callback) {
          const instance = this.#controller.instance;
          if (instance)
            callback(instance);
          return this.#controller.onInstance(callback);
        }
        destroy() {
          this.#controller.destroy();
        }
      };
    }
  });

  // node_modules/.pnpm/vidstack@1.12.9/node_modules/vidstack/prod/providers/vidstack-dash.js
  var vidstack_dash_exports = {};
  __export(vidstack_dash_exports, {
    DASHProvider: () => DASHProvider
  });
  function getLangName(langCode) {
    try {
      const displayNames = new Intl.DisplayNames(navigator.languages, { type: "language" });
      const languageName = displayNames.of(langCode);
      return languageName ?? null;
    } catch (err) {
      return null;
    }
  }
  async function importDASH(loader, callbacks = {}) {
    if (isUndefined(loader))
      return void 0;
    callbacks.onLoadStart?.();
    if (isDASHConstructor(loader)) {
      callbacks.onLoaded?.(loader);
      return loader;
    }
    if (isDASHNamespace(loader)) {
      const ctor = loader.MediaPlayer;
      callbacks.onLoaded?.(ctor);
      return ctor;
    }
    try {
      const ctor = (await loader())?.default;
      if (isDASHNamespace(ctor)) {
        callbacks.onLoaded?.(ctor.MediaPlayer);
        return ctor.MediaPlayer;
      }
      if (ctor) {
        callbacks.onLoaded?.(ctor);
      } else {
        throw Error(
          false ? "[vidstack] failed importing `dash.js`. Dynamic import returned invalid object." : ""
        );
      }
      return ctor;
    } catch (err) {
      callbacks.onLoadError?.(err);
    }
    return void 0;
  }
  async function loadDASHScript(src, callbacks = {}) {
    if (!isString(src))
      return void 0;
    callbacks.onLoadStart?.();
    try {
      await loadScript(src);
      if (!isFunction(window.dashjs.MediaPlayer)) {
        throw Error(
          false ? "[vidstack] failed loading `dash.js`. Could not find a valid `Dash` constructor on window" : ""
        );
      }
      const ctor = window.dashjs.MediaPlayer;
      callbacks.onLoaded?.(ctor);
      return ctor;
    } catch (err) {
      callbacks.onLoadError?.(err);
    }
    return void 0;
  }
  function isDASHConstructor(value) {
    return value && value.prototype && value.prototype !== Function;
  }
  function isDASHNamespace(value) {
    return value && "MediaPlayer" in value;
  }
  var toDOMEventType2, DASHController, DASHLibLoader, JS_DELIVR_CDN2, DASHProvider;
  var init_vidstack_dash = __esm({
    "node_modules/.pnpm/vidstack@1.12.9/node_modules/vidstack/prod/providers/vidstack-dash.js"() {
      init_live_reload();
      init_vidstack_vDnjyKV8();
      init_vidstack_DyMkFGuS();
      init_vidstack_video();
      init_vidstack_CRlI3Mh7();
      init_vidstack_B01xzxC4();
      init_vidstack_B5628Ni3();
      init_vidstack_D5EzK014();
      init_vidstack_DSYpsFWk();
      init_vidstack_C9vIqaYT();
      toDOMEventType2 = (type) => `dash-${camelToKebabCase(type)}`;
      DASHController = class {
        #video;
        #ctx;
        #instance = null;
        #callbacks = /* @__PURE__ */ new Set();
        #stopLiveSync = null;
        config = {};
        get instance() {
          return this.#instance;
        }
        constructor(video, ctx) {
          this.#video = video;
          this.#ctx = ctx;
        }
        setup(ctor) {
          this.#instance = ctor().create();
          const dispatcher = this.#dispatchDASHEvent.bind(this);
          for (const event2 of Object.values(ctor.events))
            this.#instance.on(event2, dispatcher);
          this.#instance.on(ctor.events.ERROR, this.#onError.bind(this));
          for (const callback of this.#callbacks)
            callback(this.#instance);
          this.#ctx.player.dispatch("dash-instance", {
            detail: this.#instance
          });
          this.#instance.initialize(this.#video, void 0, false);
          this.#instance.updateSettings({
            streaming: {
              text: {
                // Disabling text rendering by dash.
                defaultEnabled: false,
                dispatchForManualRendering: true
              },
              buffer: {
                /// Enables buffer replacement when switching bitrates for faster switching.
                fastSwitchEnabled: true
              }
            },
            ...this.config
          });
          this.#instance.on(ctor.events.FRAGMENT_LOADING_STARTED, this.#onFragmentLoadStart.bind(this));
          this.#instance.on(
            ctor.events.FRAGMENT_LOADING_COMPLETED,
            this.#onFragmentLoadComplete.bind(this)
          );
          this.#instance.on(ctor.events.MANIFEST_LOADED, this.#onManifestLoaded.bind(this));
          this.#instance.on(ctor.events.QUALITY_CHANGE_RENDERED, this.#onQualityChange.bind(this));
          this.#instance.on(ctor.events.TEXT_TRACKS_ADDED, this.#onTextTracksAdded.bind(this));
          this.#instance.on(ctor.events.TRACK_CHANGE_RENDERED, this.#onTrackChange.bind(this));
          this.#ctx.qualities[QualitySymbol.enableAuto] = this.#enableAutoQuality.bind(this);
          listenEvent(this.#ctx.qualities, "change", this.#onUserQualityChange.bind(this));
          listenEvent(this.#ctx.audioTracks, "change", this.#onUserAudioChange.bind(this));
          this.#stopLiveSync = effect(this.#liveSync.bind(this));
        }
        #createDOMEvent(event2) {
          return new DOMEvent(toDOMEventType2(event2.type), { detail: event2 });
        }
        #liveSync() {
          if (!this.#ctx.$state.live())
            return;
          const raf = new RAFLoop(this.#liveSyncPosition.bind(this));
          raf.start();
          return raf.stop.bind(raf);
        }
        #liveSyncPosition() {
          if (!this.#instance)
            return;
          const position = this.#instance.duration() - this.#instance.time();
          this.#ctx.$state.liveSyncPosition.set(!isNaN(position) ? position : Infinity);
        }
        #dispatchDASHEvent(event2) {
          this.#ctx.player?.dispatch(this.#createDOMEvent(event2));
        }
        #currentTrack = null;
        #cueTracker = {};
        #onTextFragmentLoaded(event2) {
          const native = this.#currentTrack?.[TextTrackSymbol.native], cues = (native?.track).cues;
          if (!native || !cues)
            return;
          const id = this.#currentTrack.id, startIndex = this.#cueTracker[id] ?? 0, trigger = this.#createDOMEvent(event2);
          for (let i5 = startIndex; i5 < cues.length; i5++) {
            const cue = cues[i5];
            if (!cue.positionAlign)
              cue.positionAlign = "auto";
            this.#currentTrack.addCue(cue, trigger);
          }
          this.#cueTracker[id] = cues.length;
        }
        #onTextTracksAdded(event2) {
          if (!this.#instance)
            return;
          const data = event2.tracks, nativeTextTracks = [...this.#video.textTracks].filter((track) => "manualMode" in track), trigger = this.#createDOMEvent(event2);
          for (let i5 = 0; i5 < nativeTextTracks.length; i5++) {
            const textTrackInfo = data[i5], nativeTextTrack = nativeTextTracks[i5];
            const id = `dash-${textTrackInfo.kind}-${i5}`, track = new TextTrack({
              id,
              label: textTrackInfo?.label ?? textTrackInfo.labels.find((t6) => t6.text)?.text ?? (textTrackInfo?.lang && getLangName(textTrackInfo.lang)) ?? textTrackInfo?.lang ?? void 0,
              language: textTrackInfo.lang ?? void 0,
              kind: textTrackInfo.kind,
              default: textTrackInfo.defaultTrack
            });
            track[TextTrackSymbol.native] = {
              managed: true,
              track: nativeTextTrack
            };
            track[TextTrackSymbol.readyState] = 2;
            track[TextTrackSymbol.onModeChange] = () => {
              if (!this.#instance)
                return;
              if (track.mode === "showing") {
                this.#instance.setTextTrack(i5);
                this.#currentTrack = track;
              } else {
                this.#instance.setTextTrack(-1);
                this.#currentTrack = null;
              }
            };
            this.#ctx.textTracks.add(track, trigger);
          }
        }
        #onTrackChange(event2) {
          const { mediaType, newMediaInfo } = event2;
          if (mediaType === "audio") {
            const track = this.#ctx.audioTracks.getById(`dash-audio-${newMediaInfo.index}`);
            if (track) {
              const trigger = this.#createDOMEvent(event2);
              this.#ctx.audioTracks[ListSymbol.select](track, true, trigger);
            }
          }
        }
        #onQualityChange(event2) {
          if (event2.mediaType !== "video")
            return;
          const quality = this.#ctx.qualities[event2.newQuality];
          if (quality) {
            const trigger = this.#createDOMEvent(event2);
            this.#ctx.qualities[ListSymbol.select](quality, true, trigger);
          }
        }
        #onManifestLoaded(event2) {
          if (this.#ctx.$state.canPlay() || !this.#instance)
            return;
          const { type, mediaPresentationDuration } = event2.data, trigger = this.#createDOMEvent(event2);
          this.#ctx.notify("stream-type-change", type !== "static" ? "live" : "on-demand", trigger);
          this.#ctx.notify("duration-change", mediaPresentationDuration, trigger);
          this.#ctx.qualities[QualitySymbol.setAuto](true, trigger);
          const media = this.#instance.getVideoElement();
          const videoQualities = this.#instance.getTracksForTypeFromManifest(
            "video",
            event2.data
          );
          const supportedVideoMimeType = [...new Set(videoQualities.map((e8) => e8.mimeType))].find(
            (type2) => type2 && canPlayVideoType(media, type2)
          );
          const videoQuality = videoQualities.filter(
            (track) => supportedVideoMimeType === track.mimeType
          )[0];
          let audioTracks = this.#instance.getTracksForTypeFromManifest(
            "audio",
            event2.data
          );
          const supportedAudioMimeType = [...new Set(audioTracks.map((e8) => e8.mimeType))].find(
            (type2) => type2 && canPlayAudioType(media, type2)
          );
          audioTracks = audioTracks.filter((track) => supportedAudioMimeType === track.mimeType);
          videoQuality.bitrateList.forEach((bitrate, index) => {
            const quality = {
              id: bitrate.id?.toString() ?? `dash-bitrate-${index}`,
              width: bitrate.width ?? 0,
              height: bitrate.height ?? 0,
              bitrate: bitrate.bandwidth ?? 0,
              codec: videoQuality.codec,
              index
            };
            this.#ctx.qualities[ListSymbol.add](quality, trigger);
          });
          if (isNumber(videoQuality.index)) {
            const quality = this.#ctx.qualities[videoQuality.index];
            if (quality)
              this.#ctx.qualities[ListSymbol.select](quality, true, trigger);
          }
          audioTracks.forEach((audioTrack, index) => {
            const matchingLabel = audioTrack.labels.find((label2) => {
              return navigator.languages.some((language) => {
                return label2.lang && language.toLowerCase().startsWith(label2.lang.toLowerCase());
              });
            });
            const label = matchingLabel || audioTrack.labels[0];
            const localTrack = {
              id: `dash-audio-${audioTrack?.index}`,
              label: label?.text ?? (audioTrack.lang && getLangName(audioTrack.lang)) ?? audioTrack.lang ?? "",
              language: audioTrack.lang ?? "",
              kind: "main",
              mimeType: audioTrack.mimeType,
              codec: audioTrack.codec,
              index
            };
            this.#ctx.audioTracks[ListSymbol.add](localTrack, trigger);
          });
          media.dispatchEvent(new DOMEvent("canplay", { trigger }));
        }
        #onError(event2) {
          const { type: eventType, error: data } = event2;
          switch (data.code) {
            case 27:
              this.#onNetworkError(data);
              break;
            default:
              this.#onFatalError(data);
              break;
          }
        }
        #onFragmentLoadStart() {
          if (this.#retryLoadingTimer >= 0)
            this.#clearRetryTimer();
        }
        #onFragmentLoadComplete(event2) {
          const mediaType = event2.mediaType;
          if (mediaType === "text") {
            requestAnimationFrame(this.#onTextFragmentLoaded.bind(this, event2));
          }
        }
        #retryLoadingTimer = -1;
        #onNetworkError(error) {
          this.#clearRetryTimer();
          this.#instance?.play();
          this.#retryLoadingTimer = window.setTimeout(() => {
            this.#retryLoadingTimer = -1;
            this.#onFatalError(error);
          }, 5e3);
        }
        #clearRetryTimer() {
          clearTimeout(this.#retryLoadingTimer);
          this.#retryLoadingTimer = -1;
        }
        #onFatalError(error) {
          this.#ctx.notify("error", {
            message: error.message ?? "",
            code: 1,
            error
          });
        }
        #enableAutoQuality() {
          this.#switchAutoBitrate("video", true);
          const { qualities } = this.#ctx;
          this.#instance?.setQualityFor("video", qualities.selectedIndex, true);
        }
        #switchAutoBitrate(type, auto) {
          this.#instance?.updateSettings({
            streaming: { abr: { autoSwitchBitrate: { [type]: auto } } }
          });
        }
        #onUserQualityChange() {
          const { qualities } = this.#ctx;
          if (!this.#instance || qualities.auto || !qualities.selected)
            return;
          this.#switchAutoBitrate("video", false);
          this.#instance.setQualityFor("video", qualities.selectedIndex, qualities.switch === "current");
          if (IS_CHROME) {
            this.#video.currentTime = this.#video.currentTime;
          }
        }
        #onUserAudioChange() {
          if (!this.#instance)
            return;
          const { audioTracks } = this.#ctx, selectedTrack = this.#instance.getTracksFor("audio").find(
            (track) => audioTracks.selected && audioTracks.selected.id === `dash-audio-${track.index}`
          );
          if (selectedTrack)
            this.#instance.setCurrentTrack(selectedTrack);
        }
        #reset() {
          this.#clearRetryTimer();
          this.#currentTrack = null;
          this.#cueTracker = {};
        }
        onInstance(callback) {
          this.#callbacks.add(callback);
          return () => this.#callbacks.delete(callback);
        }
        loadSource(src) {
          this.#reset();
          if (!isString(src.src))
            return;
          this.#instance?.attachSource(src.src);
        }
        destroy() {
          this.#reset();
          this.#instance?.destroy();
          this.#instance = null;
          this.#stopLiveSync?.();
          this.#stopLiveSync = null;
        }
      };
      DASHLibLoader = class {
        #lib;
        #ctx;
        #callback;
        constructor(lib, ctx, callback) {
          this.#lib = lib;
          this.#ctx = ctx;
          this.#callback = callback;
          this.#startLoading();
        }
        async #startLoading() {
          const callbacks = {
            onLoadStart: this.#onLoadStart.bind(this),
            onLoaded: this.#onLoaded.bind(this),
            onLoadError: this.#onLoadError.bind(this)
          };
          let ctor = await loadDASHScript(this.#lib, callbacks);
          if (isUndefined(ctor) && !isString(this.#lib))
            ctor = await importDASH(this.#lib, callbacks);
          if (!ctor)
            return null;
          if (!window.dashjs.supportsMediaSource()) {
            const message = "[vidstack] `dash.js` is not supported in this environment";
            this.#ctx.player.dispatch(new DOMEvent("dash-unsupported"));
            this.#ctx.notify("error", { message, code: 4 });
            return null;
          }
          return ctor;
        }
        #onLoadStart() {
          this.#ctx.player.dispatch(new DOMEvent("dash-lib-load-start"));
        }
        #onLoaded(ctor) {
          this.#ctx.player.dispatch(
            new DOMEvent("dash-lib-loaded", {
              detail: ctor
            })
          );
          this.#callback(ctor);
        }
        #onLoadError(e8) {
          const error = coerceToError(e8);
          this.#ctx.player.dispatch(
            new DOMEvent("dash-lib-load-error", {
              detail: error
            })
          );
          this.#ctx.notify("error", {
            message: error.message,
            code: 4,
            error
          });
        }
      };
      JS_DELIVR_CDN2 = "https://cdn.jsdelivr.net";
      DASHProvider = class extends VideoProvider {
        $$PROVIDER_TYPE = "DASH";
        #ctor = null;
        #controller = new DASHController(this.video, this.ctx);
        /**
         * The `dash.js` constructor.
         */
        get ctor() {
          return this.#ctor;
        }
        /**
         * The current `dash.js` instance.
         */
        get instance() {
          return this.#controller.instance;
        }
        /**
         * Whether `dash.js` is supported in this environment.
         */
        static supported = isDASHSupported();
        get type() {
          return "dash";
        }
        get canLiveSync() {
          return true;
        }
        #library = `${JS_DELIVR_CDN2}/npm/dashjs@4.7.4/dist/dash${".all.min.js"}`;
        /**
         * The `dash.js` configuration object.
         *
         * @see {@link https://cdn.dashjs.org/latest/jsdoc/module-Settings.html}
         */
        get config() {
          return this.#controller.config;
        }
        set config(config3) {
          this.#controller.config = config3;
        }
        /**
         * The `dash.js` constructor (supports dynamic imports) or a URL of where it can be found.
         *
         * @defaultValue `https://cdn.jsdelivr.net/npm/dashjs@4.7.4/dist/dash.all.min.js`
         */
        get library() {
          return this.#library;
        }
        set library(library) {
          this.#library = library;
        }
        preconnect() {
          if (!isString(this.#library))
            return;
          preconnect(this.#library);
        }
        setup() {
          super.setup();
          new DASHLibLoader(this.#library, this.ctx, (ctor) => {
            this.#ctor = ctor;
            this.#controller.setup(ctor);
            this.ctx.notify("provider-setup", this);
            const src = peek(this.ctx.$state.source);
            if (src)
              this.loadSource(src);
          });
        }
        async loadSource(src, preload2) {
          if (!isString(src.src)) {
            this.removeSource();
            return;
          }
          this.media.preload = preload2 || "";
          this.appendSource(src, "application/x-mpegurl");
          this.#controller.loadSource(src);
          this.currentSrc = src;
        }
        /**
         * The given callback is invoked when a new `dash.js` instance is created and right before it's
         * attached to media.
         */
        onInstance(callback) {
          const instance = this.#controller.instance;
          if (instance)
            callback(instance);
          return this.#controller.onInstance(callback);
        }
        destroy() {
          this.#controller.destroy();
        }
      };
    }
  });

  // node_modules/.pnpm/vidstack@1.12.9/node_modules/vidstack/prod/chunks/vidstack-BSPPDWLF.js
  var EmbedProvider;
  var init_vidstack_BSPPDWLF = __esm({
    "node_modules/.pnpm/vidstack@1.12.9/node_modules/vidstack/prod/chunks/vidstack-BSPPDWLF.js"() {
      init_live_reload();
      init_vidstack_CRlI3Mh7();
      init_vidstack_vDnjyKV8();
      EmbedProvider = class {
        #iframe;
        src = signal("");
        /**
         * Defines which referrer is sent when fetching the resource.
         *
         * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLIFrameElement/referrerPolicy}
         */
        referrerPolicy = null;
        get iframe() {
          return this.#iframe;
        }
        constructor(iframe) {
          this.#iframe = iframe;
          iframe.setAttribute("frameBorder", "0");
          iframe.setAttribute("aria-hidden", "true");
          iframe.setAttribute(
            "allow",
            "autoplay; fullscreen; encrypted-media; picture-in-picture; accelerometer; gyroscope"
          );
          if (this.referrerPolicy !== null) {
            iframe.setAttribute("referrerpolicy", this.referrerPolicy);
          }
        }
        setup() {
          listenEvent(window, "message", this.#onWindowMessage.bind(this));
          listenEvent(this.#iframe, "load", this.onLoad.bind(this));
          effect(this.#watchSrc.bind(this));
        }
        #watchSrc() {
          const src = this.src();
          if (!src.length) {
            this.#iframe.setAttribute("src", "");
            return;
          }
          const params = peek(() => this.buildParams());
          this.#iframe.setAttribute("src", appendParamsToURL(src, params));
        }
        postMessage(message, target) {
          this.#iframe.contentWindow?.postMessage(JSON.stringify(message), target ?? "*");
        }
        #onWindowMessage(event2) {
          const origin = this.getOrigin(), isOriginMatch = (event2.source === null || event2.source === this.#iframe?.contentWindow) && (!isString(origin) || origin === event2.origin);
          if (!isOriginMatch)
            return;
          try {
            const message = JSON.parse(event2.data);
            if (message)
              this.onMessage(message, event2);
            return;
          } catch (e8) {
          }
          if (event2.data)
            this.onMessage(event2.data, event2);
        }
      };
    }
  });

  // node_modules/.pnpm/vidstack@1.12.9/node_modules/vidstack/prod/chunks/vidstack-krOAtKMi.js
  var vidstack_krOAtKMi_exports = {};
  __export(vidstack_krOAtKMi_exports, {
    getVimeoVideoInfo: () => getVimeoVideoInfo,
    resolveVimeoVideoId: () => resolveVimeoVideoId
  });
  function resolveVimeoVideoId(src) {
    const matches = src.match(videoIdRE);
    return { videoId: matches?.[1], hash: matches?.[2] };
  }
  async function getVimeoVideoInfo(videoId, abort, videoHash) {
    if (infoCache.has(videoId))
      return infoCache.get(videoId);
    if (pendingFetch.has(videoId))
      return pendingFetch.get(videoId);
    let oembedSrc = `https://vimeo.com/api/oembed.json?url=https://player.vimeo.com/video/${videoId}`;
    if (videoHash) {
      oembedSrc = oembedSrc.concat(`?h=${videoHash}`);
    }
    const promise = window.fetch(oembedSrc, {
      mode: "cors",
      signal: abort.signal
    }).then((response) => response.json()).then((data) => {
      const thumnailRegex = /vimeocdn.com\/video\/(.*)?_/, thumbnailId = data?.thumbnail_url?.match(thumnailRegex)?.[1], poster = thumbnailId ? `https://i.vimeocdn.com/video/${thumbnailId}_1920x1080.webp` : "", info = {
        title: data?.title ?? "",
        duration: data?.duration ?? 0,
        poster,
        pro: data.account_type !== "basic"
      };
      infoCache.set(videoId, info);
      return info;
    }).finally(() => pendingFetch.delete(videoId));
    pendingFetch.set(videoId, promise);
    return promise;
  }
  var videoIdRE, infoCache, pendingFetch;
  var init_vidstack_krOAtKMi = __esm({
    "node_modules/.pnpm/vidstack@1.12.9/node_modules/vidstack/prod/chunks/vidstack-krOAtKMi.js"() {
      init_live_reload();
      videoIdRE = /(?:https:\/\/)?(?:player\.)?vimeo(?:\.com)?\/(?:video\/)?(\d+)(?:(?:\?hash=|\?h=|\/)(.*))?/;
      infoCache = /* @__PURE__ */ new Map();
      pendingFetch = /* @__PURE__ */ new Map();
    }
  });

  // node_modules/.pnpm/vidstack@1.12.9/node_modules/vidstack/prod/providers/vidstack-vimeo.js
  var vidstack_vimeo_exports = {};
  __export(vidstack_vimeo_exports, {
    VimeoProvider: () => VimeoProvider
  });
  var trackedVimeoEvents, VimeoProvider;
  var init_vidstack_vimeo = __esm({
    "node_modules/.pnpm/vidstack@1.12.9/node_modules/vidstack/prod/providers/vidstack-vimeo.js"() {
      init_live_reload();
      init_vidstack_CRlI3Mh7();
      init_vidstack_B01xzxC4();
      init_vidstack_BmMUBVGQ();
      init_vidstack_B5628Ni3();
      init_vidstack_D5EzK014();
      init_vidstack_DSYpsFWk();
      init_vidstack_vDnjyKV8();
      init_vidstack_BSPPDWLF();
      init_vidstack_krOAtKMi();
      trackedVimeoEvents = [
        "bufferend",
        "bufferstart",
        // 'cuechange',
        "durationchange",
        "ended",
        "enterpictureinpicture",
        "error",
        "fullscreenchange",
        "leavepictureinpicture",
        "loaded",
        // 'loadeddata',
        // 'loadedmetadata',
        // 'loadstart',
        "playProgress",
        "loadProgress",
        "pause",
        "play",
        "playbackratechange",
        // 'progress',
        "qualitychange",
        "seeked",
        "seeking",
        // 'texttrackchange',
        "timeupdate",
        "volumechange",
        "waiting"
        // 'adstarted',
        // 'adcompleted',
        // 'aderror',
        // 'adskipped',
        // 'adallcompleted',
        // 'adclicked',
        // 'chapterchange',
        // 'chromecastconnected',
        // 'remoteplaybackavailabilitychange',
        // 'remoteplaybackconnecting',
        // 'remoteplaybackconnect',
        // 'remoteplaybackdisconnect',
        // 'liveeventended',
        // 'liveeventstarted',
        // 'livestreamoffline',
        // 'livestreamonline',
      ];
      VimeoProvider = class extends EmbedProvider {
        $$PROVIDER_TYPE = "VIMEO";
        scope = createScope();
        fullscreen;
        #ctx;
        #videoId = signal("");
        #pro = signal(false);
        #hash = null;
        #currentSrc = null;
        #fullscreenActive = false;
        #seekableRange = new TimeRange(0, 0);
        #timeRAF = new RAFLoop(this.#onAnimationFrame.bind(this));
        #currentCue = null;
        #chaptersTrack = null;
        #promises = /* @__PURE__ */ new Map();
        #videoInfoPromise = null;
        constructor(iframe, ctx) {
          super(iframe);
          this.#ctx = ctx;
          const self = this;
          this.fullscreen = {
            get active() {
              return self.#fullscreenActive;
            },
            supported: true,
            enter: () => this.#remote("requestFullscreen"),
            exit: () => this.#remote("exitFullscreen")
          };
        }
        /**
         * Whether tracking session data should be enabled on the embed, including cookies and analytics.
         * This is turned off by default to be GDPR-compliant.
         *
         * @defaultValue `false`
         */
        cookies = false;
        title = true;
        byline = true;
        portrait = true;
        color = "00ADEF";
        get type() {
          return "vimeo";
        }
        get currentSrc() {
          return this.#currentSrc;
        }
        get videoId() {
          return this.#videoId();
        }
        get hash() {
          return this.#hash;
        }
        get isPro() {
          return this.#pro();
        }
        preconnect() {
          preconnect(this.getOrigin());
        }
        setup() {
          super.setup();
          effect(this.#watchVideoId.bind(this));
          effect(this.#watchVideoInfo.bind(this));
          effect(this.#watchPro.bind(this));
          this.#ctx.notify("provider-setup", this);
        }
        destroy() {
          this.#reset();
          this.fullscreen = void 0;
          const message = "provider destroyed";
          for (const promises of this.#promises.values()) {
            for (const { reject } of promises)
              reject(message);
          }
          this.#promises.clear();
          this.#remote("destroy");
        }
        async play() {
          return this.#remote("play");
        }
        async pause() {
          return this.#remote("pause");
        }
        setMuted(muted) {
          this.#remote("setMuted", muted);
        }
        setCurrentTime(time) {
          this.#remote("seekTo", time);
          this.#ctx.notify("seeking", time);
        }
        setVolume(volume) {
          this.#remote("setVolume", volume);
          this.#remote("setMuted", peek(this.#ctx.$state.muted));
        }
        setPlaybackRate(rate) {
          this.#remote("setPlaybackRate", rate);
        }
        async loadSource(src) {
          if (!isString(src.src)) {
            this.#currentSrc = null;
            this.#hash = null;
            this.#videoId.set("");
            return;
          }
          const { videoId, hash } = resolveVimeoVideoId(src.src);
          this.#videoId.set(videoId ?? "");
          this.#hash = hash ?? null;
          this.#currentSrc = src;
        }
        #watchVideoId() {
          this.#reset();
          const videoId = this.#videoId();
          if (!videoId) {
            this.src.set("");
            return;
          }
          this.src.set(`${this.getOrigin()}/video/${videoId}`);
          this.#ctx.notify("load-start");
        }
        #watchVideoInfo() {
          const videoId = this.#videoId();
          if (!videoId)
            return;
          const promise = deferredPromise(), abort = new AbortController();
          this.#videoInfoPromise = promise;
          getVimeoVideoInfo(videoId, abort, this.#hash).then((info) => {
            promise.resolve(info);
          }).catch((e8) => {
            promise.reject();
          });
          return () => {
            promise.reject();
            abort.abort();
          };
        }
        #watchPro() {
          const isPro = this.#pro(), { $state, qualities } = this.#ctx;
          $state.canSetPlaybackRate.set(isPro);
          qualities[ListSymbol.setReadonly](!isPro);
          if (isPro) {
            return listenEvent(qualities, "change", () => {
              if (qualities.auto)
                return;
              const id = qualities.selected?.id;
              if (id)
                this.#remote("setQuality", id);
            });
          }
        }
        getOrigin() {
          return "https://player.vimeo.com";
        }
        buildParams() {
          const { keyDisabled } = this.#ctx.$props, { playsInline, nativeControls } = this.#ctx.$state, showControls = nativeControls();
          return {
            title: this.title,
            byline: this.byline,
            color: this.color,
            portrait: this.portrait,
            controls: showControls,
            h: this.hash,
            keyboard: showControls && !keyDisabled(),
            transparent: true,
            playsinline: playsInline(),
            dnt: !this.cookies
          };
        }
        #onAnimationFrame() {
          this.#remote("getCurrentTime");
        }
        // Embed will sometimes dispatch 0 at end of playback.
        #preventTimeUpdates = false;
        #onTimeUpdate(time, trigger) {
          if (this.#preventTimeUpdates && time === 0)
            return;
          const { realCurrentTime, realDuration, paused, bufferedEnd } = this.#ctx.$state;
          if (realCurrentTime() === time)
            return;
          const prevTime = realCurrentTime();
          this.#ctx.notify("time-change", time, trigger);
          if (Math.abs(prevTime - time) > 1.5) {
            this.#ctx.notify("seeking", time, trigger);
            if (!paused() && bufferedEnd() < time) {
              this.#ctx.notify("waiting", void 0, trigger);
            }
          }
          if (realDuration() - time < 0.01) {
            this.#ctx.notify("end", void 0, trigger);
            this.#preventTimeUpdates = true;
            setTimeout(() => {
              this.#preventTimeUpdates = false;
            }, 500);
          }
        }
        #onSeeked(time, trigger) {
          this.#ctx.notify("seeked", time, trigger);
        }
        #onLoaded(trigger) {
          const videoId = this.#videoId();
          this.#videoInfoPromise?.promise.then((info) => {
            if (!info)
              return;
            const { title, poster, duration, pro } = info;
            this.#pro.set(pro);
            this.#ctx.notify("title-change", title, trigger);
            this.#ctx.notify("poster-change", poster, trigger);
            this.#ctx.notify("duration-change", duration, trigger);
            this.#onReady(duration, trigger);
          }).catch(() => {
            if (videoId !== this.#videoId())
              return;
            this.#remote("getVideoTitle");
            this.#remote("getDuration");
          });
        }
        #onReady(duration, trigger) {
          const { nativeControls } = this.#ctx.$state, showEmbedControls = nativeControls();
          this.#seekableRange = new TimeRange(0, duration);
          const detail = {
            buffered: new TimeRange(0, 0),
            seekable: this.#seekableRange,
            duration
          };
          this.#ctx.delegate.ready(detail, trigger);
          if (!showEmbedControls) {
            this.#remote("_hideOverlay");
          }
          this.#remote("getQualities");
          this.#remote("getChapters");
        }
        #onMethod(method2, data, trigger) {
          switch (method2) {
            case "getVideoTitle":
              const videoTitle = data;
              this.#ctx.notify("title-change", videoTitle, trigger);
              break;
            case "getDuration":
              const duration = data;
              if (!this.#ctx.$state.canPlay()) {
                this.#onReady(duration, trigger);
              } else {
                this.#ctx.notify("duration-change", duration, trigger);
              }
              break;
            case "getCurrentTime":
              this.#onTimeUpdate(data, trigger);
              break;
            case "getBuffered":
              if (isArray(data) && data.length) {
                this.#onLoadProgress(data[data.length - 1][1], trigger);
              }
              break;
            case "setMuted":
              this.#onVolumeChange(peek(this.#ctx.$state.volume), data, trigger);
              break;
            case "getChapters":
              this.#onChaptersChange(data);
              break;
            case "getQualities":
              this.#onQualitiesChange(data, trigger);
              break;
          }
          this.#getPromise(method2)?.resolve();
        }
        #attachListeners() {
          for (const type of trackedVimeoEvents) {
            this.#remote("addEventListener", type);
          }
        }
        #onPause(trigger) {
          this.#timeRAF.stop();
          this.#ctx.notify("pause", void 0, trigger);
        }
        #onPlay(trigger) {
          this.#timeRAF.start();
          this.#ctx.notify("play", void 0, trigger);
        }
        #onPlayProgress(trigger) {
          const { paused } = this.#ctx.$state;
          if (!paused() && !this.#preventTimeUpdates) {
            this.#ctx.notify("playing", void 0, trigger);
          }
        }
        #onLoadProgress(buffered, trigger) {
          const detail = {
            buffered: new TimeRange(0, buffered),
            seekable: this.#seekableRange
          };
          this.#ctx.notify("progress", detail, trigger);
        }
        #onBufferStart(trigger) {
          this.#ctx.notify("waiting", void 0, trigger);
        }
        #onBufferEnd(trigger) {
          const { paused } = this.#ctx.$state;
          if (!paused())
            this.#ctx.notify("playing", void 0, trigger);
        }
        #onWaiting(trigger) {
          const { paused } = this.#ctx.$state;
          if (paused()) {
            this.#ctx.notify("play", void 0, trigger);
          }
          this.#ctx.notify("waiting", void 0, trigger);
        }
        #onVolumeChange(volume, muted, trigger) {
          const detail = { volume, muted };
          this.#ctx.notify("volume-change", detail, trigger);
        }
        // #onTextTrackChange(track: VimeoTextTrack, trigger: Event) {
        //   const textTrack = this.#ctx.textTracks.toArray().find((t) => t.language === track.language);
        //   if (textTrack) textTrack.mode = track.mode;
        // }
        // #onTextTracksChange(tracks: VimeoTextTrack[], trigger: Event) {
        //   for (const init of tracks) {
        //     const textTrack = new TextTrack({
        //       ...init,
        //       label: init.label.replace('auto-generated', 'auto'),
        //     });
        //     textTrack[TextTrackSymbol.readyState] = 2;
        //     this.#ctx.textTracks.add(textTrack, trigger);
        //     textTrack.setMode(init.mode, trigger);
        //   }
        // }
        // #onCueChange(cue: VimeoTextCue, trigger: Event) {
        //   const { textTracks, $state } = this.#ctx,
        //     { currentTime } = $state,
        //     track = textTracks.selected;
        //   if (this.#currentCue) track?.removeCue(this.#currentCue, trigger);
        //   this.#currentCue = new window.VTTCue(currentTime(), Number.MAX_SAFE_INTEGER, cue.text);
        //   track?.addCue(this.#currentCue, trigger);
        // }
        #onChaptersChange(chapters) {
          this.#removeChapters();
          if (!chapters.length)
            return;
          const track = new TextTrack({
            kind: "chapters",
            default: true
          }), { realDuration } = this.#ctx.$state;
          for (let i5 = 0; i5 < chapters.length; i5++) {
            const chapter = chapters[i5], nextChapter = chapters[i5 + 1];
            track.addCue(
              new window.VTTCue(
                chapter.startTime,
                nextChapter?.startTime ?? realDuration(),
                chapter.title
              )
            );
          }
          this.#chaptersTrack = track;
          this.#ctx.textTracks.add(track);
        }
        #removeChapters() {
          if (!this.#chaptersTrack)
            return;
          this.#ctx.textTracks.remove(this.#chaptersTrack);
          this.#chaptersTrack = null;
        }
        #onQualitiesChange(qualities, trigger) {
          this.#ctx.qualities[QualitySymbol.enableAuto] = qualities.some((q) => q.id === "auto") ? () => this.#remote("setQuality", "auto") : void 0;
          for (const quality of qualities) {
            if (quality.id === "auto")
              continue;
            const height = +quality.id.slice(0, -1);
            if (isNaN(height))
              continue;
            this.#ctx.qualities[ListSymbol.add](
              {
                id: quality.id,
                width: height * (16 / 9),
                height,
                codec: "avc1,h.264",
                bitrate: -1
              },
              trigger
            );
          }
          this.#onQualityChange(
            qualities.find((q) => q.active),
            trigger
          );
        }
        #onQualityChange({ id } = {}, trigger) {
          if (!id)
            return;
          const isAuto = id === "auto", newQuality = this.#ctx.qualities.getById(id);
          if (isAuto) {
            this.#ctx.qualities[QualitySymbol.setAuto](isAuto, trigger);
            this.#ctx.qualities[ListSymbol.select](void 0, true, trigger);
          } else {
            this.#ctx.qualities[ListSymbol.select](newQuality ?? void 0, true, trigger);
          }
        }
        #onEvent(event2, payload, trigger) {
          switch (event2) {
            case "ready":
              this.#attachListeners();
              break;
            case "loaded":
              this.#onLoaded(trigger);
              break;
            case "play":
              this.#onPlay(trigger);
              break;
            case "playProgress":
              this.#onPlayProgress(trigger);
              break;
            case "pause":
              this.#onPause(trigger);
              break;
            case "loadProgress":
              this.#onLoadProgress(payload.seconds, trigger);
              break;
            case "waiting":
              this.#onWaiting(trigger);
              break;
            case "bufferstart":
              this.#onBufferStart(trigger);
              break;
            case "bufferend":
              this.#onBufferEnd(trigger);
              break;
            case "volumechange":
              this.#onVolumeChange(payload.volume, peek(this.#ctx.$state.muted), trigger);
              break;
            case "durationchange":
              this.#seekableRange = new TimeRange(0, payload.duration);
              this.#ctx.notify("duration-change", payload.duration, trigger);
              break;
            case "playbackratechange":
              this.#ctx.notify("rate-change", payload.playbackRate, trigger);
              break;
            case "qualitychange":
              this.#onQualityChange(payload, trigger);
              break;
            case "fullscreenchange":
              this.#fullscreenActive = payload.fullscreen;
              this.#ctx.notify("fullscreen-change", payload.fullscreen, trigger);
              break;
            case "enterpictureinpicture":
              this.#ctx.notify("picture-in-picture-change", true, trigger);
              break;
            case "leavepictureinpicture":
              this.#ctx.notify("picture-in-picture-change", false, trigger);
              break;
            case "ended":
              this.#ctx.notify("end", void 0, trigger);
              break;
            case "error":
              this.#onError(payload, trigger);
              break;
            case "seek":
            case "seeked":
              this.#onSeeked(payload.seconds, trigger);
              break;
          }
        }
        #onError(error, trigger) {
          const { message, method: method2 } = error;
          if (method2 === "setPlaybackRate") {
            this.#pro.set(false);
          }
          if (method2) {
            this.#getPromise(method2)?.reject(message);
          }
        }
        onMessage(message, event2) {
          if (message.event) {
            this.#onEvent(message.event, message.data, event2);
          } else if (message.method) {
            this.#onMethod(message.method, message.value, event2);
          }
        }
        onLoad() {
        }
        async #remote(command, arg) {
          let promise = deferredPromise(), promises = this.#promises.get(command);
          if (!promises)
            this.#promises.set(command, promises = []);
          promises.push(promise);
          this.postMessage({
            method: command,
            value: arg
          });
          return promise.promise;
        }
        #reset() {
          this.#timeRAF.stop();
          this.#seekableRange = new TimeRange(0, 0);
          this.#videoInfoPromise = null;
          this.#currentCue = null;
          this.#pro.set(false);
          this.#removeChapters();
        }
        #getPromise(command) {
          return this.#promises.get(command)?.shift();
        }
      };
    }
  });

  // node_modules/.pnpm/vidstack@1.12.9/node_modules/vidstack/prod/chunks/vidstack-Zc3I7oOd.js
  var vidstack_Zc3I7oOd_exports = {};
  __export(vidstack_Zc3I7oOd_exports, {
    findYouTubePoster: () => findYouTubePoster,
    resolveYouTubeVideoId: () => resolveYouTubeVideoId
  });
  function resolveYouTubeVideoId(src) {
    return src.match(videoIdRE2)?.[1];
  }
  async function findYouTubePoster(videoId, abort) {
    if (posterCache.has(videoId))
      return posterCache.get(videoId);
    if (pendingFetch2.has(videoId))
      return pendingFetch2.get(videoId);
    const pending2 = new Promise(async (resolve) => {
      const sizes = ["maxresdefault", "sddefault", "hqdefault"];
      for (const size2 of sizes) {
        for (const webp of [true, false]) {
          const url = resolveYouTubePosterURL(videoId, size2, webp), response = await fetch(url, {
            mode: "no-cors",
            signal: abort.signal
          });
          if (response.status < 400) {
            posterCache.set(videoId, url);
            resolve(url);
            return;
          }
        }
      }
    }).catch(() => "").finally(() => pendingFetch2.delete(videoId));
    pendingFetch2.set(videoId, pending2);
    return pending2;
  }
  function resolveYouTubePosterURL(videoId, size2, webp) {
    const type = webp ? "webp" : "jpg";
    return `https://i.ytimg.com/${webp ? "vi_webp" : "vi"}/${videoId}/${size2}.${type}`;
  }
  var videoIdRE2, posterCache, pendingFetch2;
  var init_vidstack_Zc3I7oOd = __esm({
    "node_modules/.pnpm/vidstack@1.12.9/node_modules/vidstack/prod/chunks/vidstack-Zc3I7oOd.js"() {
      init_live_reload();
      videoIdRE2 = /(?:youtu\.be|youtube|youtube\.com|youtube-nocookie\.com)\/(?:embed\/|v\/|watch\?v=|watch\?.+&v=|)((?:\w|-){11})/;
      posterCache = /* @__PURE__ */ new Map();
      pendingFetch2 = /* @__PURE__ */ new Map();
    }
  });

  // node_modules/.pnpm/vidstack@1.12.9/node_modules/vidstack/prod/providers/vidstack-youtube.js
  var vidstack_youtube_exports = {};
  __export(vidstack_youtube_exports, {
    YouTubeProvider: () => YouTubeProvider
  });
  var YouTubePlayerState, YouTubeProvider;
  var init_vidstack_youtube = __esm({
    "node_modules/.pnpm/vidstack@1.12.9/node_modules/vidstack/prod/providers/vidstack-youtube.js"() {
      init_live_reload();
      init_vidstack_CRlI3Mh7();
      init_vidstack_BmMUBVGQ();
      init_vidstack_vDnjyKV8();
      init_vidstack_BSPPDWLF();
      init_vidstack_Zc3I7oOd();
      YouTubePlayerState = {
        Unstarted: -1,
        Ended: 0,
        Playing: 1,
        Paused: 2,
        Buffering: 3,
        Cued: 5
      };
      YouTubeProvider = class extends EmbedProvider {
        $$PROVIDER_TYPE = "YOUTUBE";
        scope = createScope();
        #ctx;
        #videoId = signal("");
        #state = -1;
        #currentSrc = null;
        #seekingTimer = -1;
        #invalidPlay = false;
        #promises = /* @__PURE__ */ new Map();
        constructor(iframe, ctx) {
          super(iframe);
          this.#ctx = ctx;
        }
        /**
         * Sets the player's interface language. The parameter value is an ISO 639-1 two-letter
         * language code or a fully specified locale. For example, fr and fr-ca are both valid values.
         * Other language input codes, such as IETF language tags (BCP 47) might also be handled properly.
         *
         * The interface language is used for tooltips in the player and also affects the default caption
         * track. Note that YouTube might select a different caption track language for a particular
         * user based on the user's individual language preferences and the availability of caption tracks.
         *
         * @defaultValue 'en'
         */
        language = "en";
        color = "red";
        /**
         * Whether cookies should be enabled on the embed. This is turned off by default to be
         * GDPR-compliant.
         *
         * @defaultValue `false`
         */
        cookies = false;
        get currentSrc() {
          return this.#currentSrc;
        }
        get type() {
          return "youtube";
        }
        get videoId() {
          return this.#videoId();
        }
        preconnect() {
          preconnect(this.getOrigin());
        }
        setup() {
          super.setup();
          effect(this.#watchVideoId.bind(this));
          this.#ctx.notify("provider-setup", this);
        }
        destroy() {
          this.#reset();
          const message = "provider destroyed";
          for (const promises of this.#promises.values()) {
            for (const { reject } of promises)
              reject(message);
          }
          this.#promises.clear();
        }
        async play() {
          return this.#remote("playVideo");
        }
        #playFail(message) {
          this.#getPromise("playVideo")?.reject(message);
        }
        async pause() {
          return this.#remote("pauseVideo");
        }
        #pauseFail(message) {
          this.#getPromise("pauseVideo")?.reject(message);
        }
        setMuted(muted) {
          if (muted)
            this.#remote("mute");
          else
            this.#remote("unMute");
        }
        setCurrentTime(time) {
          this.#remote("seekTo", time);
          this.#ctx.notify("seeking", time);
        }
        setVolume(volume) {
          this.#remote("setVolume", volume * 100);
        }
        setPlaybackRate(rate) {
          this.#remote("setPlaybackRate", rate);
        }
        async loadSource(src) {
          if (!isString(src.src)) {
            this.#currentSrc = null;
            this.#videoId.set("");
            return;
          }
          const videoId = resolveYouTubeVideoId(src.src);
          this.#videoId.set(videoId ?? "");
          this.#currentSrc = src;
        }
        getOrigin() {
          return !this.cookies ? "https://www.youtube-nocookie.com" : "https://www.youtube.com";
        }
        #watchVideoId() {
          this.#reset();
          const videoId = this.#videoId();
          if (!videoId) {
            this.src.set("");
            return;
          }
          this.src.set(`${this.getOrigin()}/embed/${videoId}`);
          this.#ctx.notify("load-start");
        }
        buildParams() {
          const { keyDisabled } = this.#ctx.$props, { muted, playsInline, nativeControls } = this.#ctx.$state, showControls = nativeControls();
          return {
            autoplay: 0,
            cc_lang_pref: this.language,
            cc_load_policy: showControls ? 1 : void 0,
            color: this.color,
            controls: showControls ? 1 : 0,
            disablekb: !showControls || keyDisabled() ? 1 : 0,
            enablejsapi: 1,
            fs: 1,
            hl: this.language,
            iv_load_policy: showControls ? 1 : 3,
            mute: muted() ? 1 : 0,
            playsinline: playsInline() ? 1 : 0
          };
        }
        #remote(command, arg) {
          let promise = deferredPromise(), promises = this.#promises.get(command);
          if (!promises)
            this.#promises.set(command, promises = []);
          promises.push(promise);
          this.postMessage({
            event: "command",
            func: command,
            args: arg ? [arg] : void 0
          });
          return promise.promise;
        }
        onLoad() {
          window.setTimeout(() => this.postMessage({ event: "listening" }), 100);
        }
        #onReady(trigger) {
          this.#ctx.notify("loaded-metadata");
          this.#ctx.notify("loaded-data");
          this.#ctx.delegate.ready(void 0, trigger);
        }
        #onPause(trigger) {
          this.#getPromise("pauseVideo")?.resolve();
          this.#ctx.notify("pause", void 0, trigger);
        }
        #onTimeUpdate(time, trigger) {
          const { duration, realCurrentTime } = this.#ctx.$state, hasEnded = this.#state === YouTubePlayerState.Ended, boundTime = hasEnded ? duration() : time;
          this.#ctx.notify("time-change", boundTime, trigger);
          if (!hasEnded && Math.abs(boundTime - realCurrentTime()) > 1) {
            this.#ctx.notify("seeking", boundTime, trigger);
          }
        }
        #onProgress(buffered, seekable, trigger) {
          const detail = {
            buffered: new TimeRange(0, buffered),
            seekable
          };
          this.#ctx.notify("progress", detail, trigger);
          const { seeking, realCurrentTime } = this.#ctx.$state;
          if (seeking() && buffered > realCurrentTime()) {
            this.#onSeeked(trigger);
          }
        }
        #onSeeked(trigger) {
          const { paused, realCurrentTime } = this.#ctx.$state;
          window.clearTimeout(this.#seekingTimer);
          this.#seekingTimer = window.setTimeout(
            () => {
              this.#ctx.notify("seeked", realCurrentTime(), trigger);
              this.#seekingTimer = -1;
            },
            paused() ? 100 : 0
          );
        }
        #onEnded(trigger) {
          const { seeking } = this.#ctx.$state;
          if (seeking())
            this.#onSeeked(trigger);
          this.#ctx.notify("pause", void 0, trigger);
          this.#ctx.notify("end", void 0, trigger);
        }
        #onStateChange(state, trigger) {
          const { paused, seeking } = this.#ctx.$state, isPlaying = state === YouTubePlayerState.Playing, isBuffering = state === YouTubePlayerState.Buffering, isPendingPlay = this.#isPending("playVideo"), isPlay = paused() && (isBuffering || isPlaying);
          if (isBuffering)
            this.#ctx.notify("waiting", void 0, trigger);
          if (seeking() && isPlaying) {
            this.#onSeeked(trigger);
          }
          if (this.#invalidPlay && isPlaying) {
            this.pause();
            this.#invalidPlay = false;
            this.setMuted(this.#ctx.$state.muted());
            return;
          }
          if (!isPendingPlay && isPlay) {
            this.#invalidPlay = true;
            this.setMuted(true);
            return;
          }
          if (isPlay) {
            this.#getPromise("playVideo")?.resolve();
            this.#ctx.notify("play", void 0, trigger);
          }
          switch (state) {
            case YouTubePlayerState.Cued:
              this.#onReady(trigger);
              break;
            case YouTubePlayerState.Playing:
              this.#ctx.notify("playing", void 0, trigger);
              break;
            case YouTubePlayerState.Paused:
              this.#onPause(trigger);
              break;
            case YouTubePlayerState.Ended:
              this.#onEnded(trigger);
              break;
          }
          this.#state = state;
        }
        onMessage({ info }, event2) {
          if (!info)
            return;
          const { title, intrinsicDuration, playbackRate } = this.#ctx.$state;
          if (isObject3(info.videoData) && info.videoData.title !== title()) {
            this.#ctx.notify("title-change", info.videoData.title, event2);
          }
          if (isNumber(info.duration) && info.duration !== intrinsicDuration()) {
            if (isNumber(info.videoLoadedFraction)) {
              const buffered = info.progressState?.loaded ?? info.videoLoadedFraction * info.duration, seekable = new TimeRange(0, info.duration);
              this.#onProgress(buffered, seekable, event2);
            }
            this.#ctx.notify("duration-change", info.duration, event2);
          }
          if (isNumber(info.playbackRate) && info.playbackRate !== playbackRate()) {
            this.#ctx.notify("rate-change", info.playbackRate, event2);
          }
          if (info.progressState) {
            const { current, seekableStart, seekableEnd, loaded, duration } = info.progressState;
            this.#onTimeUpdate(current, event2);
            this.#onProgress(loaded, new TimeRange(seekableStart, seekableEnd), event2);
            if (duration !== intrinsicDuration()) {
              this.#ctx.notify("duration-change", duration, event2);
            }
          }
          if (isNumber(info.volume) && isBoolean(info.muted) && !this.#invalidPlay) {
            const detail = {
              muted: info.muted,
              volume: info.volume / 100
            };
            this.#ctx.notify("volume-change", detail, event2);
          }
          if (isNumber(info.playerState) && info.playerState !== this.#state) {
            this.#onStateChange(info.playerState, event2);
          }
        }
        #reset() {
          this.#state = -1;
          this.#seekingTimer = -1;
          this.#invalidPlay = false;
        }
        #getPromise(command) {
          return this.#promises.get(command)?.shift();
        }
        #isPending(command) {
          return Boolean(this.#promises.get(command)?.length);
        }
      };
    }
  });

  // node_modules/.pnpm/vidstack@1.12.9/node_modules/vidstack/prod/chunks/vidstack-IHrfMzpQ.js
  function getCastFrameworkURL() {
    return "https://www.gstatic.com/cv/js/sender/v1/cast_sender.js?loadCastFramework=1";
  }
  function hasLoadedCastFramework() {
    return !!window.cast?.framework;
  }
  function isCastAvailable() {
    return !!window.chrome?.cast?.isAvailable;
  }
  function isCastConnected() {
    return getCastContext().getCastState() === cast.framework.CastState.CONNECTED;
  }
  function getCastContext() {
    return window.cast.framework.CastContext.getInstance();
  }
  function getCastSession() {
    return getCastContext().getCurrentSession();
  }
  function getCastSessionMedia() {
    return getCastSession()?.getSessionObj().media[0];
  }
  function hasActiveCastSession(src) {
    const contentId = getCastSessionMedia()?.media.contentId;
    return contentId === src?.src;
  }
  function getDefaultCastOptions() {
    return {
      language: "en-US",
      autoJoinPolicy: chrome.cast.AutoJoinPolicy.ORIGIN_SCOPED,
      receiverApplicationId: chrome.cast.media.DEFAULT_MEDIA_RECEIVER_APP_ID,
      resumeSavedSession: true,
      androidReceiverCompatible: true
    };
  }
  function getCastErrorMessage(code) {
    const defaultMessage = `Google Cast Error Code: ${code}`;
    return defaultMessage;
  }
  function listenCastContextEvent(type, handler) {
    return listenEvent(getCastContext(), type, handler);
  }
  var init_vidstack_IHrfMzpQ = __esm({
    "node_modules/.pnpm/vidstack@1.12.9/node_modules/vidstack/prod/chunks/vidstack-IHrfMzpQ.js"() {
      init_live_reload();
      init_vidstack_CRlI3Mh7();
    }
  });

  // node_modules/.pnpm/vidstack@1.12.9/node_modules/vidstack/prod/providers/vidstack-google-cast.js
  var vidstack_google_cast_exports = {};
  __export(vidstack_google_cast_exports, {
    GoogleCastProvider: () => GoogleCastProvider
  });
  var GoogleCastMediaInfoBuilder, REMOTE_TRACK_TEXT_TYPE, REMOTE_TRACK_AUDIO_TYPE, GoogleCastTracksManager, GoogleCastProvider;
  var init_vidstack_google_cast = __esm({
    "node_modules/.pnpm/vidstack@1.12.9/node_modules/vidstack/prod/providers/vidstack-google-cast.js"() {
      init_live_reload();
      init_vidstack_CRlI3Mh7();
      init_vidstack_BmMUBVGQ();
      init_vidstack_DSYpsFWk();
      init_vidstack_D5EzK014();
      init_vidstack_IHrfMzpQ();
      GoogleCastMediaInfoBuilder = class {
        #info;
        constructor(src) {
          this.#info = new chrome.cast.media.MediaInfo(src.src, src.type);
        }
        build() {
          return this.#info;
        }
        setStreamType(streamType) {
          if (streamType.includes("live")) {
            this.#info.streamType = chrome.cast.media.StreamType.LIVE;
          } else {
            this.#info.streamType = chrome.cast.media.StreamType.BUFFERED;
          }
          return this;
        }
        setTracks(tracks) {
          this.#info.tracks = tracks.map(this.#buildCastTrack);
          return this;
        }
        setMetadata(title, poster) {
          this.#info.metadata = new chrome.cast.media.GenericMediaMetadata();
          this.#info.metadata.title = title;
          this.#info.metadata.images = [{ url: poster }];
          return this;
        }
        #buildCastTrack(track, trackId) {
          const castTrack = new chrome.cast.media.Track(trackId, chrome.cast.media.TrackType.TEXT);
          castTrack.name = track.label;
          castTrack.trackContentId = track.src;
          castTrack.trackContentType = "text/vtt";
          castTrack.language = track.language;
          castTrack.subtype = track.kind.toUpperCase();
          return castTrack;
        }
      };
      REMOTE_TRACK_TEXT_TYPE = chrome.cast.media.TrackType.TEXT;
      REMOTE_TRACK_AUDIO_TYPE = chrome.cast.media.TrackType.AUDIO;
      GoogleCastTracksManager = class {
        #cast;
        #ctx;
        #onNewLocalTracks;
        constructor(cast2, ctx, onNewLocalTracks) {
          this.#cast = cast2;
          this.#ctx = ctx;
          this.#onNewLocalTracks = onNewLocalTracks;
        }
        setup() {
          const syncRemoteActiveIds = this.syncRemoteActiveIds.bind(this);
          listenEvent(this.#ctx.audioTracks, "change", syncRemoteActiveIds);
          listenEvent(this.#ctx.textTracks, "mode-change", syncRemoteActiveIds);
          effect(this.#syncLocalTracks.bind(this));
        }
        getLocalTextTracks() {
          return this.#ctx.$state.textTracks().filter((track) => track.src && track.type === "vtt");
        }
        #getLocalAudioTracks() {
          return this.#ctx.$state.audioTracks();
        }
        #getRemoteTracks(type) {
          const tracks = this.#cast.mediaInfo?.tracks ?? [];
          return type ? tracks.filter((track) => track.type === type) : tracks;
        }
        #getRemoteActiveIds() {
          const activeIds = [], activeLocalAudioTrack = this.#getLocalAudioTracks().find((track) => track.selected), activeLocalTextTracks = this.getLocalTextTracks().filter((track) => track.mode === "showing");
          if (activeLocalAudioTrack) {
            const remoteAudioTracks = this.#getRemoteTracks(REMOTE_TRACK_AUDIO_TYPE), remoteAudioTrack = this.#findRemoteTrack(remoteAudioTracks, activeLocalAudioTrack);
            if (remoteAudioTrack)
              activeIds.push(remoteAudioTrack.trackId);
          }
          if (activeLocalTextTracks?.length) {
            const remoteTextTracks = this.#getRemoteTracks(REMOTE_TRACK_TEXT_TYPE);
            if (remoteTextTracks.length) {
              for (const localTrack of activeLocalTextTracks) {
                const remoteTextTrack = this.#findRemoteTrack(remoteTextTracks, localTrack);
                if (remoteTextTrack)
                  activeIds.push(remoteTextTrack.trackId);
              }
            }
          }
          return activeIds;
        }
        #syncLocalTracks() {
          const localTextTracks = this.getLocalTextTracks();
          if (!this.#cast.isMediaLoaded)
            return;
          const remoteTextTracks = this.#getRemoteTracks(REMOTE_TRACK_TEXT_TYPE);
          for (const localTrack of localTextTracks) {
            const hasRemoteTrack = this.#findRemoteTrack(remoteTextTracks, localTrack);
            if (!hasRemoteTrack) {
              untrack(() => this.#onNewLocalTracks?.());
              break;
            }
          }
        }
        syncRemoteTracks(event2) {
          if (!this.#cast.isMediaLoaded)
            return;
          const localAudioTracks = this.#getLocalAudioTracks(), localTextTracks = this.getLocalTextTracks(), remoteAudioTracks = this.#getRemoteTracks(REMOTE_TRACK_AUDIO_TYPE), remoteTextTracks = this.#getRemoteTracks(REMOTE_TRACK_TEXT_TYPE);
          for (const remoteAudioTrack of remoteAudioTracks) {
            const hasLocalTrack = this.#findLocalTrack(localAudioTracks, remoteAudioTrack);
            if (hasLocalTrack)
              continue;
            const localAudioTrack = {
              id: remoteAudioTrack.trackId.toString(),
              label: remoteAudioTrack.name,
              language: remoteAudioTrack.language,
              kind: remoteAudioTrack.subtype ?? "main",
              selected: false
            };
            this.#ctx.audioTracks[ListSymbol.add](localAudioTrack, event2);
          }
          for (const remoteTextTrack of remoteTextTracks) {
            const hasLocalTrack = this.#findLocalTrack(localTextTracks, remoteTextTrack);
            if (hasLocalTrack)
              continue;
            const localTextTrack = {
              id: remoteTextTrack.trackId.toString(),
              src: remoteTextTrack.trackContentId,
              label: remoteTextTrack.name,
              language: remoteTextTrack.language,
              kind: remoteTextTrack.subtype.toLowerCase()
            };
            this.#ctx.textTracks.add(localTextTrack, event2);
          }
        }
        syncRemoteActiveIds(event2) {
          if (!this.#cast.isMediaLoaded)
            return;
          const activeIds = this.#getRemoteActiveIds(), editRequest = new chrome.cast.media.EditTracksInfoRequest(activeIds);
          this.#editTracksInfo(editRequest).catch((error) => {
          });
        }
        #editTracksInfo(request) {
          const media = getCastSessionMedia();
          return new Promise((resolve, reject) => media?.editTracksInfo(request, resolve, reject));
        }
        #findLocalTrack(localTracks, remoteTrack) {
          return localTracks.find((localTrack) => this.#isMatch(localTrack, remoteTrack));
        }
        #findRemoteTrack(remoteTracks, localTrack) {
          return remoteTracks.find((remoteTrack) => this.#isMatch(localTrack, remoteTrack));
        }
        // Note: we can't rely on id matching because they will differ between local/remote. A local
        // track id might not even exist.
        #isMatch(localTrack, remoteTrack) {
          return remoteTrack.name === localTrack.label && remoteTrack.language === localTrack.language && remoteTrack.subtype.toLowerCase() === localTrack.kind.toLowerCase();
        }
      };
      GoogleCastProvider = class {
        $$PROVIDER_TYPE = "GOOGLE_CAST";
        scope = createScope();
        #player;
        #ctx;
        #tracks;
        #currentSrc = null;
        #state = "disconnected";
        #currentTime = 0;
        #played = 0;
        #seekableRange = new TimeRange(0, 0);
        #timeRAF = new RAFLoop(this.#onAnimationFrame.bind(this));
        #playerEventHandlers;
        #reloadInfo = null;
        #isIdle = false;
        constructor(player, ctx) {
          this.#player = player;
          this.#ctx = ctx;
          this.#tracks = new GoogleCastTracksManager(player, ctx, this.#onNewLocalTracks.bind(this));
        }
        get type() {
          return "google-cast";
        }
        get currentSrc() {
          return this.#currentSrc;
        }
        /**
         * The Google Cast remote player.
         *
         * @see {@link https://developers.google.com/cast/docs/reference/web_sender/cast.framework.RemotePlayer}
         */
        get player() {
          return this.#player;
        }
        /**
         * @see {@link https://developers.google.com/cast/docs/reference/web_sender/cast.framework.CastContext}
         */
        get cast() {
          return getCastContext();
        }
        /**
         * @see {@link https://developers.google.com/cast/docs/reference/web_sender/cast.framework.CastSession}
         */
        get session() {
          return getCastSession();
        }
        /**
         * @see {@link https://developers.google.com/cast/docs/reference/web_sender/chrome.cast.media.Media}
         */
        get media() {
          return getCastSessionMedia();
        }
        /**
         * Whether the current Google Cast session belongs to this provider.
         */
        get hasActiveSession() {
          return hasActiveCastSession(this.#currentSrc);
        }
        setup() {
          this.#attachCastContextEventListeners();
          this.#attachCastPlayerEventListeners();
          this.#tracks.setup();
          this.#ctx.notify("provider-setup", this);
        }
        #attachCastContextEventListeners() {
          listenCastContextEvent(
            cast.framework.CastContextEventType.CAST_STATE_CHANGED,
            this.#onCastStateChange.bind(this)
          );
        }
        #attachCastPlayerEventListeners() {
          const Event2 = cast.framework.RemotePlayerEventType, handlers = {
            [Event2.IS_CONNECTED_CHANGED]: this.#onCastStateChange,
            [Event2.IS_MEDIA_LOADED_CHANGED]: this.#onMediaLoadedChange,
            [Event2.CAN_CONTROL_VOLUME_CHANGED]: this.#onCanControlVolumeChange,
            [Event2.CAN_SEEK_CHANGED]: this.#onCanSeekChange,
            [Event2.DURATION_CHANGED]: this.#onDurationChange,
            [Event2.IS_MUTED_CHANGED]: this.#onVolumeChange,
            [Event2.VOLUME_LEVEL_CHANGED]: this.#onVolumeChange,
            [Event2.IS_PAUSED_CHANGED]: this.#onPausedChange,
            [Event2.LIVE_SEEKABLE_RANGE_CHANGED]: this.#onProgress,
            [Event2.PLAYER_STATE_CHANGED]: this.#onPlayerStateChange
          };
          this.#playerEventHandlers = handlers;
          const handler = this.#onRemotePlayerEvent.bind(this);
          for (const type of keysOf(handlers)) {
            this.#player.controller.addEventListener(type, handler);
          }
          onDispose(() => {
            for (const type of keysOf(handlers)) {
              this.#player.controller.removeEventListener(type, handler);
            }
          });
        }
        async play() {
          if (!this.#player.isPaused && !this.#isIdle)
            return;
          if (this.#isIdle) {
            await this.#reload(false, 0);
            return;
          }
          this.#player.controller?.playOrPause();
        }
        async pause() {
          if (this.#player.isPaused)
            return;
          this.#player.controller?.playOrPause();
        }
        getMediaStatus(request) {
          return new Promise((resolve, reject) => {
            this.media?.getStatus(request, resolve, reject);
          });
        }
        setMuted(muted) {
          const hasChanged = muted && !this.#player.isMuted || !muted && this.#player.isMuted;
          if (hasChanged)
            this.#player.controller?.muteOrUnmute();
        }
        setCurrentTime(time) {
          this.#player.currentTime = time;
          this.#ctx.notify("seeking", time);
          this.#player.controller?.seek();
        }
        setVolume(volume) {
          this.#player.volumeLevel = volume;
          this.#player.controller?.setVolumeLevel();
        }
        async loadSource(src) {
          if (this.#reloadInfo?.src !== src)
            this.#reloadInfo = null;
          if (hasActiveCastSession(src)) {
            this.#resumeSession();
            this.#currentSrc = src;
            return;
          }
          this.#ctx.notify("load-start");
          const loadRequest = this.#buildLoadRequest(src), errorCode = await this.session.loadMedia(loadRequest);
          if (errorCode) {
            this.#currentSrc = null;
            this.#ctx.notify("error", Error(getCastErrorMessage(errorCode)));
            return;
          }
          this.#currentSrc = src;
        }
        destroy() {
          this.#reset();
          this.#endSession();
        }
        #reset() {
          if (!this.#reloadInfo) {
            this.#played = 0;
            this.#seekableRange = new TimeRange(0, 0);
          }
          this.#timeRAF.stop();
          this.#currentTime = 0;
          this.#reloadInfo = null;
        }
        #resumeSession() {
          const resumeSessionEvent = new DOMEvent("resume-session", { detail: this.session });
          this.#onMediaLoadedChange(resumeSessionEvent);
          const { muted, volume, savedState } = this.#ctx.$state, localState = savedState();
          this.setCurrentTime(Math.max(this.#player.currentTime, localState?.currentTime ?? 0));
          this.setMuted(muted());
          this.setVolume(volume());
          if (localState?.paused === false)
            this.play();
        }
        #endSession() {
          this.cast.endCurrentSession(true);
          const { remotePlaybackLoader } = this.#ctx.$state;
          remotePlaybackLoader.set(null);
        }
        #disconnectFromReceiver() {
          const { savedState } = this.#ctx.$state;
          savedState.set({
            paused: this.#player.isPaused,
            currentTime: this.#player.currentTime
          });
          this.#endSession();
        }
        #onAnimationFrame() {
          this.#onCurrentTimeChange();
        }
        #onRemotePlayerEvent(event2) {
          this.#playerEventHandlers[event2.type].call(this, event2);
        }
        #onCastStateChange(data) {
          const castState = this.cast.getCastState(), state = castState === cast.framework.CastState.CONNECTED ? "connected" : castState === cast.framework.CastState.CONNECTING ? "connecting" : "disconnected";
          if (this.#state === state)
            return;
          const detail = { type: "google-cast", state }, trigger = this.#createEvent(data);
          this.#state = state;
          this.#ctx.notify("remote-playback-change", detail, trigger);
          if (state === "disconnected") {
            this.#disconnectFromReceiver();
          }
        }
        #onMediaLoadedChange(event2) {
          const hasLoaded = !!this.#player.isMediaLoaded;
          if (!hasLoaded)
            return;
          const src = peek(this.#ctx.$state.source);
          Promise.resolve().then(() => {
            if (src !== peek(this.#ctx.$state.source) || !this.#player.isMediaLoaded)
              return;
            this.#reset();
            const duration = this.#player.duration;
            this.#seekableRange = new TimeRange(0, duration);
            const detail = {
              provider: this,
              duration,
              buffered: new TimeRange(0, 0),
              seekable: this.#getSeekableRange()
            }, trigger = this.#createEvent(event2);
            this.#ctx.notify("loaded-metadata", void 0, trigger);
            this.#ctx.notify("loaded-data", void 0, trigger);
            this.#ctx.notify("can-play", detail, trigger);
            this.#onCanControlVolumeChange();
            this.#onCanSeekChange(event2);
            const { volume, muted } = this.#ctx.$state;
            this.setVolume(volume());
            this.setMuted(muted());
            this.#timeRAF.start();
            this.#tracks.syncRemoteTracks(trigger);
            this.#tracks.syncRemoteActiveIds(trigger);
          });
        }
        #onCanControlVolumeChange() {
          this.#ctx.$state.canSetVolume.set(this.#player.canControlVolume);
        }
        #onCanSeekChange(event2) {
          const trigger = this.#createEvent(event2);
          this.#ctx.notify("stream-type-change", this.#getStreamType(), trigger);
        }
        #getStreamType() {
          const streamType = this.#player.mediaInfo?.streamType;
          return streamType === chrome.cast.media.StreamType.LIVE ? this.#player.canSeek ? "live:dvr" : "live" : "on-demand";
        }
        #onCurrentTimeChange() {
          if (this.#reloadInfo)
            return;
          const currentTime = this.#player.currentTime;
          if (currentTime === this.#currentTime)
            return;
          this.#ctx.notify("time-change", currentTime);
          if (currentTime > this.#played) {
            this.#played = currentTime;
            this.#onProgress();
          }
          if (this.#ctx.$state.seeking()) {
            this.#ctx.notify("seeked", currentTime);
          }
          this.#currentTime = currentTime;
        }
        #onDurationChange(event2) {
          if (!this.#player.isMediaLoaded || this.#reloadInfo)
            return;
          const duration = this.#player.duration, trigger = this.#createEvent(event2);
          this.#seekableRange = new TimeRange(0, duration);
          this.#ctx.notify("duration-change", duration, trigger);
        }
        #onVolumeChange(event2) {
          if (!this.#player.isMediaLoaded)
            return;
          const detail = {
            muted: this.#player.isMuted,
            volume: this.#player.volumeLevel
          }, trigger = this.#createEvent(event2);
          this.#ctx.notify("volume-change", detail, trigger);
        }
        #onPausedChange(event2) {
          const trigger = this.#createEvent(event2);
          if (this.#player.isPaused) {
            this.#ctx.notify("pause", void 0, trigger);
          } else {
            this.#ctx.notify("play", void 0, trigger);
          }
        }
        #onProgress(event2) {
          const detail = {
            seekable: this.#getSeekableRange(),
            buffered: new TimeRange(0, this.#played)
          }, trigger = event2 ? this.#createEvent(event2) : void 0;
          this.#ctx.notify("progress", detail, trigger);
        }
        #onPlayerStateChange(event2) {
          const state = this.#player.playerState, PlayerState = chrome.cast.media.PlayerState;
          this.#isIdle = state === PlayerState.IDLE;
          if (state === PlayerState.PAUSED)
            return;
          const trigger = this.#createEvent(event2);
          switch (state) {
            case PlayerState.PLAYING:
              this.#ctx.notify("playing", void 0, trigger);
              break;
            case PlayerState.BUFFERING:
              this.#ctx.notify("waiting", void 0, trigger);
              break;
            case PlayerState.IDLE:
              this.#timeRAF.stop();
              this.#ctx.notify("pause");
              this.#ctx.notify("end");
              break;
          }
        }
        #getSeekableRange() {
          return this.#player.liveSeekableRange ? new TimeRange(this.#player.liveSeekableRange.start, this.#player.liveSeekableRange.end) : this.#seekableRange;
        }
        #createEvent(detail) {
          return detail instanceof Event ? detail : new DOMEvent(detail.type, { detail });
        }
        #buildMediaInfo(src) {
          const { streamType, title, poster } = this.#ctx.$state;
          return new GoogleCastMediaInfoBuilder(src).setMetadata(title(), poster()).setStreamType(streamType()).setTracks(this.#tracks.getLocalTextTracks()).build();
        }
        #buildLoadRequest(src) {
          const mediaInfo = this.#buildMediaInfo(src), request = new chrome.cast.media.LoadRequest(mediaInfo), savedState = this.#ctx.$state.savedState();
          request.autoplay = (this.#reloadInfo?.paused ?? savedState?.paused) === false;
          request.currentTime = this.#reloadInfo?.time ?? savedState?.currentTime ?? 0;
          return request;
        }
        async #reload(paused, time) {
          const src = peek(this.#ctx.$state.source);
          this.#reloadInfo = { src, paused, time };
          await this.loadSource(src);
        }
        #onNewLocalTracks() {
          this.#reload(this.#player.isPaused, this.#player.currentTime).catch((error) => {
          });
        }
      };
    }
  });

  // node_modules/.pnpm/vidstack@1.12.9/node_modules/vidstack/prod/chunks/vidstack-kV1-bfkY.js
  var vidstack_kV1_bfkY_exports = {};
  __export(vidstack_kV1_bfkY_exports, {
    GoogleCastLoader: () => GoogleCastLoader
  });
  var GoogleCastLoader;
  var init_vidstack_kV1_bfkY = __esm({
    "node_modules/.pnpm/vidstack@1.12.9/node_modules/vidstack/prod/chunks/vidstack-kV1-bfkY.js"() {
      init_live_reload();
      init_vidstack_DyMkFGuS();
      init_vidstack_vDnjyKV8();
      init_vidstack_IHrfMzpQ();
      init_vidstack_CRlI3Mh7();
      GoogleCastLoader = class {
        name = "google-cast";
        target;
        #player;
        /**
         * @see {@link https://developers.google.com/cast/docs/reference/web_sender/cast.framework.CastContext}
         */
        get cast() {
          return getCastContext();
        }
        mediaType() {
          return "video";
        }
        canPlay(src) {
          return IS_CHROME && !IS_IOS && canGoogleCastSrc(src);
        }
        async prompt(ctx) {
          let loadEvent, openEvent, errorEvent;
          try {
            loadEvent = await this.#loadCastFramework(ctx);
            if (!this.#player) {
              this.#player = new cast.framework.RemotePlayer();
              new cast.framework.RemotePlayerController(this.#player);
            }
            openEvent = ctx.player.createEvent("google-cast-prompt-open", {
              trigger: loadEvent
            });
            ctx.player.dispatchEvent(openEvent);
            this.#notifyRemoteStateChange(ctx, "connecting", openEvent);
            await this.#showPrompt(peek(ctx.$props.googleCast));
            ctx.$state.remotePlaybackInfo.set({
              deviceName: getCastSession()?.getCastDevice().friendlyName
            });
            if (isCastConnected())
              this.#notifyRemoteStateChange(ctx, "connected", openEvent);
          } catch (code) {
            const error = code instanceof Error ? code : this.#createError(
              (code + "").toUpperCase(),
              "Prompt failed."
            );
            errorEvent = ctx.player.createEvent("google-cast-prompt-error", {
              detail: error,
              trigger: openEvent ?? loadEvent,
              cancelable: true
            });
            ctx.player.dispatch(errorEvent);
            this.#notifyRemoteStateChange(
              ctx,
              isCastConnected() ? "connected" : "disconnected",
              errorEvent
            );
            throw error;
          } finally {
            ctx.player.dispatch("google-cast-prompt-close", {
              trigger: errorEvent ?? openEvent ?? loadEvent
            });
          }
        }
        async load(ctx) {
          if (!this.#player) {
            throw Error("[vidstack] google cast player was not initialized");
          }
          return new (await Promise.resolve().then(() => (init_vidstack_google_cast(), vidstack_google_cast_exports))).GoogleCastProvider(this.#player, ctx);
        }
        async #loadCastFramework(ctx) {
          if (hasLoadedCastFramework())
            return;
          const loadStartEvent = ctx.player.createEvent("google-cast-load-start");
          ctx.player.dispatch(loadStartEvent);
          await loadScript(getCastFrameworkURL());
          await customElements.whenDefined("google-cast-launcher");
          const loadedEvent = ctx.player.createEvent("google-cast-loaded", { trigger: loadStartEvent });
          ctx.player.dispatch(loadedEvent);
          if (!isCastAvailable()) {
            throw this.#createError("CAST_NOT_AVAILABLE", "Google Cast not available on this platform.");
          }
          return loadedEvent;
        }
        async #showPrompt(options) {
          this.#setOptions(options);
          const errorCode = await this.cast.requestSession();
          if (errorCode) {
            throw this.#createError(
              errorCode.toUpperCase(),
              getCastErrorMessage(errorCode)
            );
          }
        }
        #setOptions(options) {
          this.cast?.setOptions({
            ...getDefaultCastOptions(),
            ...options
          });
        }
        #notifyRemoteStateChange(ctx, state, trigger) {
          const detail = { type: "google-cast", state };
          ctx.notify("remote-playback-change", detail, trigger);
        }
        #createError(code, message) {
          const error = Error(message);
          error.code = code;
          return error;
        }
      };
    }
  });

  // node_modules/.pnpm/vidstack@1.12.9/node_modules/vidstack/prod/chunks/vidstack-DJTshtlu.js
  var vidstack_DJTshtlu_exports = {};
  __export(vidstack_DJTshtlu_exports, {
    insertContent: () => insertContent
  });
  function insertContent(container, $state) {
    const icon = cloneTemplateContent(svgTemplate);
    icon.innerHTML = Icon$24;
    container.append(icon);
    const text = document.createElement("span");
    text.classList.add("vds-google-cast-info");
    container.append(text);
    const deviceName = document.createElement("span");
    deviceName.classList.add("vds-google-cast-device-name");
    effect(() => {
      const { remotePlaybackInfo } = $state, info = remotePlaybackInfo();
      if (info?.deviceName) {
        deviceName.textContent = info.deviceName;
        text.append("Google Cast on ", deviceName);
      }
      return () => {
        text.textContent = "";
      };
    });
  }
  var svgTemplate;
  var init_vidstack_DJTshtlu = __esm({
    "node_modules/.pnpm/vidstack@1.12.9/node_modules/vidstack/prod/chunks/vidstack-DJTshtlu.js"() {
      init_live_reload();
      init_vidstack_CRlI3Mh7();
      init_vidstack_Ds_q5BGO();
      svgTemplate = /* @__PURE__ */ createTemplate(
        `<svg viewBox="0 0 32 32" fill="none" aria-hidden="true" xmlns="http://www.w3.org/2000/svg"></svg>`
      );
    }
  });

  // node_modules/.pnpm/lit-html@2.8.0/node_modules/lit-html/directives/if-defined.js
  var init_if_defined = __esm({
    "node_modules/.pnpm/lit-html@2.8.0/node_modules/lit-html/directives/if-defined.js"() {
      init_live_reload();
      init_lit_html();
    }
  });

  // node_modules/.pnpm/lit-html@2.8.0/node_modules/lit-html/directive.js
  var t4, e5, i3;
  var init_directive = __esm({
    "node_modules/.pnpm/lit-html@2.8.0/node_modules/lit-html/directive.js"() {
      init_live_reload();
      t4 = { ATTRIBUTE: 1, CHILD: 2, PROPERTY: 3, BOOLEAN_ATTRIBUTE: 4, EVENT: 5, ELEMENT: 6 };
      e5 = (t6) => (...e8) => ({ _$litDirective$: t6, values: e8 });
      i3 = class {
        constructor(t6) {
        }
        get _$AU() {
          return this._$AM._$AU;
        }
        _$AT(t6, e8, i5) {
          this._$Ct = t6, this._$AM = e8, this._$Ci = i5;
        }
        _$AS(t6, e8) {
          return this.update(t6, e8);
        }
        update(t6, e8) {
          return this.render(...e8);
        }
      };
    }
  });

  // node_modules/.pnpm/lit-html@2.8.0/node_modules/lit-html/directives/unsafe-html.js
  var e6, o4;
  var init_unsafe_html = __esm({
    "node_modules/.pnpm/lit-html@2.8.0/node_modules/lit-html/directives/unsafe-html.js"() {
      init_live_reload();
      init_lit_html();
      init_directive();
      e6 = class extends i3 {
        constructor(i5) {
          if (super(i5), this.et = A, i5.type !== t4.CHILD)
            throw Error(this.constructor.directiveName + "() can only be used in child bindings");
        }
        render(r5) {
          if (r5 === A || null == r5)
            return this.ft = void 0, this.et = r5;
          if (r5 === T)
            return r5;
          if ("string" != typeof r5)
            throw Error(this.constructor.directiveName + "() called with a non-string value");
          if (r5 === this.et)
            return this.ft;
          this.et = r5;
          const s5 = [r5];
          return s5.raw = s5, this.ft = { _$litType$: this.constructor.resultType, strings: s5, values: [] };
        }
      };
      e6.directiveName = "unsafeHTML", e6.resultType = 1;
      o4 = e5(e6);
    }
  });

  // node_modules/.pnpm/lit-html@2.8.0/node_modules/lit-html/directives/unsafe-svg.js
  var t5, o5;
  var init_unsafe_svg = __esm({
    "node_modules/.pnpm/lit-html@2.8.0/node_modules/lit-html/directives/unsafe-svg.js"() {
      init_live_reload();
      init_directive();
      init_unsafe_html();
      t5 = class extends e6 {
      };
      t5.directiveName = "unsafeSVG", t5.resultType = 2;
      o5 = e5(t5);
    }
  });

  // node_modules/.pnpm/lit-html@2.8.0/node_modules/lit-html/directive-helpers.js
  var l4, e7, s3, a3;
  var init_directive_helpers = __esm({
    "node_modules/.pnpm/lit-html@2.8.0/node_modules/lit-html/directive-helpers.js"() {
      init_live_reload();
      init_lit_html();
      ({ I: l4 } = j);
      e7 = (o7) => void 0 === o7.strings;
      s3 = {};
      a3 = (o7, l6 = s3) => o7._$AH = l6;
    }
  });

  // node_modules/.pnpm/lit-html@2.8.0/node_modules/lit-html/async-directive.js
  function n4(i5) {
    void 0 !== this._$AN ? (o6(this), this._$AM = i5, r4(this)) : this._$AM = i5;
  }
  function h3(i5, t6 = false, e8 = 0) {
    const r5 = this._$AH, n6 = this._$AN;
    if (void 0 !== n6 && 0 !== n6.size)
      if (t6)
        if (Array.isArray(r5))
          for (let i6 = e8; i6 < r5.length; i6++)
            s4(r5[i6], false), o6(r5[i6]);
        else
          null != r5 && (s4(r5, false), o6(r5));
      else
        s4(this, i5);
  }
  var s4, o6, r4, l5, c3;
  var init_async_directive = __esm({
    "node_modules/.pnpm/lit-html@2.8.0/node_modules/lit-html/async-directive.js"() {
      init_live_reload();
      init_directive_helpers();
      init_directive();
      init_directive();
      s4 = (i5, t6) => {
        var e8, o7;
        const r5 = i5._$AN;
        if (void 0 === r5)
          return false;
        for (const i6 of r5)
          null === (o7 = (e8 = i6)._$AO) || void 0 === o7 || o7.call(e8, t6, false), s4(i6, t6);
        return true;
      };
      o6 = (i5) => {
        let t6, e8;
        do {
          if (void 0 === (t6 = i5._$AM))
            break;
          e8 = t6._$AN, e8.delete(i5), i5 = t6;
        } while (0 === (null == e8 ? void 0 : e8.size));
      };
      r4 = (i5) => {
        for (let t6; t6 = i5._$AM; i5 = t6) {
          let e8 = t6._$AN;
          if (void 0 === e8)
            t6._$AN = e8 = /* @__PURE__ */ new Set();
          else if (e8.has(i5))
            break;
          e8.add(i5), l5(t6);
        }
      };
      l5 = (i5) => {
        var t6, s5, o7, r5;
        i5.type == t4.CHILD && (null !== (t6 = (o7 = i5)._$AP) && void 0 !== t6 || (o7._$AP = h3), null !== (s5 = (r5 = i5)._$AQ) && void 0 !== s5 || (r5._$AQ = n4));
      };
      c3 = class extends i3 {
        constructor() {
          super(...arguments), this._$AN = void 0;
        }
        _$AT(i5, t6, e8) {
          super._$AT(i5, t6, e8), r4(this), this.isConnected = i5._$AU;
        }
        _$AO(i5, t6 = true) {
          var e8, r5;
          i5 !== this.isConnected && (this.isConnected = i5, i5 ? null === (e8 = this.reconnected) || void 0 === e8 || e8.call(this) : null === (r5 = this.disconnected) || void 0 === r5 || r5.call(this)), t6 && (s4(this, i5), o6(this));
        }
        setValue(t6) {
          if (e7(this._$Ct))
            this._$Ct._$AI(t6, this);
          else {
            const i5 = [...this._$Ct._$AH];
            i5[this._$Ci] = t6, this._$Ct._$AI(i5, this, 0);
          }
        }
        disconnected() {
        }
        reconnected() {
        }
      };
    }
  });

  // node_modules/.pnpm/lit-html@2.8.0/node_modules/lit-html/directives/ref.js
  var h4, n5;
  var init_ref = __esm({
    "node_modules/.pnpm/lit-html@2.8.0/node_modules/lit-html/directives/ref.js"() {
      init_live_reload();
      init_lit_html();
      init_async_directive();
      init_directive();
      h4 = /* @__PURE__ */ new WeakMap();
      n5 = e5(class extends c3 {
        render(t6) {
          return A;
        }
        update(t6, [s5]) {
          var e8;
          const o7 = s5 !== this.G;
          return o7 && void 0 !== this.G && this.ot(void 0), (o7 || this.rt !== this.lt) && (this.G = s5, this.dt = null === (e8 = t6.options) || void 0 === e8 ? void 0 : e8.host, this.ot(this.lt = t6.element)), A;
        }
        ot(i5) {
          var t6;
          if ("function" == typeof this.G) {
            const s5 = null !== (t6 = this.dt) && void 0 !== t6 ? t6 : globalThis;
            let e8 = h4.get(s5);
            void 0 === e8 && (e8 = /* @__PURE__ */ new WeakMap(), h4.set(s5, e8)), void 0 !== e8.get(this.G) && this.G.call(this.dt, void 0), e8.set(this.G, i5), void 0 !== i5 && this.G.call(this.dt, i5);
          } else
            this.G.value = i5;
        }
        get rt() {
          var i5, t6, s5;
          return "function" == typeof this.G ? null === (t6 = h4.get(null !== (i5 = this.dt) && void 0 !== i5 ? i5 : globalThis)) || void 0 === t6 ? void 0 : t6.get(this.G) : null === (s5 = this.G) || void 0 === s5 ? void 0 : s5.value;
        }
        disconnected() {
          this.rt === this.lt && this.ot(void 0);
        }
        reconnected() {
          this.ot(this.lt);
        }
      });
    }
  });

  // node_modules/.pnpm/lit-html@2.8.0/node_modules/lit-html/directives/keyed.js
  var i4;
  var init_keyed = __esm({
    "node_modules/.pnpm/lit-html@2.8.0/node_modules/lit-html/directives/keyed.js"() {
      init_live_reload();
      init_lit_html();
      init_directive();
      init_directive_helpers();
      i4 = e5(class extends i3 {
        constructor() {
          super(...arguments), this.key = A;
        }
        render(r5, t6) {
          return this.key = r5, t6;
        }
        update(r5, [t6, e8]) {
          return t6 !== this.key && (a3(r5), this.key = t6), e8;
        }
      });
    }
  });

  // src/index.ts
  init_live_reload();

  // src/formCode.ts
  init_live_reload();
  function initializeformCode() {
    window.onload = () => ["utm_source", "utm_medium", "utm_campaign"].forEach(
      (field) => document.getElementById(field).value = new URLSearchParams(location.search).get(field.toLowerCase()) || ""
    );
    document.querySelector('[data-js="input"]').oninput = (e8) => e8.target.value = e8.target.value.replace(/\D/g, "").replace(/^(\d{2})(\d)/, "($1) $2").replace(/(\d{5})(\d)/, "$1-$2").replace(/(-\d{4})\d+?$/, "$1");
  }

  // src/globalCode.ts
  init_live_reload();

  // node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/index.js
  init_live_reload();

  // node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/gsap-core.js
  init_live_reload();
  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
  }
  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    subClass.__proto__ = superClass;
  }
  var _config = {
    autoSleep: 120,
    force3D: "auto",
    nullTargetWarn: 1,
    units: {
      lineHeight: ""
    }
  };
  var _defaults = {
    duration: 0.5,
    overwrite: false,
    delay: 0
  };
  var _suppressOverwrites;
  var _reverting;
  var _context;
  var _bigNum = 1e8;
  var _tinyNum = 1 / _bigNum;
  var _2PI = Math.PI * 2;
  var _HALF_PI = _2PI / 4;
  var _gsID = 0;
  var _sqrt = Math.sqrt;
  var _cos = Math.cos;
  var _sin = Math.sin;
  var _isString = function _isString2(value) {
    return typeof value === "string";
  };
  var _isFunction = function _isFunction2(value) {
    return typeof value === "function";
  };
  var _isNumber = function _isNumber2(value) {
    return typeof value === "number";
  };
  var _isUndefined = function _isUndefined2(value) {
    return typeof value === "undefined";
  };
  var _isObject = function _isObject2(value) {
    return typeof value === "object";
  };
  var _isNotFalse = function _isNotFalse2(value) {
    return value !== false;
  };
  var _windowExists = function _windowExists2() {
    return typeof window !== "undefined";
  };
  var _isFuncOrString = function _isFuncOrString2(value) {
    return _isFunction(value) || _isString(value);
  };
  var _isTypedArray = typeof ArrayBuffer === "function" && ArrayBuffer.isView || function() {
  };
  var _isArray = Array.isArray;
  var _strictNumExp = /(?:-?\.?\d|\.)+/gi;
  var _numExp = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g;
  var _numWithUnitExp = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g;
  var _complexStringNumExp = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi;
  var _relExp = /[+-]=-?[.\d]+/;
  var _delimitedValueExp = /[^,'"\[\]\s]+/gi;
  var _unitExp = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i;
  var _globalTimeline;
  var _win;
  var _coreInitted;
  var _doc;
  var _globals = {};
  var _installScope = {};
  var _coreReady;
  var _install = function _install2(scope) {
    return (_installScope = _merge(scope, _globals)) && gsap;
  };
  var _missingPlugin = function _missingPlugin2(property, value) {
    return console.warn("Invalid property", property, "set to", value, "Missing plugin? gsap.registerPlugin()");
  };
  var _warn = function _warn2(message, suppress) {
    return !suppress && console.warn(message);
  };
  var _addGlobal = function _addGlobal2(name, obj) {
    return name && (_globals[name] = obj) && _installScope && (_installScope[name] = obj) || _globals;
  };
  var _emptyFunc = function _emptyFunc2() {
    return 0;
  };
  var _startAtRevertConfig = {
    suppressEvents: true,
    isStart: true,
    kill: false
  };
  var _revertConfigNoKill = {
    suppressEvents: true,
    kill: false
  };
  var _revertConfig = {
    suppressEvents: true
  };
  var _reservedProps = {};
  var _lazyTweens = [];
  var _lazyLookup = {};
  var _lastRenderedFrame;
  var _plugins = {};
  var _effects = {};
  var _nextGCFrame = 30;
  var _harnessPlugins = [];
  var _callbackNames = "";
  var _harness = function _harness2(targets) {
    var target = targets[0], harnessPlugin, i5;
    _isObject(target) || _isFunction(target) || (targets = [targets]);
    if (!(harnessPlugin = (target._gsap || {}).harness)) {
      i5 = _harnessPlugins.length;
      while (i5-- && !_harnessPlugins[i5].targetTest(target)) {
      }
      harnessPlugin = _harnessPlugins[i5];
    }
    i5 = targets.length;
    while (i5--) {
      targets[i5] && (targets[i5]._gsap || (targets[i5]._gsap = new GSCache(targets[i5], harnessPlugin))) || targets.splice(i5, 1);
    }
    return targets;
  };
  var _getCache = function _getCache2(target) {
    return target._gsap || _harness(toArray(target))[0]._gsap;
  };
  var _getProperty = function _getProperty2(target, property, v2) {
    return (v2 = target[property]) && _isFunction(v2) ? target[property]() : _isUndefined(v2) && target.getAttribute && target.getAttribute(property) || v2;
  };
  var _forEachName = function _forEachName2(names, func) {
    return (names = names.split(",")).forEach(func) || names;
  };
  var _round = function _round2(value) {
    return Math.round(value * 1e5) / 1e5 || 0;
  };
  var _roundPrecise = function _roundPrecise2(value) {
    return Math.round(value * 1e7) / 1e7 || 0;
  };
  var _parseRelative = function _parseRelative2(start, value) {
    var operator = value.charAt(0), end = parseFloat(value.substr(2));
    start = parseFloat(start);
    return operator === "+" ? start + end : operator === "-" ? start - end : operator === "*" ? start * end : start / end;
  };
  var _arrayContainsAny = function _arrayContainsAny2(toSearch, toFind) {
    var l6 = toFind.length, i5 = 0;
    for (; toSearch.indexOf(toFind[i5]) < 0 && ++i5 < l6; ) {
    }
    return i5 < l6;
  };
  var _lazyRender = function _lazyRender2() {
    var l6 = _lazyTweens.length, a4 = _lazyTweens.slice(0), i5, tween;
    _lazyLookup = {};
    _lazyTweens.length = 0;
    for (i5 = 0; i5 < l6; i5++) {
      tween = a4[i5];
      tween && tween._lazy && (tween.render(tween._lazy[0], tween._lazy[1], true)._lazy = 0);
    }
  };
  var _lazySafeRender = function _lazySafeRender2(animation, time, suppressEvents, force) {
    _lazyTweens.length && !_reverting && _lazyRender();
    animation.render(time, suppressEvents, force || _reverting && time < 0 && (animation._initted || animation._startAt));
    _lazyTweens.length && !_reverting && _lazyRender();
  };
  var _numericIfPossible = function _numericIfPossible2(value) {
    var n6 = parseFloat(value);
    return (n6 || n6 === 0) && (value + "").match(_delimitedValueExp).length < 2 ? n6 : _isString(value) ? value.trim() : value;
  };
  var _passThrough = function _passThrough2(p2) {
    return p2;
  };
  var _setDefaults = function _setDefaults2(obj, defaults4) {
    for (var p2 in defaults4) {
      p2 in obj || (obj[p2] = defaults4[p2]);
    }
    return obj;
  };
  var _setKeyframeDefaults = function _setKeyframeDefaults2(excludeDuration) {
    return function(obj, defaults4) {
      for (var p2 in defaults4) {
        p2 in obj || p2 === "duration" && excludeDuration || p2 === "ease" || (obj[p2] = defaults4[p2]);
      }
    };
  };
  var _merge = function _merge2(base, toMerge) {
    for (var p2 in toMerge) {
      base[p2] = toMerge[p2];
    }
    return base;
  };
  var _mergeDeep = function _mergeDeep2(base, toMerge) {
    for (var p2 in toMerge) {
      p2 !== "__proto__" && p2 !== "constructor" && p2 !== "prototype" && (base[p2] = _isObject(toMerge[p2]) ? _mergeDeep2(base[p2] || (base[p2] = {}), toMerge[p2]) : toMerge[p2]);
    }
    return base;
  };
  var _copyExcluding = function _copyExcluding2(obj, excluding) {
    var copy = {}, p2;
    for (p2 in obj) {
      p2 in excluding || (copy[p2] = obj[p2]);
    }
    return copy;
  };
  var _inheritDefaults = function _inheritDefaults2(vars) {
    var parent = vars.parent || _globalTimeline, func = vars.keyframes ? _setKeyframeDefaults(_isArray(vars.keyframes)) : _setDefaults;
    if (_isNotFalse(vars.inherit)) {
      while (parent) {
        func(vars, parent.vars.defaults);
        parent = parent.parent || parent._dp;
      }
    }
    return vars;
  };
  var _arraysMatch = function _arraysMatch2(a1, a22) {
    var i5 = a1.length, match = i5 === a22.length;
    while (match && i5-- && a1[i5] === a22[i5]) {
    }
    return i5 < 0;
  };
  var _addLinkedListItem = function _addLinkedListItem2(parent, child, firstProp, lastProp, sortBy) {
    if (firstProp === void 0) {
      firstProp = "_first";
    }
    if (lastProp === void 0) {
      lastProp = "_last";
    }
    var prev = parent[lastProp], t6;
    if (sortBy) {
      t6 = child[sortBy];
      while (prev && prev[sortBy] > t6) {
        prev = prev._prev;
      }
    }
    if (prev) {
      child._next = prev._next;
      prev._next = child;
    } else {
      child._next = parent[firstProp];
      parent[firstProp] = child;
    }
    if (child._next) {
      child._next._prev = child;
    } else {
      parent[lastProp] = child;
    }
    child._prev = prev;
    child.parent = child._dp = parent;
    return child;
  };
  var _removeLinkedListItem = function _removeLinkedListItem2(parent, child, firstProp, lastProp) {
    if (firstProp === void 0) {
      firstProp = "_first";
    }
    if (lastProp === void 0) {
      lastProp = "_last";
    }
    var prev = child._prev, next = child._next;
    if (prev) {
      prev._next = next;
    } else if (parent[firstProp] === child) {
      parent[firstProp] = next;
    }
    if (next) {
      next._prev = prev;
    } else if (parent[lastProp] === child) {
      parent[lastProp] = prev;
    }
    child._next = child._prev = child.parent = null;
  };
  var _removeFromParent = function _removeFromParent2(child, onlyIfParentHasAutoRemove) {
    child.parent && (!onlyIfParentHasAutoRemove || child.parent.autoRemoveChildren) && child.parent.remove && child.parent.remove(child);
    child._act = 0;
  };
  var _uncache = function _uncache2(animation, child) {
    if (animation && (!child || child._end > animation._dur || child._start < 0)) {
      var a4 = animation;
      while (a4) {
        a4._dirty = 1;
        a4 = a4.parent;
      }
    }
    return animation;
  };
  var _recacheAncestors = function _recacheAncestors2(animation) {
    var parent = animation.parent;
    while (parent && parent.parent) {
      parent._dirty = 1;
      parent.totalDuration();
      parent = parent.parent;
    }
    return animation;
  };
  var _rewindStartAt = function _rewindStartAt2(tween, totalTime, suppressEvents, force) {
    return tween._startAt && (_reverting ? tween._startAt.revert(_revertConfigNoKill) : tween.vars.immediateRender && !tween.vars.autoRevert || tween._startAt.render(totalTime, true, force));
  };
  var _hasNoPausedAncestors = function _hasNoPausedAncestors2(animation) {
    return !animation || animation._ts && _hasNoPausedAncestors2(animation.parent);
  };
  var _elapsedCycleDuration = function _elapsedCycleDuration2(animation) {
    return animation._repeat ? _animationCycle(animation._tTime, animation = animation.duration() + animation._rDelay) * animation : 0;
  };
  var _animationCycle = function _animationCycle2(tTime, cycleDuration) {
    var whole = Math.floor(tTime /= cycleDuration);
    return tTime && whole === tTime ? whole - 1 : whole;
  };
  var _parentToChildTotalTime = function _parentToChildTotalTime2(parentTime, child) {
    return (parentTime - child._start) * child._ts + (child._ts >= 0 ? 0 : child._dirty ? child.totalDuration() : child._tDur);
  };
  var _setEnd = function _setEnd2(animation) {
    return animation._end = _roundPrecise(animation._start + (animation._tDur / Math.abs(animation._ts || animation._rts || _tinyNum) || 0));
  };
  var _alignPlayhead = function _alignPlayhead2(animation, totalTime) {
    var parent = animation._dp;
    if (parent && parent.smoothChildTiming && animation._ts) {
      animation._start = _roundPrecise(parent._time - (animation._ts > 0 ? totalTime / animation._ts : ((animation._dirty ? animation.totalDuration() : animation._tDur) - totalTime) / -animation._ts));
      _setEnd(animation);
      parent._dirty || _uncache(parent, animation);
    }
    return animation;
  };
  var _postAddChecks = function _postAddChecks2(timeline2, child) {
    var t6;
    if (child._time || !child._dur && child._initted || child._start < timeline2._time && (child._dur || !child.add)) {
      t6 = _parentToChildTotalTime(timeline2.rawTime(), child);
      if (!child._dur || _clamp(0, child.totalDuration(), t6) - child._tTime > _tinyNum) {
        child.render(t6, true);
      }
    }
    if (_uncache(timeline2, child)._dp && timeline2._initted && timeline2._time >= timeline2._dur && timeline2._ts) {
      if (timeline2._dur < timeline2.duration()) {
        t6 = timeline2;
        while (t6._dp) {
          t6.rawTime() >= 0 && t6.totalTime(t6._tTime);
          t6 = t6._dp;
        }
      }
      timeline2._zTime = -_tinyNum;
    }
  };
  var _addToTimeline = function _addToTimeline2(timeline2, child, position, skipChecks) {
    child.parent && _removeFromParent(child);
    child._start = _roundPrecise((_isNumber(position) ? position : position || timeline2 !== _globalTimeline ? _parsePosition(timeline2, position, child) : timeline2._time) + child._delay);
    child._end = _roundPrecise(child._start + (child.totalDuration() / Math.abs(child.timeScale()) || 0));
    _addLinkedListItem(timeline2, child, "_first", "_last", timeline2._sort ? "_start" : 0);
    _isFromOrFromStart(child) || (timeline2._recent = child);
    skipChecks || _postAddChecks(timeline2, child);
    timeline2._ts < 0 && _alignPlayhead(timeline2, timeline2._tTime);
    return timeline2;
  };
  var _scrollTrigger = function _scrollTrigger2(animation, trigger) {
    return (_globals.ScrollTrigger || _missingPlugin("scrollTrigger", trigger)) && _globals.ScrollTrigger.create(trigger, animation);
  };
  var _attemptInitTween = function _attemptInitTween2(tween, time, force, suppressEvents, tTime) {
    _initTween(tween, time, tTime);
    if (!tween._initted) {
      return 1;
    }
    if (!force && tween._pt && !_reverting && (tween._dur && tween.vars.lazy !== false || !tween._dur && tween.vars.lazy) && _lastRenderedFrame !== _ticker.frame) {
      _lazyTweens.push(tween);
      tween._lazy = [tTime, suppressEvents];
      return 1;
    }
  };
  var _parentPlayheadIsBeforeStart = function _parentPlayheadIsBeforeStart2(_ref) {
    var parent = _ref.parent;
    return parent && parent._ts && parent._initted && !parent._lock && (parent.rawTime() < 0 || _parentPlayheadIsBeforeStart2(parent));
  };
  var _isFromOrFromStart = function _isFromOrFromStart2(_ref2) {
    var data = _ref2.data;
    return data === "isFromStart" || data === "isStart";
  };
  var _renderZeroDurationTween = function _renderZeroDurationTween2(tween, totalTime, suppressEvents, force) {
    var prevRatio = tween.ratio, ratio = totalTime < 0 || !totalTime && (!tween._start && _parentPlayheadIsBeforeStart(tween) && !(!tween._initted && _isFromOrFromStart(tween)) || (tween._ts < 0 || tween._dp._ts < 0) && !_isFromOrFromStart(tween)) ? 0 : 1, repeatDelay = tween._rDelay, tTime = 0, pt, iteration, prevIteration;
    if (repeatDelay && tween._repeat) {
      tTime = _clamp(0, tween._tDur, totalTime);
      iteration = _animationCycle(tTime, repeatDelay);
      tween._yoyo && iteration & 1 && (ratio = 1 - ratio);
      if (iteration !== _animationCycle(tween._tTime, repeatDelay)) {
        prevRatio = 1 - ratio;
        tween.vars.repeatRefresh && tween._initted && tween.invalidate();
      }
    }
    if (ratio !== prevRatio || _reverting || force || tween._zTime === _tinyNum || !totalTime && tween._zTime) {
      if (!tween._initted && _attemptInitTween(tween, totalTime, force, suppressEvents, tTime)) {
        return;
      }
      prevIteration = tween._zTime;
      tween._zTime = totalTime || (suppressEvents ? _tinyNum : 0);
      suppressEvents || (suppressEvents = totalTime && !prevIteration);
      tween.ratio = ratio;
      tween._from && (ratio = 1 - ratio);
      tween._time = 0;
      tween._tTime = tTime;
      pt = tween._pt;
      while (pt) {
        pt.r(ratio, pt.d);
        pt = pt._next;
      }
      totalTime < 0 && _rewindStartAt(tween, totalTime, suppressEvents, true);
      tween._onUpdate && !suppressEvents && _callback(tween, "onUpdate");
      tTime && tween._repeat && !suppressEvents && tween.parent && _callback(tween, "onRepeat");
      if ((totalTime >= tween._tDur || totalTime < 0) && tween.ratio === ratio) {
        ratio && _removeFromParent(tween, 1);
        if (!suppressEvents && !_reverting) {
          _callback(tween, ratio ? "onComplete" : "onReverseComplete", true);
          tween._prom && tween._prom();
        }
      }
    } else if (!tween._zTime) {
      tween._zTime = totalTime;
    }
  };
  var _findNextPauseTween = function _findNextPauseTween2(animation, prevTime, time) {
    var child;
    if (time > prevTime) {
      child = animation._first;
      while (child && child._start <= time) {
        if (child.data === "isPause" && child._start > prevTime) {
          return child;
        }
        child = child._next;
      }
    } else {
      child = animation._last;
      while (child && child._start >= time) {
        if (child.data === "isPause" && child._start < prevTime) {
          return child;
        }
        child = child._prev;
      }
    }
  };
  var _setDuration = function _setDuration2(animation, duration, skipUncache, leavePlayhead) {
    var repeat = animation._repeat, dur = _roundPrecise(duration) || 0, totalProgress = animation._tTime / animation._tDur;
    totalProgress && !leavePlayhead && (animation._time *= dur / animation._dur);
    animation._dur = dur;
    animation._tDur = !repeat ? dur : repeat < 0 ? 1e10 : _roundPrecise(dur * (repeat + 1) + animation._rDelay * repeat);
    totalProgress > 0 && !leavePlayhead && _alignPlayhead(animation, animation._tTime = animation._tDur * totalProgress);
    animation.parent && _setEnd(animation);
    skipUncache || _uncache(animation.parent, animation);
    return animation;
  };
  var _onUpdateTotalDuration = function _onUpdateTotalDuration2(animation) {
    return animation instanceof Timeline ? _uncache(animation) : _setDuration(animation, animation._dur);
  };
  var _zeroPosition = {
    _start: 0,
    endTime: _emptyFunc,
    totalDuration: _emptyFunc
  };
  var _parsePosition = function _parsePosition2(animation, position, percentAnimation) {
    var labels = animation.labels, recent = animation._recent || _zeroPosition, clippedDuration = animation.duration() >= _bigNum ? recent.endTime(false) : animation._dur, i5, offset2, isPercent;
    if (_isString(position) && (isNaN(position) || position in labels)) {
      offset2 = position.charAt(0);
      isPercent = position.substr(-1) === "%";
      i5 = position.indexOf("=");
      if (offset2 === "<" || offset2 === ">") {
        i5 >= 0 && (position = position.replace(/=/, ""));
        return (offset2 === "<" ? recent._start : recent.endTime(recent._repeat >= 0)) + (parseFloat(position.substr(1)) || 0) * (isPercent ? (i5 < 0 ? recent : percentAnimation).totalDuration() / 100 : 1);
      }
      if (i5 < 0) {
        position in labels || (labels[position] = clippedDuration);
        return labels[position];
      }
      offset2 = parseFloat(position.charAt(i5 - 1) + position.substr(i5 + 1));
      if (isPercent && percentAnimation) {
        offset2 = offset2 / 100 * (_isArray(percentAnimation) ? percentAnimation[0] : percentAnimation).totalDuration();
      }
      return i5 > 1 ? _parsePosition2(animation, position.substr(0, i5 - 1), percentAnimation) + offset2 : clippedDuration + offset2;
    }
    return position == null ? clippedDuration : +position;
  };
  var _createTweenType = function _createTweenType2(type, params, timeline2) {
    var isLegacy = _isNumber(params[1]), varsIndex = (isLegacy ? 2 : 1) + (type < 2 ? 0 : 1), vars = params[varsIndex], irVars, parent;
    isLegacy && (vars.duration = params[1]);
    vars.parent = timeline2;
    if (type) {
      irVars = vars;
      parent = timeline2;
      while (parent && !("immediateRender" in irVars)) {
        irVars = parent.vars.defaults || {};
        parent = _isNotFalse(parent.vars.inherit) && parent.parent;
      }
      vars.immediateRender = _isNotFalse(irVars.immediateRender);
      type < 2 ? vars.runBackwards = 1 : vars.startAt = params[varsIndex - 1];
    }
    return new Tween(params[0], vars, params[varsIndex + 1]);
  };
  var _conditionalReturn = function _conditionalReturn2(value, func) {
    return value || value === 0 ? func(value) : func;
  };
  var _clamp = function _clamp2(min2, max2, value) {
    return value < min2 ? min2 : value > max2 ? max2 : value;
  };
  var getUnit = function getUnit2(value, v2) {
    return !_isString(value) || !(v2 = _unitExp.exec(value)) ? "" : v2[1];
  };
  var clamp = function clamp2(min2, max2, value) {
    return _conditionalReturn(value, function(v2) {
      return _clamp(min2, max2, v2);
    });
  };
  var _slice = [].slice;
  var _isArrayLike = function _isArrayLike2(value, nonEmpty) {
    return value && _isObject(value) && "length" in value && (!nonEmpty && !value.length || value.length - 1 in value && _isObject(value[0])) && !value.nodeType && value !== _win;
  };
  var _flatten = function _flatten2(ar, leaveStrings, accumulator) {
    if (accumulator === void 0) {
      accumulator = [];
    }
    return ar.forEach(function(value) {
      var _accumulator;
      return _isString(value) && !leaveStrings || _isArrayLike(value, 1) ? (_accumulator = accumulator).push.apply(_accumulator, toArray(value)) : accumulator.push(value);
    }) || accumulator;
  };
  var toArray = function toArray2(value, scope, leaveStrings) {
    return _context && !scope && _context.selector ? _context.selector(value) : _isString(value) && !leaveStrings && (_coreInitted || !_wake()) ? _slice.call((scope || _doc).querySelectorAll(value), 0) : _isArray(value) ? _flatten(value, leaveStrings) : _isArrayLike(value) ? _slice.call(value, 0) : value ? [value] : [];
  };
  var selector = function selector2(value) {
    value = toArray(value)[0] || _warn("Invalid scope") || {};
    return function(v2) {
      var el = value.current || value.nativeElement || value;
      return toArray(v2, el.querySelectorAll ? el : el === value ? _warn("Invalid scope") || _doc.createElement("div") : value);
    };
  };
  var shuffle = function shuffle2(a4) {
    return a4.sort(function() {
      return 0.5 - Math.random();
    });
  };
  var distribute = function distribute2(v2) {
    if (_isFunction(v2)) {
      return v2;
    }
    var vars = _isObject(v2) ? v2 : {
      each: v2
    }, ease = _parseEase(vars.ease), from = vars.from || 0, base = parseFloat(vars.base) || 0, cache2 = {}, isDecimal = from > 0 && from < 1, ratios = isNaN(from) || isDecimal, axis = vars.axis, ratioX = from, ratioY = from;
    if (_isString(from)) {
      ratioX = ratioY = {
        center: 0.5,
        edges: 0.5,
        end: 1
      }[from] || 0;
    } else if (!isDecimal && ratios) {
      ratioX = from[0];
      ratioY = from[1];
    }
    return function(i5, target, a4) {
      var l6 = (a4 || vars).length, distances = cache2[l6], originX, originY, x2, y2, d2, j2, max2, min2, wrapAt;
      if (!distances) {
        wrapAt = vars.grid === "auto" ? 0 : (vars.grid || [1, _bigNum])[1];
        if (!wrapAt) {
          max2 = -_bigNum;
          while (max2 < (max2 = a4[wrapAt++].getBoundingClientRect().left) && wrapAt < l6) {
          }
          wrapAt < l6 && wrapAt--;
        }
        distances = cache2[l6] = [];
        originX = ratios ? Math.min(wrapAt, l6) * ratioX - 0.5 : from % wrapAt;
        originY = wrapAt === _bigNum ? 0 : ratios ? l6 * ratioY / wrapAt - 0.5 : from / wrapAt | 0;
        max2 = 0;
        min2 = _bigNum;
        for (j2 = 0; j2 < l6; j2++) {
          x2 = j2 % wrapAt - originX;
          y2 = originY - (j2 / wrapAt | 0);
          distances[j2] = d2 = !axis ? _sqrt(x2 * x2 + y2 * y2) : Math.abs(axis === "y" ? y2 : x2);
          d2 > max2 && (max2 = d2);
          d2 < min2 && (min2 = d2);
        }
        from === "random" && shuffle(distances);
        distances.max = max2 - min2;
        distances.min = min2;
        distances.v = l6 = (parseFloat(vars.amount) || parseFloat(vars.each) * (wrapAt > l6 ? l6 - 1 : !axis ? Math.max(wrapAt, l6 / wrapAt) : axis === "y" ? l6 / wrapAt : wrapAt) || 0) * (from === "edges" ? -1 : 1);
        distances.b = l6 < 0 ? base - l6 : base;
        distances.u = getUnit(vars.amount || vars.each) || 0;
        ease = ease && l6 < 0 ? _invertEase(ease) : ease;
      }
      l6 = (distances[i5] - distances.min) / distances.max || 0;
      return _roundPrecise(distances.b + (ease ? ease(l6) : l6) * distances.v) + distances.u;
    };
  };
  var _roundModifier = function _roundModifier2(v2) {
    var p2 = Math.pow(10, ((v2 + "").split(".")[1] || "").length);
    return function(raw) {
      var n6 = _roundPrecise(Math.round(parseFloat(raw) / v2) * v2 * p2);
      return (n6 - n6 % 1) / p2 + (_isNumber(raw) ? 0 : getUnit(raw));
    };
  };
  var snap = function snap2(snapTo, value) {
    var isArray2 = _isArray(snapTo), radius, is2D;
    if (!isArray2 && _isObject(snapTo)) {
      radius = isArray2 = snapTo.radius || _bigNum;
      if (snapTo.values) {
        snapTo = toArray(snapTo.values);
        if (is2D = !_isNumber(snapTo[0])) {
          radius *= radius;
        }
      } else {
        snapTo = _roundModifier(snapTo.increment);
      }
    }
    return _conditionalReturn(value, !isArray2 ? _roundModifier(snapTo) : _isFunction(snapTo) ? function(raw) {
      is2D = snapTo(raw);
      return Math.abs(is2D - raw) <= radius ? is2D : raw;
    } : function(raw) {
      var x2 = parseFloat(is2D ? raw.x : raw), y2 = parseFloat(is2D ? raw.y : 0), min2 = _bigNum, closest = 0, i5 = snapTo.length, dx, dy;
      while (i5--) {
        if (is2D) {
          dx = snapTo[i5].x - x2;
          dy = snapTo[i5].y - y2;
          dx = dx * dx + dy * dy;
        } else {
          dx = Math.abs(snapTo[i5] - x2);
        }
        if (dx < min2) {
          min2 = dx;
          closest = i5;
        }
      }
      closest = !radius || min2 <= radius ? snapTo[closest] : raw;
      return is2D || closest === raw || _isNumber(raw) ? closest : closest + getUnit(raw);
    });
  };
  var random = function random2(min2, max2, roundingIncrement, returnFunction) {
    return _conditionalReturn(_isArray(min2) ? !max2 : roundingIncrement === true ? !!(roundingIncrement = 0) : !returnFunction, function() {
      return _isArray(min2) ? min2[~~(Math.random() * min2.length)] : (roundingIncrement = roundingIncrement || 1e-5) && (returnFunction = roundingIncrement < 1 ? Math.pow(10, (roundingIncrement + "").length - 2) : 1) && Math.floor(Math.round((min2 - roundingIncrement / 2 + Math.random() * (max2 - min2 + roundingIncrement * 0.99)) / roundingIncrement) * roundingIncrement * returnFunction) / returnFunction;
    });
  };
  var pipe = function pipe2() {
    for (var _len = arguments.length, functions = new Array(_len), _key = 0; _key < _len; _key++) {
      functions[_key] = arguments[_key];
    }
    return function(value) {
      return functions.reduce(function(v2, f2) {
        return f2(v2);
      }, value);
    };
  };
  var unitize = function unitize2(func, unit) {
    return function(value) {
      return func(parseFloat(value)) + (unit || getUnit(value));
    };
  };
  var normalize = function normalize2(min2, max2, value) {
    return mapRange(min2, max2, 0, 1, value);
  };
  var _wrapArray = function _wrapArray2(a4, wrapper, value) {
    return _conditionalReturn(value, function(index) {
      return a4[~~wrapper(index)];
    });
  };
  var wrap = function wrap2(min2, max2, value) {
    var range = max2 - min2;
    return _isArray(min2) ? _wrapArray(min2, wrap2(0, min2.length), max2) : _conditionalReturn(value, function(value2) {
      return (range + (value2 - min2) % range) % range + min2;
    });
  };
  var wrapYoyo = function wrapYoyo2(min2, max2, value) {
    var range = max2 - min2, total = range * 2;
    return _isArray(min2) ? _wrapArray(min2, wrapYoyo2(0, min2.length - 1), max2) : _conditionalReturn(value, function(value2) {
      value2 = (total + (value2 - min2) % total) % total || 0;
      return min2 + (value2 > range ? total - value2 : value2);
    });
  };
  var _replaceRandom = function _replaceRandom2(value) {
    var prev = 0, s5 = "", i5, nums, end, isArray2;
    while (~(i5 = value.indexOf("random(", prev))) {
      end = value.indexOf(")", i5);
      isArray2 = value.charAt(i5 + 7) === "[";
      nums = value.substr(i5 + 7, end - i5 - 7).match(isArray2 ? _delimitedValueExp : _strictNumExp);
      s5 += value.substr(prev, i5 - prev) + random(isArray2 ? nums : +nums[0], isArray2 ? 0 : +nums[1], +nums[2] || 1e-5);
      prev = end + 1;
    }
    return s5 + value.substr(prev, value.length - prev);
  };
  var mapRange = function mapRange2(inMin, inMax, outMin, outMax, value) {
    var inRange = inMax - inMin, outRange = outMax - outMin;
    return _conditionalReturn(value, function(value2) {
      return outMin + ((value2 - inMin) / inRange * outRange || 0);
    });
  };
  var interpolate = function interpolate2(start, end, progress, mutate) {
    var func = isNaN(start + end) ? 0 : function(p3) {
      return (1 - p3) * start + p3 * end;
    };
    if (!func) {
      var isString2 = _isString(start), master = {}, p2, i5, interpolators, l6, il;
      progress === true && (mutate = 1) && (progress = null);
      if (isString2) {
        start = {
          p: start
        };
        end = {
          p: end
        };
      } else if (_isArray(start) && !_isArray(end)) {
        interpolators = [];
        l6 = start.length;
        il = l6 - 2;
        for (i5 = 1; i5 < l6; i5++) {
          interpolators.push(interpolate2(start[i5 - 1], start[i5]));
        }
        l6--;
        func = function func2(p3) {
          p3 *= l6;
          var i6 = Math.min(il, ~~p3);
          return interpolators[i6](p3 - i6);
        };
        progress = end;
      } else if (!mutate) {
        start = _merge(_isArray(start) ? [] : {}, start);
      }
      if (!interpolators) {
        for (p2 in end) {
          _addPropTween.call(master, start, p2, "get", end[p2]);
        }
        func = function func2(p3) {
          return _renderPropTweens(p3, master) || (isString2 ? start.p : start);
        };
      }
    }
    return _conditionalReturn(progress, func);
  };
  var _getLabelInDirection = function _getLabelInDirection2(timeline2, fromTime, backward) {
    var labels = timeline2.labels, min2 = _bigNum, p2, distance, label;
    for (p2 in labels) {
      distance = labels[p2] - fromTime;
      if (distance < 0 === !!backward && distance && min2 > (distance = Math.abs(distance))) {
        label = p2;
        min2 = distance;
      }
    }
    return label;
  };
  var _callback = function _callback2(animation, type, executeLazyFirst) {
    var v2 = animation.vars, callback = v2[type], prevContext = _context, context3 = animation._ctx, params, scope, result;
    if (!callback) {
      return;
    }
    params = v2[type + "Params"];
    scope = v2.callbackScope || animation;
    executeLazyFirst && _lazyTweens.length && _lazyRender();
    context3 && (_context = context3);
    result = params ? callback.apply(scope, params) : callback.call(scope);
    _context = prevContext;
    return result;
  };
  var _interrupt = function _interrupt2(animation) {
    _removeFromParent(animation);
    animation.scrollTrigger && animation.scrollTrigger.kill(!!_reverting);
    animation.progress() < 1 && _callback(animation, "onInterrupt");
    return animation;
  };
  var _quickTween;
  var _registerPluginQueue = [];
  var _createPlugin = function _createPlugin2(config3) {
    if (!config3)
      return;
    config3 = !config3.name && config3["default"] || config3;
    if (_windowExists() || config3.headless) {
      var name = config3.name, isFunc = _isFunction(config3), Plugin = name && !isFunc && config3.init ? function() {
        this._props = [];
      } : config3, instanceDefaults = {
        init: _emptyFunc,
        render: _renderPropTweens,
        add: _addPropTween,
        kill: _killPropTweensOf,
        modifier: _addPluginModifier,
        rawVars: 0
      }, statics = {
        targetTest: 0,
        get: 0,
        getSetter: _getSetter,
        aliases: {},
        register: 0
      };
      _wake();
      if (config3 !== Plugin) {
        if (_plugins[name]) {
          return;
        }
        _setDefaults(Plugin, _setDefaults(_copyExcluding(config3, instanceDefaults), statics));
        _merge(Plugin.prototype, _merge(instanceDefaults, _copyExcluding(config3, statics)));
        _plugins[Plugin.prop = name] = Plugin;
        if (config3.targetTest) {
          _harnessPlugins.push(Plugin);
          _reservedProps[name] = 1;
        }
        name = (name === "css" ? "CSS" : name.charAt(0).toUpperCase() + name.substr(1)) + "Plugin";
      }
      _addGlobal(name, Plugin);
      config3.register && config3.register(gsap, Plugin, PropTween);
    } else {
      _registerPluginQueue.push(config3);
    }
  };
  var _255 = 255;
  var _colorLookup = {
    aqua: [0, _255, _255],
    lime: [0, _255, 0],
    silver: [192, 192, 192],
    black: [0, 0, 0],
    maroon: [128, 0, 0],
    teal: [0, 128, 128],
    blue: [0, 0, _255],
    navy: [0, 0, 128],
    white: [_255, _255, _255],
    olive: [128, 128, 0],
    yellow: [_255, _255, 0],
    orange: [_255, 165, 0],
    gray: [128, 128, 128],
    purple: [128, 0, 128],
    green: [0, 128, 0],
    red: [_255, 0, 0],
    pink: [_255, 192, 203],
    cyan: [0, _255, _255],
    transparent: [_255, _255, _255, 0]
  };
  var _hue = function _hue2(h5, m1, m2) {
    h5 += h5 < 0 ? 1 : h5 > 1 ? -1 : 0;
    return (h5 * 6 < 1 ? m1 + (m2 - m1) * h5 * 6 : h5 < 0.5 ? m2 : h5 * 3 < 2 ? m1 + (m2 - m1) * (2 / 3 - h5) * 6 : m1) * _255 + 0.5 | 0;
  };
  var splitColor = function splitColor2(v2, toHSL, forceAlpha) {
    var a4 = !v2 ? _colorLookup.black : _isNumber(v2) ? [v2 >> 16, v2 >> 8 & _255, v2 & _255] : 0, r5, g2, b2, h5, s5, l6, max2, min2, d2, wasHSL;
    if (!a4) {
      if (v2.substr(-1) === ",") {
        v2 = v2.substr(0, v2.length - 1);
      }
      if (_colorLookup[v2]) {
        a4 = _colorLookup[v2];
      } else if (v2.charAt(0) === "#") {
        if (v2.length < 6) {
          r5 = v2.charAt(1);
          g2 = v2.charAt(2);
          b2 = v2.charAt(3);
          v2 = "#" + r5 + r5 + g2 + g2 + b2 + b2 + (v2.length === 5 ? v2.charAt(4) + v2.charAt(4) : "");
        }
        if (v2.length === 9) {
          a4 = parseInt(v2.substr(1, 6), 16);
          return [a4 >> 16, a4 >> 8 & _255, a4 & _255, parseInt(v2.substr(7), 16) / 255];
        }
        v2 = parseInt(v2.substr(1), 16);
        a4 = [v2 >> 16, v2 >> 8 & _255, v2 & _255];
      } else if (v2.substr(0, 3) === "hsl") {
        a4 = wasHSL = v2.match(_strictNumExp);
        if (!toHSL) {
          h5 = +a4[0] % 360 / 360;
          s5 = +a4[1] / 100;
          l6 = +a4[2] / 100;
          g2 = l6 <= 0.5 ? l6 * (s5 + 1) : l6 + s5 - l6 * s5;
          r5 = l6 * 2 - g2;
          a4.length > 3 && (a4[3] *= 1);
          a4[0] = _hue(h5 + 1 / 3, r5, g2);
          a4[1] = _hue(h5, r5, g2);
          a4[2] = _hue(h5 - 1 / 3, r5, g2);
        } else if (~v2.indexOf("=")) {
          a4 = v2.match(_numExp);
          forceAlpha && a4.length < 4 && (a4[3] = 1);
          return a4;
        }
      } else {
        a4 = v2.match(_strictNumExp) || _colorLookup.transparent;
      }
      a4 = a4.map(Number);
    }
    if (toHSL && !wasHSL) {
      r5 = a4[0] / _255;
      g2 = a4[1] / _255;
      b2 = a4[2] / _255;
      max2 = Math.max(r5, g2, b2);
      min2 = Math.min(r5, g2, b2);
      l6 = (max2 + min2) / 2;
      if (max2 === min2) {
        h5 = s5 = 0;
      } else {
        d2 = max2 - min2;
        s5 = l6 > 0.5 ? d2 / (2 - max2 - min2) : d2 / (max2 + min2);
        h5 = max2 === r5 ? (g2 - b2) / d2 + (g2 < b2 ? 6 : 0) : max2 === g2 ? (b2 - r5) / d2 + 2 : (r5 - g2) / d2 + 4;
        h5 *= 60;
      }
      a4[0] = ~~(h5 + 0.5);
      a4[1] = ~~(s5 * 100 + 0.5);
      a4[2] = ~~(l6 * 100 + 0.5);
    }
    forceAlpha && a4.length < 4 && (a4[3] = 1);
    return a4;
  };
  var _colorOrderData = function _colorOrderData2(v2) {
    var values = [], c4 = [], i5 = -1;
    v2.split(_colorExp).forEach(function(v3) {
      var a4 = v3.match(_numWithUnitExp) || [];
      values.push.apply(values, a4);
      c4.push(i5 += a4.length + 1);
    });
    values.c = c4;
    return values;
  };
  var _formatColors = function _formatColors2(s5, toHSL, orderMatchData) {
    var result = "", colors = (s5 + result).match(_colorExp), type = toHSL ? "hsla(" : "rgba(", i5 = 0, c4, shell, d2, l6;
    if (!colors) {
      return s5;
    }
    colors = colors.map(function(color) {
      return (color = splitColor(color, toHSL, 1)) && type + (toHSL ? color[0] + "," + color[1] + "%," + color[2] + "%," + color[3] : color.join(",")) + ")";
    });
    if (orderMatchData) {
      d2 = _colorOrderData(s5);
      c4 = orderMatchData.c;
      if (c4.join(result) !== d2.c.join(result)) {
        shell = s5.replace(_colorExp, "1").split(_numWithUnitExp);
        l6 = shell.length - 1;
        for (; i5 < l6; i5++) {
          result += shell[i5] + (~c4.indexOf(i5) ? colors.shift() || type + "0,0,0,0)" : (d2.length ? d2 : colors.length ? colors : orderMatchData).shift());
        }
      }
    }
    if (!shell) {
      shell = s5.split(_colorExp);
      l6 = shell.length - 1;
      for (; i5 < l6; i5++) {
        result += shell[i5] + colors[i5];
      }
    }
    return result + shell[l6];
  };
  var _colorExp = function() {
    var s5 = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b", p2;
    for (p2 in _colorLookup) {
      s5 += "|" + p2 + "\\b";
    }
    return new RegExp(s5 + ")", "gi");
  }();
  var _hslExp = /hsl[a]?\(/;
  var _colorStringFilter = function _colorStringFilter2(a4) {
    var combined = a4.join(" "), toHSL;
    _colorExp.lastIndex = 0;
    if (_colorExp.test(combined)) {
      toHSL = _hslExp.test(combined);
      a4[1] = _formatColors(a4[1], toHSL);
      a4[0] = _formatColors(a4[0], toHSL, _colorOrderData(a4[1]));
      return true;
    }
  };
  var _tickerActive;
  var _ticker = function() {
    var _getTime3 = Date.now, _lagThreshold = 500, _adjustedLag = 33, _startTime = _getTime3(), _lastUpdate = _startTime, _gap = 1e3 / 240, _nextTime = _gap, _listeners3 = [], _id, _req, _raf, _self, _delta, _i2, _tick = function _tick2(v2) {
      var elapsed = _getTime3() - _lastUpdate, manual = v2 === true, overlap, dispatch, time, frame;
      (elapsed > _lagThreshold || elapsed < 0) && (_startTime += elapsed - _adjustedLag);
      _lastUpdate += elapsed;
      time = _lastUpdate - _startTime;
      overlap = time - _nextTime;
      if (overlap > 0 || manual) {
        frame = ++_self.frame;
        _delta = time - _self.time * 1e3;
        _self.time = time = time / 1e3;
        _nextTime += overlap + (overlap >= _gap ? 4 : _gap - overlap);
        dispatch = 1;
      }
      manual || (_id = _req(_tick2));
      if (dispatch) {
        for (_i2 = 0; _i2 < _listeners3.length; _i2++) {
          _listeners3[_i2](time, _delta, frame, v2);
        }
      }
    };
    _self = {
      time: 0,
      frame: 0,
      tick: function tick2() {
        _tick(true);
      },
      deltaRatio: function deltaRatio(fps) {
        return _delta / (1e3 / (fps || 60));
      },
      wake: function wake() {
        if (_coreReady) {
          if (!_coreInitted && _windowExists()) {
            _win = _coreInitted = window;
            _doc = _win.document || {};
            _globals.gsap = gsap;
            (_win.gsapVersions || (_win.gsapVersions = [])).push(gsap.version);
            _install(_installScope || _win.GreenSockGlobals || !_win.gsap && _win || {});
            _registerPluginQueue.forEach(_createPlugin);
          }
          _raf = typeof requestAnimationFrame !== "undefined" && requestAnimationFrame;
          _id && _self.sleep();
          _req = _raf || function(f2) {
            return setTimeout(f2, _nextTime - _self.time * 1e3 + 1 | 0);
          };
          _tickerActive = 1;
          _tick(2);
        }
      },
      sleep: function sleep() {
        (_raf ? cancelAnimationFrame : clearTimeout)(_id);
        _tickerActive = 0;
        _req = _emptyFunc;
      },
      lagSmoothing: function lagSmoothing(threshold, adjustedLag) {
        _lagThreshold = threshold || Infinity;
        _adjustedLag = Math.min(adjustedLag || 33, _lagThreshold);
      },
      fps: function fps(_fps) {
        _gap = 1e3 / (_fps || 240);
        _nextTime = _self.time * 1e3 + _gap;
      },
      add: function add(callback, once, prioritize) {
        var func = once ? function(t6, d2, f2, v2) {
          callback(t6, d2, f2, v2);
          _self.remove(func);
        } : callback;
        _self.remove(callback);
        _listeners3[prioritize ? "unshift" : "push"](func);
        _wake();
        return func;
      },
      remove: function remove(callback, i5) {
        ~(i5 = _listeners3.indexOf(callback)) && _listeners3.splice(i5, 1) && _i2 >= i5 && _i2--;
      },
      _listeners: _listeners3
    };
    return _self;
  }();
  var _wake = function _wake2() {
    return !_tickerActive && _ticker.wake();
  };
  var _easeMap = {};
  var _customEaseExp = /^[\d.\-M][\d.\-,\s]/;
  var _quotesExp = /["']/g;
  var _parseObjectInString = function _parseObjectInString2(value) {
    var obj = {}, split = value.substr(1, value.length - 3).split(":"), key2 = split[0], i5 = 1, l6 = split.length, index, val, parsedVal;
    for (; i5 < l6; i5++) {
      val = split[i5];
      index = i5 !== l6 - 1 ? val.lastIndexOf(",") : val.length;
      parsedVal = val.substr(0, index);
      obj[key2] = isNaN(parsedVal) ? parsedVal.replace(_quotesExp, "").trim() : +parsedVal;
      key2 = val.substr(index + 1).trim();
    }
    return obj;
  };
  var _valueInParentheses = function _valueInParentheses2(value) {
    var open = value.indexOf("(") + 1, close = value.indexOf(")"), nested = value.indexOf("(", open);
    return value.substring(open, ~nested && nested < close ? value.indexOf(")", close + 1) : close);
  };
  var _configEaseFromString = function _configEaseFromString2(name) {
    var split = (name + "").split("("), ease = _easeMap[split[0]];
    return ease && split.length > 1 && ease.config ? ease.config.apply(null, ~name.indexOf("{") ? [_parseObjectInString(split[1])] : _valueInParentheses(name).split(",").map(_numericIfPossible)) : _easeMap._CE && _customEaseExp.test(name) ? _easeMap._CE("", name) : ease;
  };
  var _invertEase = function _invertEase2(ease) {
    return function(p2) {
      return 1 - ease(1 - p2);
    };
  };
  var _propagateYoyoEase = function _propagateYoyoEase2(timeline2, isYoyo) {
    var child = timeline2._first, ease;
    while (child) {
      if (child instanceof Timeline) {
        _propagateYoyoEase2(child, isYoyo);
      } else if (child.vars.yoyoEase && (!child._yoyo || !child._repeat) && child._yoyo !== isYoyo) {
        if (child.timeline) {
          _propagateYoyoEase2(child.timeline, isYoyo);
        } else {
          ease = child._ease;
          child._ease = child._yEase;
          child._yEase = ease;
          child._yoyo = isYoyo;
        }
      }
      child = child._next;
    }
  };
  var _parseEase = function _parseEase2(ease, defaultEase) {
    return !ease ? defaultEase : (_isFunction(ease) ? ease : _easeMap[ease] || _configEaseFromString(ease)) || defaultEase;
  };
  var _insertEase = function _insertEase2(names, easeIn, easeOut, easeInOut) {
    if (easeOut === void 0) {
      easeOut = function easeOut2(p2) {
        return 1 - easeIn(1 - p2);
      };
    }
    if (easeInOut === void 0) {
      easeInOut = function easeInOut2(p2) {
        return p2 < 0.5 ? easeIn(p2 * 2) / 2 : 1 - easeIn((1 - p2) * 2) / 2;
      };
    }
    var ease = {
      easeIn,
      easeOut,
      easeInOut
    }, lowercaseName;
    _forEachName(names, function(name) {
      _easeMap[name] = _globals[name] = ease;
      _easeMap[lowercaseName = name.toLowerCase()] = easeOut;
      for (var p2 in ease) {
        _easeMap[lowercaseName + (p2 === "easeIn" ? ".in" : p2 === "easeOut" ? ".out" : ".inOut")] = _easeMap[name + "." + p2] = ease[p2];
      }
    });
    return ease;
  };
  var _easeInOutFromOut = function _easeInOutFromOut2(easeOut) {
    return function(p2) {
      return p2 < 0.5 ? (1 - easeOut(1 - p2 * 2)) / 2 : 0.5 + easeOut((p2 - 0.5) * 2) / 2;
    };
  };
  var _configElastic = function _configElastic2(type, amplitude, period) {
    var p1 = amplitude >= 1 ? amplitude : 1, p2 = (period || (type ? 0.3 : 0.45)) / (amplitude < 1 ? amplitude : 1), p3 = p2 / _2PI * (Math.asin(1 / p1) || 0), easeOut = function easeOut2(p4) {
      return p4 === 1 ? 1 : p1 * Math.pow(2, -10 * p4) * _sin((p4 - p3) * p2) + 1;
    }, ease = type === "out" ? easeOut : type === "in" ? function(p4) {
      return 1 - easeOut(1 - p4);
    } : _easeInOutFromOut(easeOut);
    p2 = _2PI / p2;
    ease.config = function(amplitude2, period2) {
      return _configElastic2(type, amplitude2, period2);
    };
    return ease;
  };
  var _configBack = function _configBack2(type, overshoot) {
    if (overshoot === void 0) {
      overshoot = 1.70158;
    }
    var easeOut = function easeOut2(p2) {
      return p2 ? --p2 * p2 * ((overshoot + 1) * p2 + overshoot) + 1 : 0;
    }, ease = type === "out" ? easeOut : type === "in" ? function(p2) {
      return 1 - easeOut(1 - p2);
    } : _easeInOutFromOut(easeOut);
    ease.config = function(overshoot2) {
      return _configBack2(type, overshoot2);
    };
    return ease;
  };
  _forEachName("Linear,Quad,Cubic,Quart,Quint,Strong", function(name, i5) {
    var power = i5 < 5 ? i5 + 1 : i5;
    _insertEase(name + ",Power" + (power - 1), i5 ? function(p2) {
      return Math.pow(p2, power);
    } : function(p2) {
      return p2;
    }, function(p2) {
      return 1 - Math.pow(1 - p2, power);
    }, function(p2) {
      return p2 < 0.5 ? Math.pow(p2 * 2, power) / 2 : 1 - Math.pow((1 - p2) * 2, power) / 2;
    });
  });
  _easeMap.Linear.easeNone = _easeMap.none = _easeMap.Linear.easeIn;
  _insertEase("Elastic", _configElastic("in"), _configElastic("out"), _configElastic());
  (function(n6, c4) {
    var n1 = 1 / c4, n22 = 2 * n1, n32 = 2.5 * n1, easeOut = function easeOut2(p2) {
      return p2 < n1 ? n6 * p2 * p2 : p2 < n22 ? n6 * Math.pow(p2 - 1.5 / c4, 2) + 0.75 : p2 < n32 ? n6 * (p2 -= 2.25 / c4) * p2 + 0.9375 : n6 * Math.pow(p2 - 2.625 / c4, 2) + 0.984375;
    };
    _insertEase("Bounce", function(p2) {
      return 1 - easeOut(1 - p2);
    }, easeOut);
  })(7.5625, 2.75);
  _insertEase("Expo", function(p2) {
    return p2 ? Math.pow(2, 10 * (p2 - 1)) : 0;
  });
  _insertEase("Circ", function(p2) {
    return -(_sqrt(1 - p2 * p2) - 1);
  });
  _insertEase("Sine", function(p2) {
    return p2 === 1 ? 1 : -_cos(p2 * _HALF_PI) + 1;
  });
  _insertEase("Back", _configBack("in"), _configBack("out"), _configBack());
  _easeMap.SteppedEase = _easeMap.steps = _globals.SteppedEase = {
    config: function config(steps, immediateStart) {
      if (steps === void 0) {
        steps = 1;
      }
      var p1 = 1 / steps, p2 = steps + (immediateStart ? 0 : 1), p3 = immediateStart ? 1 : 0, max2 = 1 - _tinyNum;
      return function(p4) {
        return ((p2 * _clamp(0, max2, p4) | 0) + p3) * p1;
      };
    }
  };
  _defaults.ease = _easeMap["quad.out"];
  _forEachName("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", function(name) {
    return _callbackNames += name + "," + name + "Params,";
  });
  var GSCache = function GSCache2(target, harness) {
    this.id = _gsID++;
    target._gsap = this;
    this.target = target;
    this.harness = harness;
    this.get = harness ? harness.get : _getProperty;
    this.set = harness ? harness.getSetter : _getSetter;
  };
  var Animation = /* @__PURE__ */ function() {
    function Animation2(vars) {
      this.vars = vars;
      this._delay = +vars.delay || 0;
      if (this._repeat = vars.repeat === Infinity ? -2 : vars.repeat || 0) {
        this._rDelay = vars.repeatDelay || 0;
        this._yoyo = !!vars.yoyo || !!vars.yoyoEase;
      }
      this._ts = 1;
      _setDuration(this, +vars.duration, 1, 1);
      this.data = vars.data;
      if (_context) {
        this._ctx = _context;
        _context.data.push(this);
      }
      _tickerActive || _ticker.wake();
    }
    var _proto = Animation2.prototype;
    _proto.delay = function delay(value) {
      if (value || value === 0) {
        this.parent && this.parent.smoothChildTiming && this.startTime(this._start + value - this._delay);
        this._delay = value;
        return this;
      }
      return this._delay;
    };
    _proto.duration = function duration(value) {
      return arguments.length ? this.totalDuration(this._repeat > 0 ? value + (value + this._rDelay) * this._repeat : value) : this.totalDuration() && this._dur;
    };
    _proto.totalDuration = function totalDuration(value) {
      if (!arguments.length) {
        return this._tDur;
      }
      this._dirty = 0;
      return _setDuration(this, this._repeat < 0 ? value : (value - this._repeat * this._rDelay) / (this._repeat + 1));
    };
    _proto.totalTime = function totalTime(_totalTime, suppressEvents) {
      _wake();
      if (!arguments.length) {
        return this._tTime;
      }
      var parent = this._dp;
      if (parent && parent.smoothChildTiming && this._ts) {
        _alignPlayhead(this, _totalTime);
        !parent._dp || parent.parent || _postAddChecks(parent, this);
        while (parent && parent.parent) {
          if (parent.parent._time !== parent._start + (parent._ts >= 0 ? parent._tTime / parent._ts : (parent.totalDuration() - parent._tTime) / -parent._ts)) {
            parent.totalTime(parent._tTime, true);
          }
          parent = parent.parent;
        }
        if (!this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && _totalTime < this._tDur || this._ts < 0 && _totalTime > 0 || !this._tDur && !_totalTime)) {
          _addToTimeline(this._dp, this, this._start - this._delay);
        }
      }
      if (this._tTime !== _totalTime || !this._dur && !suppressEvents || this._initted && Math.abs(this._zTime) === _tinyNum || !_totalTime && !this._initted && (this.add || this._ptLookup)) {
        this._ts || (this._pTime = _totalTime);
        _lazySafeRender(this, _totalTime, suppressEvents);
      }
      return this;
    };
    _proto.time = function time(value, suppressEvents) {
      return arguments.length ? this.totalTime(Math.min(this.totalDuration(), value + _elapsedCycleDuration(this)) % (this._dur + this._rDelay) || (value ? this._dur : 0), suppressEvents) : this._time;
    };
    _proto.totalProgress = function totalProgress(value, suppressEvents) {
      return arguments.length ? this.totalTime(this.totalDuration() * value, suppressEvents) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.rawTime() > 0 ? 1 : 0;
    };
    _proto.progress = function progress(value, suppressEvents) {
      return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - value : value) + _elapsedCycleDuration(this), suppressEvents) : this.duration() ? Math.min(1, this._time / this._dur) : this.rawTime() > 0 ? 1 : 0;
    };
    _proto.iteration = function iteration(value, suppressEvents) {
      var cycleDuration = this.duration() + this._rDelay;
      return arguments.length ? this.totalTime(this._time + (value - 1) * cycleDuration, suppressEvents) : this._repeat ? _animationCycle(this._tTime, cycleDuration) + 1 : 1;
    };
    _proto.timeScale = function timeScale(value, suppressEvents) {
      if (!arguments.length) {
        return this._rts === -_tinyNum ? 0 : this._rts;
      }
      if (this._rts === value) {
        return this;
      }
      var tTime = this.parent && this._ts ? _parentToChildTotalTime(this.parent._time, this) : this._tTime;
      this._rts = +value || 0;
      this._ts = this._ps || value === -_tinyNum ? 0 : this._rts;
      this.totalTime(_clamp(-Math.abs(this._delay), this._tDur, tTime), suppressEvents !== false);
      _setEnd(this);
      return _recacheAncestors(this);
    };
    _proto.paused = function paused(value) {
      if (!arguments.length) {
        return this._ps;
      }
      if (this._ps !== value) {
        this._ps = value;
        if (value) {
          this._pTime = this._tTime || Math.max(-this._delay, this.rawTime());
          this._ts = this._act = 0;
        } else {
          _wake();
          this._ts = this._rts;
          this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && Math.abs(this._zTime) !== _tinyNum && (this._tTime -= _tinyNum));
        }
      }
      return this;
    };
    _proto.startTime = function startTime(value) {
      if (arguments.length) {
        this._start = value;
        var parent = this.parent || this._dp;
        parent && (parent._sort || !this.parent) && _addToTimeline(parent, this, value - this._delay);
        return this;
      }
      return this._start;
    };
    _proto.endTime = function endTime(includeRepeats) {
      return this._start + (_isNotFalse(includeRepeats) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1);
    };
    _proto.rawTime = function rawTime(wrapRepeats) {
      var parent = this.parent || this._dp;
      return !parent ? this._tTime : wrapRepeats && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : !this._ts ? this._tTime : _parentToChildTotalTime(parent.rawTime(wrapRepeats), this);
    };
    _proto.revert = function revert(config3) {
      if (config3 === void 0) {
        config3 = _revertConfig;
      }
      var prevIsReverting = _reverting;
      _reverting = config3;
      if (this._initted || this._startAt) {
        this.timeline && this.timeline.revert(config3);
        this.totalTime(-0.01, config3.suppressEvents);
      }
      this.data !== "nested" && config3.kill !== false && this.kill();
      _reverting = prevIsReverting;
      return this;
    };
    _proto.globalTime = function globalTime(rawTime) {
      var animation = this, time = arguments.length ? rawTime : animation.rawTime();
      while (animation) {
        time = animation._start + time / (Math.abs(animation._ts) || 1);
        animation = animation._dp;
      }
      return !this.parent && this._sat ? this._sat.globalTime(rawTime) : time;
    };
    _proto.repeat = function repeat(value) {
      if (arguments.length) {
        this._repeat = value === Infinity ? -2 : value;
        return _onUpdateTotalDuration(this);
      }
      return this._repeat === -2 ? Infinity : this._repeat;
    };
    _proto.repeatDelay = function repeatDelay(value) {
      if (arguments.length) {
        var time = this._time;
        this._rDelay = value;
        _onUpdateTotalDuration(this);
        return time ? this.time(time) : this;
      }
      return this._rDelay;
    };
    _proto.yoyo = function yoyo(value) {
      if (arguments.length) {
        this._yoyo = value;
        return this;
      }
      return this._yoyo;
    };
    _proto.seek = function seek(position, suppressEvents) {
      return this.totalTime(_parsePosition(this, position), _isNotFalse(suppressEvents));
    };
    _proto.restart = function restart(includeDelay, suppressEvents) {
      return this.play().totalTime(includeDelay ? -this._delay : 0, _isNotFalse(suppressEvents));
    };
    _proto.play = function play(from, suppressEvents) {
      from != null && this.seek(from, suppressEvents);
      return this.reversed(false).paused(false);
    };
    _proto.reverse = function reverse(from, suppressEvents) {
      from != null && this.seek(from || this.totalDuration(), suppressEvents);
      return this.reversed(true).paused(false);
    };
    _proto.pause = function pause(atTime, suppressEvents) {
      atTime != null && this.seek(atTime, suppressEvents);
      return this.paused(true);
    };
    _proto.resume = function resume() {
      return this.paused(false);
    };
    _proto.reversed = function reversed(value) {
      if (arguments.length) {
        !!value !== this.reversed() && this.timeScale(-this._rts || (value ? -_tinyNum : 0));
        return this;
      }
      return this._rts < 0;
    };
    _proto.invalidate = function invalidate() {
      this._initted = this._act = 0;
      this._zTime = -_tinyNum;
      return this;
    };
    _proto.isActive = function isActive() {
      var parent = this.parent || this._dp, start = this._start, rawTime;
      return !!(!parent || this._ts && this._initted && parent.isActive() && (rawTime = parent.rawTime(true)) >= start && rawTime < this.endTime(true) - _tinyNum);
    };
    _proto.eventCallback = function eventCallback(type, callback, params) {
      var vars = this.vars;
      if (arguments.length > 1) {
        if (!callback) {
          delete vars[type];
        } else {
          vars[type] = callback;
          params && (vars[type + "Params"] = params);
          type === "onUpdate" && (this._onUpdate = callback);
        }
        return this;
      }
      return vars[type];
    };
    _proto.then = function then(onFulfilled) {
      var self = this;
      return new Promise(function(resolve) {
        var f2 = _isFunction(onFulfilled) ? onFulfilled : _passThrough, _resolve = function _resolve2() {
          var _then = self.then;
          self.then = null;
          _isFunction(f2) && (f2 = f2(self)) && (f2.then || f2 === self) && (self.then = _then);
          resolve(f2);
          self.then = _then;
        };
        if (self._initted && self.totalProgress() === 1 && self._ts >= 0 || !self._tTime && self._ts < 0) {
          _resolve();
        } else {
          self._prom = _resolve;
        }
      });
    };
    _proto.kill = function kill2() {
      _interrupt(this);
    };
    return Animation2;
  }();
  _setDefaults(Animation.prototype, {
    _time: 0,
    _start: 0,
    _end: 0,
    _tTime: 0,
    _tDur: 0,
    _dirty: 0,
    _repeat: 0,
    _yoyo: false,
    parent: null,
    _initted: false,
    _rDelay: 0,
    _ts: 1,
    _dp: 0,
    ratio: 0,
    _zTime: -_tinyNum,
    _prom: 0,
    _ps: false,
    _rts: 1
  });
  var Timeline = /* @__PURE__ */ function(_Animation) {
    _inheritsLoose(Timeline2, _Animation);
    function Timeline2(vars, position) {
      var _this;
      if (vars === void 0) {
        vars = {};
      }
      _this = _Animation.call(this, vars) || this;
      _this.labels = {};
      _this.smoothChildTiming = !!vars.smoothChildTiming;
      _this.autoRemoveChildren = !!vars.autoRemoveChildren;
      _this._sort = _isNotFalse(vars.sortChildren);
      _globalTimeline && _addToTimeline(vars.parent || _globalTimeline, _assertThisInitialized(_this), position);
      vars.reversed && _this.reverse();
      vars.paused && _this.paused(true);
      vars.scrollTrigger && _scrollTrigger(_assertThisInitialized(_this), vars.scrollTrigger);
      return _this;
    }
    var _proto2 = Timeline2.prototype;
    _proto2.to = function to(targets, vars, position) {
      _createTweenType(0, arguments, this);
      return this;
    };
    _proto2.from = function from(targets, vars, position) {
      _createTweenType(1, arguments, this);
      return this;
    };
    _proto2.fromTo = function fromTo(targets, fromVars, toVars, position) {
      _createTweenType(2, arguments, this);
      return this;
    };
    _proto2.set = function set(targets, vars, position) {
      vars.duration = 0;
      vars.parent = this;
      _inheritDefaults(vars).repeatDelay || (vars.repeat = 0);
      vars.immediateRender = !!vars.immediateRender;
      new Tween(targets, vars, _parsePosition(this, position), 1);
      return this;
    };
    _proto2.call = function call(callback, params, position) {
      return _addToTimeline(this, Tween.delayedCall(0, callback, params), position);
    };
    _proto2.staggerTo = function staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {
      vars.duration = duration;
      vars.stagger = vars.stagger || stagger;
      vars.onComplete = onCompleteAll;
      vars.onCompleteParams = onCompleteAllParams;
      vars.parent = this;
      new Tween(targets, vars, _parsePosition(this, position));
      return this;
    };
    _proto2.staggerFrom = function staggerFrom(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {
      vars.runBackwards = 1;
      _inheritDefaults(vars).immediateRender = _isNotFalse(vars.immediateRender);
      return this.staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams);
    };
    _proto2.staggerFromTo = function staggerFromTo(targets, duration, fromVars, toVars, stagger, position, onCompleteAll, onCompleteAllParams) {
      toVars.startAt = fromVars;
      _inheritDefaults(toVars).immediateRender = _isNotFalse(toVars.immediateRender);
      return this.staggerTo(targets, duration, toVars, stagger, position, onCompleteAll, onCompleteAllParams);
    };
    _proto2.render = function render4(totalTime, suppressEvents, force) {
      var prevTime = this._time, tDur = this._dirty ? this.totalDuration() : this._tDur, dur = this._dur, tTime = totalTime <= 0 ? 0 : _roundPrecise(totalTime), crossingStart = this._zTime < 0 !== totalTime < 0 && (this._initted || !dur), time, child, next, iteration, cycleDuration, prevPaused, pauseTween, timeScale, prevStart, prevIteration, yoyo, isYoyo;
      this !== _globalTimeline && tTime > tDur && totalTime >= 0 && (tTime = tDur);
      if (tTime !== this._tTime || force || crossingStart) {
        if (prevTime !== this._time && dur) {
          tTime += this._time - prevTime;
          totalTime += this._time - prevTime;
        }
        time = tTime;
        prevStart = this._start;
        timeScale = this._ts;
        prevPaused = !timeScale;
        if (crossingStart) {
          dur || (prevTime = this._zTime);
          (totalTime || !suppressEvents) && (this._zTime = totalTime);
        }
        if (this._repeat) {
          yoyo = this._yoyo;
          cycleDuration = dur + this._rDelay;
          if (this._repeat < -1 && totalTime < 0) {
            return this.totalTime(cycleDuration * 100 + totalTime, suppressEvents, force);
          }
          time = _roundPrecise(tTime % cycleDuration);
          if (tTime === tDur) {
            iteration = this._repeat;
            time = dur;
          } else {
            iteration = ~~(tTime / cycleDuration);
            if (iteration && iteration === tTime / cycleDuration) {
              time = dur;
              iteration--;
            }
            time > dur && (time = dur);
          }
          prevIteration = _animationCycle(this._tTime, cycleDuration);
          !prevTime && this._tTime && prevIteration !== iteration && this._tTime - prevIteration * cycleDuration - this._dur <= 0 && (prevIteration = iteration);
          if (yoyo && iteration & 1) {
            time = dur - time;
            isYoyo = 1;
          }
          if (iteration !== prevIteration && !this._lock) {
            var rewinding = yoyo && prevIteration & 1, doesWrap = rewinding === (yoyo && iteration & 1);
            iteration < prevIteration && (rewinding = !rewinding);
            prevTime = rewinding ? 0 : tTime % dur ? dur : tTime;
            this._lock = 1;
            this.render(prevTime || (isYoyo ? 0 : _roundPrecise(iteration * cycleDuration)), suppressEvents, !dur)._lock = 0;
            this._tTime = tTime;
            !suppressEvents && this.parent && _callback(this, "onRepeat");
            this.vars.repeatRefresh && !isYoyo && (this.invalidate()._lock = 1);
            if (prevTime && prevTime !== this._time || prevPaused !== !this._ts || this.vars.onRepeat && !this.parent && !this._act) {
              return this;
            }
            dur = this._dur;
            tDur = this._tDur;
            if (doesWrap) {
              this._lock = 2;
              prevTime = rewinding ? dur : -1e-4;
              this.render(prevTime, true);
              this.vars.repeatRefresh && !isYoyo && this.invalidate();
            }
            this._lock = 0;
            if (!this._ts && !prevPaused) {
              return this;
            }
            _propagateYoyoEase(this, isYoyo);
          }
        }
        if (this._hasPause && !this._forcing && this._lock < 2) {
          pauseTween = _findNextPauseTween(this, _roundPrecise(prevTime), _roundPrecise(time));
          if (pauseTween) {
            tTime -= time - (time = pauseTween._start);
          }
        }
        this._tTime = tTime;
        this._time = time;
        this._act = !timeScale;
        if (!this._initted) {
          this._onUpdate = this.vars.onUpdate;
          this._initted = 1;
          this._zTime = totalTime;
          prevTime = 0;
        }
        if (!prevTime && time && !suppressEvents && !iteration) {
          _callback(this, "onStart");
          if (this._tTime !== tTime) {
            return this;
          }
        }
        if (time >= prevTime && totalTime >= 0) {
          child = this._first;
          while (child) {
            next = child._next;
            if ((child._act || time >= child._start) && child._ts && pauseTween !== child) {
              if (child.parent !== this) {
                return this.render(totalTime, suppressEvents, force);
              }
              child.render(child._ts > 0 ? (time - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (time - child._start) * child._ts, suppressEvents, force);
              if (time !== this._time || !this._ts && !prevPaused) {
                pauseTween = 0;
                next && (tTime += this._zTime = -_tinyNum);
                break;
              }
            }
            child = next;
          }
        } else {
          child = this._last;
          var adjustedTime = totalTime < 0 ? totalTime : time;
          while (child) {
            next = child._prev;
            if ((child._act || adjustedTime <= child._end) && child._ts && pauseTween !== child) {
              if (child.parent !== this) {
                return this.render(totalTime, suppressEvents, force);
              }
              child.render(child._ts > 0 ? (adjustedTime - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (adjustedTime - child._start) * child._ts, suppressEvents, force || _reverting && (child._initted || child._startAt));
              if (time !== this._time || !this._ts && !prevPaused) {
                pauseTween = 0;
                next && (tTime += this._zTime = adjustedTime ? -_tinyNum : _tinyNum);
                break;
              }
            }
            child = next;
          }
        }
        if (pauseTween && !suppressEvents) {
          this.pause();
          pauseTween.render(time >= prevTime ? 0 : -_tinyNum)._zTime = time >= prevTime ? 1 : -1;
          if (this._ts) {
            this._start = prevStart;
            _setEnd(this);
            return this.render(totalTime, suppressEvents, force);
          }
        }
        this._onUpdate && !suppressEvents && _callback(this, "onUpdate", true);
        if (tTime === tDur && this._tTime >= this.totalDuration() || !tTime && prevTime) {
          if (prevStart === this._start || Math.abs(timeScale) !== Math.abs(this._ts)) {
            if (!this._lock) {
              (totalTime || !dur) && (tTime === tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1);
              if (!suppressEvents && !(totalTime < 0 && !prevTime) && (tTime || prevTime || !tDur)) {
                _callback(this, tTime === tDur && totalTime >= 0 ? "onComplete" : "onReverseComplete", true);
                this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();
              }
            }
          }
        }
      }
      return this;
    };
    _proto2.add = function add(child, position) {
      var _this2 = this;
      _isNumber(position) || (position = _parsePosition(this, position, child));
      if (!(child instanceof Animation)) {
        if (_isArray(child)) {
          child.forEach(function(obj) {
            return _this2.add(obj, position);
          });
          return this;
        }
        if (_isString(child)) {
          return this.addLabel(child, position);
        }
        if (_isFunction(child)) {
          child = Tween.delayedCall(0, child);
        } else {
          return this;
        }
      }
      return this !== child ? _addToTimeline(this, child, position) : this;
    };
    _proto2.getChildren = function getChildren(nested, tweens, timelines, ignoreBeforeTime) {
      if (nested === void 0) {
        nested = true;
      }
      if (tweens === void 0) {
        tweens = true;
      }
      if (timelines === void 0) {
        timelines = true;
      }
      if (ignoreBeforeTime === void 0) {
        ignoreBeforeTime = -_bigNum;
      }
      var a4 = [], child = this._first;
      while (child) {
        if (child._start >= ignoreBeforeTime) {
          if (child instanceof Tween) {
            tweens && a4.push(child);
          } else {
            timelines && a4.push(child);
            nested && a4.push.apply(a4, child.getChildren(true, tweens, timelines));
          }
        }
        child = child._next;
      }
      return a4;
    };
    _proto2.getById = function getById2(id) {
      var animations = this.getChildren(1, 1, 1), i5 = animations.length;
      while (i5--) {
        if (animations[i5].vars.id === id) {
          return animations[i5];
        }
      }
    };
    _proto2.remove = function remove(child) {
      if (_isString(child)) {
        return this.removeLabel(child);
      }
      if (_isFunction(child)) {
        return this.killTweensOf(child);
      }
      _removeLinkedListItem(this, child);
      if (child === this._recent) {
        this._recent = this._last;
      }
      return _uncache(this);
    };
    _proto2.totalTime = function totalTime(_totalTime2, suppressEvents) {
      if (!arguments.length) {
        return this._tTime;
      }
      this._forcing = 1;
      if (!this._dp && this._ts) {
        this._start = _roundPrecise(_ticker.time - (this._ts > 0 ? _totalTime2 / this._ts : (this.totalDuration() - _totalTime2) / -this._ts));
      }
      _Animation.prototype.totalTime.call(this, _totalTime2, suppressEvents);
      this._forcing = 0;
      return this;
    };
    _proto2.addLabel = function addLabel(label, position) {
      this.labels[label] = _parsePosition(this, position);
      return this;
    };
    _proto2.removeLabel = function removeLabel(label) {
      delete this.labels[label];
      return this;
    };
    _proto2.addPause = function addPause(position, callback, params) {
      var t6 = Tween.delayedCall(0, callback || _emptyFunc, params);
      t6.data = "isPause";
      this._hasPause = 1;
      return _addToTimeline(this, t6, _parsePosition(this, position));
    };
    _proto2.removePause = function removePause(position) {
      var child = this._first;
      position = _parsePosition(this, position);
      while (child) {
        if (child._start === position && child.data === "isPause") {
          _removeFromParent(child);
        }
        child = child._next;
      }
    };
    _proto2.killTweensOf = function killTweensOf(targets, props, onlyActive) {
      var tweens = this.getTweensOf(targets, onlyActive), i5 = tweens.length;
      while (i5--) {
        _overwritingTween !== tweens[i5] && tweens[i5].kill(targets, props);
      }
      return this;
    };
    _proto2.getTweensOf = function getTweensOf2(targets, onlyActive) {
      var a4 = [], parsedTargets = toArray(targets), child = this._first, isGlobalTime = _isNumber(onlyActive), children;
      while (child) {
        if (child instanceof Tween) {
          if (_arrayContainsAny(child._targets, parsedTargets) && (isGlobalTime ? (!_overwritingTween || child._initted && child._ts) && child.globalTime(0) <= onlyActive && child.globalTime(child.totalDuration()) > onlyActive : !onlyActive || child.isActive())) {
            a4.push(child);
          }
        } else if ((children = child.getTweensOf(parsedTargets, onlyActive)).length) {
          a4.push.apply(a4, children);
        }
        child = child._next;
      }
      return a4;
    };
    _proto2.tweenTo = function tweenTo(position, vars) {
      vars = vars || {};
      var tl = this, endTime = _parsePosition(tl, position), _vars = vars, startAt = _vars.startAt, _onStart = _vars.onStart, onStartParams = _vars.onStartParams, immediateRender = _vars.immediateRender, initted, tween = Tween.to(tl, _setDefaults({
        ease: vars.ease || "none",
        lazy: false,
        immediateRender: false,
        time: endTime,
        overwrite: "auto",
        duration: vars.duration || Math.abs((endTime - (startAt && "time" in startAt ? startAt.time : tl._time)) / tl.timeScale()) || _tinyNum,
        onStart: function onStart() {
          tl.pause();
          if (!initted) {
            var duration = vars.duration || Math.abs((endTime - (startAt && "time" in startAt ? startAt.time : tl._time)) / tl.timeScale());
            tween._dur !== duration && _setDuration(tween, duration, 0, 1).render(tween._time, true, true);
            initted = 1;
          }
          _onStart && _onStart.apply(tween, onStartParams || []);
        }
      }, vars));
      return immediateRender ? tween.render(0) : tween;
    };
    _proto2.tweenFromTo = function tweenFromTo(fromPosition, toPosition, vars) {
      return this.tweenTo(toPosition, _setDefaults({
        startAt: {
          time: _parsePosition(this, fromPosition)
        }
      }, vars));
    };
    _proto2.recent = function recent() {
      return this._recent;
    };
    _proto2.nextLabel = function nextLabel(afterTime) {
      if (afterTime === void 0) {
        afterTime = this._time;
      }
      return _getLabelInDirection(this, _parsePosition(this, afterTime));
    };
    _proto2.previousLabel = function previousLabel(beforeTime) {
      if (beforeTime === void 0) {
        beforeTime = this._time;
      }
      return _getLabelInDirection(this, _parsePosition(this, beforeTime), 1);
    };
    _proto2.currentLabel = function currentLabel(value) {
      return arguments.length ? this.seek(value, true) : this.previousLabel(this._time + _tinyNum);
    };
    _proto2.shiftChildren = function shiftChildren(amount, adjustLabels, ignoreBeforeTime) {
      if (ignoreBeforeTime === void 0) {
        ignoreBeforeTime = 0;
      }
      var child = this._first, labels = this.labels, p2;
      while (child) {
        if (child._start >= ignoreBeforeTime) {
          child._start += amount;
          child._end += amount;
        }
        child = child._next;
      }
      if (adjustLabels) {
        for (p2 in labels) {
          if (labels[p2] >= ignoreBeforeTime) {
            labels[p2] += amount;
          }
        }
      }
      return _uncache(this);
    };
    _proto2.invalidate = function invalidate(soft) {
      var child = this._first;
      this._lock = 0;
      while (child) {
        child.invalidate(soft);
        child = child._next;
      }
      return _Animation.prototype.invalidate.call(this, soft);
    };
    _proto2.clear = function clear(includeLabels) {
      if (includeLabels === void 0) {
        includeLabels = true;
      }
      var child = this._first, next;
      while (child) {
        next = child._next;
        this.remove(child);
        child = next;
      }
      this._dp && (this._time = this._tTime = this._pTime = 0);
      includeLabels && (this.labels = {});
      return _uncache(this);
    };
    _proto2.totalDuration = function totalDuration(value) {
      var max2 = 0, self = this, child = self._last, prevStart = _bigNum, prev, start, parent;
      if (arguments.length) {
        return self.timeScale((self._repeat < 0 ? self.duration() : self.totalDuration()) / (self.reversed() ? -value : value));
      }
      if (self._dirty) {
        parent = self.parent;
        while (child) {
          prev = child._prev;
          child._dirty && child.totalDuration();
          start = child._start;
          if (start > prevStart && self._sort && child._ts && !self._lock) {
            self._lock = 1;
            _addToTimeline(self, child, start - child._delay, 1)._lock = 0;
          } else {
            prevStart = start;
          }
          if (start < 0 && child._ts) {
            max2 -= start;
            if (!parent && !self._dp || parent && parent.smoothChildTiming) {
              self._start += start / self._ts;
              self._time -= start;
              self._tTime -= start;
            }
            self.shiftChildren(-start, false, -Infinity);
            prevStart = 0;
          }
          child._end > max2 && child._ts && (max2 = child._end);
          child = prev;
        }
        _setDuration(self, self === _globalTimeline && self._time > max2 ? self._time : max2, 1, 1);
        self._dirty = 0;
      }
      return self._tDur;
    };
    Timeline2.updateRoot = function updateRoot(time) {
      if (_globalTimeline._ts) {
        _lazySafeRender(_globalTimeline, _parentToChildTotalTime(time, _globalTimeline));
        _lastRenderedFrame = _ticker.frame;
      }
      if (_ticker.frame >= _nextGCFrame) {
        _nextGCFrame += _config.autoSleep || 120;
        var child = _globalTimeline._first;
        if (!child || !child._ts) {
          if (_config.autoSleep && _ticker._listeners.length < 2) {
            while (child && !child._ts) {
              child = child._next;
            }
            child || _ticker.sleep();
          }
        }
      }
    };
    return Timeline2;
  }(Animation);
  _setDefaults(Timeline.prototype, {
    _lock: 0,
    _hasPause: 0,
    _forcing: 0
  });
  var _addComplexStringPropTween = function _addComplexStringPropTween2(target, prop2, start, end, setter, stringFilter, funcParam) {
    var pt = new PropTween(this._pt, target, prop2, 0, 1, _renderComplexString, null, setter), index = 0, matchIndex = 0, result, startNums, color, endNum, chunk, startNum, hasRandom, a4;
    pt.b = start;
    pt.e = end;
    start += "";
    end += "";
    if (hasRandom = ~end.indexOf("random(")) {
      end = _replaceRandom(end);
    }
    if (stringFilter) {
      a4 = [start, end];
      stringFilter(a4, target, prop2);
      start = a4[0];
      end = a4[1];
    }
    startNums = start.match(_complexStringNumExp) || [];
    while (result = _complexStringNumExp.exec(end)) {
      endNum = result[0];
      chunk = end.substring(index, result.index);
      if (color) {
        color = (color + 1) % 5;
      } else if (chunk.substr(-5) === "rgba(") {
        color = 1;
      }
      if (endNum !== startNums[matchIndex++]) {
        startNum = parseFloat(startNums[matchIndex - 1]) || 0;
        pt._pt = {
          _next: pt._pt,
          p: chunk || matchIndex === 1 ? chunk : ",",
          //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.
          s: startNum,
          c: endNum.charAt(1) === "=" ? _parseRelative(startNum, endNum) - startNum : parseFloat(endNum) - startNum,
          m: color && color < 4 ? Math.round : 0
        };
        index = _complexStringNumExp.lastIndex;
      }
    }
    pt.c = index < end.length ? end.substring(index, end.length) : "";
    pt.fp = funcParam;
    if (_relExp.test(end) || hasRandom) {
      pt.e = 0;
    }
    this._pt = pt;
    return pt;
  };
  var _addPropTween = function _addPropTween2(target, prop2, start, end, index, targets, modifier, stringFilter, funcParam, optional) {
    _isFunction(end) && (end = end(index || 0, target, targets));
    var currentValue = target[prop2], parsedStart = start !== "get" ? start : !_isFunction(currentValue) ? currentValue : funcParam ? target[prop2.indexOf("set") || !_isFunction(target["get" + prop2.substr(3)]) ? prop2 : "get" + prop2.substr(3)](funcParam) : target[prop2](), setter = !_isFunction(currentValue) ? _setterPlain : funcParam ? _setterFuncWithParam : _setterFunc, pt;
    if (_isString(end)) {
      if (~end.indexOf("random(")) {
        end = _replaceRandom(end);
      }
      if (end.charAt(1) === "=") {
        pt = _parseRelative(parsedStart, end) + (getUnit(parsedStart) || 0);
        if (pt || pt === 0) {
          end = pt;
        }
      }
    }
    if (!optional || parsedStart !== end || _forceAllPropTweens) {
      if (!isNaN(parsedStart * end) && end !== "") {
        pt = new PropTween(this._pt, target, prop2, +parsedStart || 0, end - (parsedStart || 0), typeof currentValue === "boolean" ? _renderBoolean : _renderPlain, 0, setter);
        funcParam && (pt.fp = funcParam);
        modifier && pt.modifier(modifier, this, target);
        return this._pt = pt;
      }
      !currentValue && !(prop2 in target) && _missingPlugin(prop2, end);
      return _addComplexStringPropTween.call(this, target, prop2, parsedStart, end, setter, stringFilter || _config.stringFilter, funcParam);
    }
  };
  var _processVars = function _processVars2(vars, index, target, targets, tween) {
    _isFunction(vars) && (vars = _parseFuncOrString(vars, tween, index, target, targets));
    if (!_isObject(vars) || vars.style && vars.nodeType || _isArray(vars) || _isTypedArray(vars)) {
      return _isString(vars) ? _parseFuncOrString(vars, tween, index, target, targets) : vars;
    }
    var copy = {}, p2;
    for (p2 in vars) {
      copy[p2] = _parseFuncOrString(vars[p2], tween, index, target, targets);
    }
    return copy;
  };
  var _checkPlugin = function _checkPlugin2(property, vars, tween, index, target, targets) {
    var plugin, pt, ptLookup, i5;
    if (_plugins[property] && (plugin = new _plugins[property]()).init(target, plugin.rawVars ? vars[property] : _processVars(vars[property], index, target, targets, tween), tween, index, targets) !== false) {
      tween._pt = pt = new PropTween(tween._pt, target, property, 0, 1, plugin.render, plugin, 0, plugin.priority);
      if (tween !== _quickTween) {
        ptLookup = tween._ptLookup[tween._targets.indexOf(target)];
        i5 = plugin._props.length;
        while (i5--) {
          ptLookup[plugin._props[i5]] = pt;
        }
      }
    }
    return plugin;
  };
  var _overwritingTween;
  var _forceAllPropTweens;
  var _initTween = function _initTween2(tween, time, tTime) {
    var vars = tween.vars, ease = vars.ease, startAt = vars.startAt, immediateRender = vars.immediateRender, lazy = vars.lazy, onUpdate = vars.onUpdate, runBackwards = vars.runBackwards, yoyoEase = vars.yoyoEase, keyframes = vars.keyframes, autoRevert = vars.autoRevert, dur = tween._dur, prevStartAt = tween._startAt, targets = tween._targets, parent = tween.parent, fullTargets = parent && parent.data === "nested" ? parent.vars.targets : targets, autoOverwrite = tween._overwrite === "auto" && !_suppressOverwrites, tl = tween.timeline, cleanVars, i5, p2, pt, target, hasPriority, gsData, harness, plugin, ptLookup, index, harnessVars, overwritten;
    tl && (!keyframes || !ease) && (ease = "none");
    tween._ease = _parseEase(ease, _defaults.ease);
    tween._yEase = yoyoEase ? _invertEase(_parseEase(yoyoEase === true ? ease : yoyoEase, _defaults.ease)) : 0;
    if (yoyoEase && tween._yoyo && !tween._repeat) {
      yoyoEase = tween._yEase;
      tween._yEase = tween._ease;
      tween._ease = yoyoEase;
    }
    tween._from = !tl && !!vars.runBackwards;
    if (!tl || keyframes && !vars.stagger) {
      harness = targets[0] ? _getCache(targets[0]).harness : 0;
      harnessVars = harness && vars[harness.prop];
      cleanVars = _copyExcluding(vars, _reservedProps);
      if (prevStartAt) {
        prevStartAt._zTime < 0 && prevStartAt.progress(1);
        time < 0 && runBackwards && immediateRender && !autoRevert ? prevStartAt.render(-1, true) : prevStartAt.revert(runBackwards && dur ? _revertConfigNoKill : _startAtRevertConfig);
        prevStartAt._lazy = 0;
      }
      if (startAt) {
        _removeFromParent(tween._startAt = Tween.set(targets, _setDefaults({
          data: "isStart",
          overwrite: false,
          parent,
          immediateRender: true,
          lazy: !prevStartAt && _isNotFalse(lazy),
          startAt: null,
          delay: 0,
          onUpdate: onUpdate && function() {
            return _callback(tween, "onUpdate");
          },
          stagger: 0
        }, startAt)));
        tween._startAt._dp = 0;
        tween._startAt._sat = tween;
        time < 0 && (_reverting || !immediateRender && !autoRevert) && tween._startAt.revert(_revertConfigNoKill);
        if (immediateRender) {
          if (dur && time <= 0 && tTime <= 0) {
            time && (tween._zTime = time);
            return;
          }
        }
      } else if (runBackwards && dur) {
        if (!prevStartAt) {
          time && (immediateRender = false);
          p2 = _setDefaults({
            overwrite: false,
            data: "isFromStart",
            //we tag the tween with as "isFromStart" so that if [inside a plugin] we need to only do something at the very END of a tween, we have a way of identifying this tween as merely the one that's setting the beginning values for a "from()" tween. For example, clearProps in CSSPlugin should only get applied at the very END of a tween and without this tag, from(...{height:100, clearProps:"height", delay:1}) would wipe the height at the beginning of the tween and after 1 second, it'd kick back in.
            lazy: immediateRender && !prevStartAt && _isNotFalse(lazy),
            immediateRender,
            //zero-duration tweens render immediately by default, but if we're not specifically instructed to render this tween immediately, we should skip this and merely _init() to record the starting values (rendering them immediately would push them to completion which is wasteful in that case - we'd have to render(-1) immediately after)
            stagger: 0,
            parent
            //ensures that nested tweens that had a stagger are handled properly, like gsap.from(".class", {y: gsap.utils.wrap([-100,100]), stagger: 0.5})
          }, cleanVars);
          harnessVars && (p2[harness.prop] = harnessVars);
          _removeFromParent(tween._startAt = Tween.set(targets, p2));
          tween._startAt._dp = 0;
          tween._startAt._sat = tween;
          time < 0 && (_reverting ? tween._startAt.revert(_revertConfigNoKill) : tween._startAt.render(-1, true));
          tween._zTime = time;
          if (!immediateRender) {
            _initTween2(tween._startAt, _tinyNum, _tinyNum);
          } else if (!time) {
            return;
          }
        }
      }
      tween._pt = tween._ptCache = 0;
      lazy = dur && _isNotFalse(lazy) || lazy && !dur;
      for (i5 = 0; i5 < targets.length; i5++) {
        target = targets[i5];
        gsData = target._gsap || _harness(targets)[i5]._gsap;
        tween._ptLookup[i5] = ptLookup = {};
        _lazyLookup[gsData.id] && _lazyTweens.length && _lazyRender();
        index = fullTargets === targets ? i5 : fullTargets.indexOf(target);
        if (harness && (plugin = new harness()).init(target, harnessVars || cleanVars, tween, index, fullTargets) !== false) {
          tween._pt = pt = new PropTween(tween._pt, target, plugin.name, 0, 1, plugin.render, plugin, 0, plugin.priority);
          plugin._props.forEach(function(name) {
            ptLookup[name] = pt;
          });
          plugin.priority && (hasPriority = 1);
        }
        if (!harness || harnessVars) {
          for (p2 in cleanVars) {
            if (_plugins[p2] && (plugin = _checkPlugin(p2, cleanVars, tween, index, target, fullTargets))) {
              plugin.priority && (hasPriority = 1);
            } else {
              ptLookup[p2] = pt = _addPropTween.call(tween, target, p2, "get", cleanVars[p2], index, fullTargets, 0, vars.stringFilter);
            }
          }
        }
        tween._op && tween._op[i5] && tween.kill(target, tween._op[i5]);
        if (autoOverwrite && tween._pt) {
          _overwritingTween = tween;
          _globalTimeline.killTweensOf(target, ptLookup, tween.globalTime(time));
          overwritten = !tween.parent;
          _overwritingTween = 0;
        }
        tween._pt && lazy && (_lazyLookup[gsData.id] = 1);
      }
      hasPriority && _sortPropTweensByPriority(tween);
      tween._onInit && tween._onInit(tween);
    }
    tween._onUpdate = onUpdate;
    tween._initted = (!tween._op || tween._pt) && !overwritten;
    keyframes && time <= 0 && tl.render(_bigNum, true, true);
  };
  var _updatePropTweens = function _updatePropTweens2(tween, property, value, start, startIsRelative, ratio, time, skipRecursion) {
    var ptCache = (tween._pt && tween._ptCache || (tween._ptCache = {}))[property], pt, rootPT, lookup, i5;
    if (!ptCache) {
      ptCache = tween._ptCache[property] = [];
      lookup = tween._ptLookup;
      i5 = tween._targets.length;
      while (i5--) {
        pt = lookup[i5][property];
        if (pt && pt.d && pt.d._pt) {
          pt = pt.d._pt;
          while (pt && pt.p !== property && pt.fp !== property) {
            pt = pt._next;
          }
        }
        if (!pt) {
          _forceAllPropTweens = 1;
          tween.vars[property] = "+=0";
          _initTween(tween, time);
          _forceAllPropTweens = 0;
          return skipRecursion ? _warn(property + " not eligible for reset") : 1;
        }
        ptCache.push(pt);
      }
    }
    i5 = ptCache.length;
    while (i5--) {
      rootPT = ptCache[i5];
      pt = rootPT._pt || rootPT;
      pt.s = (start || start === 0) && !startIsRelative ? start : pt.s + (start || 0) + ratio * pt.c;
      pt.c = value - pt.s;
      rootPT.e && (rootPT.e = _round(value) + getUnit(rootPT.e));
      rootPT.b && (rootPT.b = pt.s + getUnit(rootPT.b));
    }
  };
  var _addAliasesToVars = function _addAliasesToVars2(targets, vars) {
    var harness = targets[0] ? _getCache(targets[0]).harness : 0, propertyAliases = harness && harness.aliases, copy, p2, i5, aliases;
    if (!propertyAliases) {
      return vars;
    }
    copy = _merge({}, vars);
    for (p2 in propertyAliases) {
      if (p2 in copy) {
        aliases = propertyAliases[p2].split(",");
        i5 = aliases.length;
        while (i5--) {
          copy[aliases[i5]] = copy[p2];
        }
      }
    }
    return copy;
  };
  var _parseKeyframe = function _parseKeyframe2(prop2, obj, allProps, easeEach) {
    var ease = obj.ease || easeEach || "power1.inOut", p2, a4;
    if (_isArray(obj)) {
      a4 = allProps[prop2] || (allProps[prop2] = []);
      obj.forEach(function(value, i5) {
        return a4.push({
          t: i5 / (obj.length - 1) * 100,
          v: value,
          e: ease
        });
      });
    } else {
      for (p2 in obj) {
        a4 = allProps[p2] || (allProps[p2] = []);
        p2 === "ease" || a4.push({
          t: parseFloat(prop2),
          v: obj[p2],
          e: ease
        });
      }
    }
  };
  var _parseFuncOrString = function _parseFuncOrString2(value, tween, i5, target, targets) {
    return _isFunction(value) ? value.call(tween, i5, target, targets) : _isString(value) && ~value.indexOf("random(") ? _replaceRandom(value) : value;
  };
  var _staggerTweenProps = _callbackNames + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert";
  var _staggerPropsToSkip = {};
  _forEachName(_staggerTweenProps + ",id,stagger,delay,duration,paused,scrollTrigger", function(name) {
    return _staggerPropsToSkip[name] = 1;
  });
  var Tween = /* @__PURE__ */ function(_Animation2) {
    _inheritsLoose(Tween2, _Animation2);
    function Tween2(targets, vars, position, skipInherit) {
      var _this3;
      if (typeof vars === "number") {
        position.duration = vars;
        vars = position;
        position = null;
      }
      _this3 = _Animation2.call(this, skipInherit ? vars : _inheritDefaults(vars)) || this;
      var _this3$vars = _this3.vars, duration = _this3$vars.duration, delay = _this3$vars.delay, immediateRender = _this3$vars.immediateRender, stagger = _this3$vars.stagger, overwrite = _this3$vars.overwrite, keyframes = _this3$vars.keyframes, defaults4 = _this3$vars.defaults, scrollTrigger = _this3$vars.scrollTrigger, yoyoEase = _this3$vars.yoyoEase, parent = vars.parent || _globalTimeline, parsedTargets = (_isArray(targets) || _isTypedArray(targets) ? _isNumber(targets[0]) : "length" in vars) ? [targets] : toArray(targets), tl, i5, copy, l6, p2, curTarget, staggerFunc, staggerVarsToMerge;
      _this3._targets = parsedTargets.length ? _harness(parsedTargets) : _warn("GSAP target " + targets + " not found. https://gsap.com", !_config.nullTargetWarn) || [];
      _this3._ptLookup = [];
      _this3._overwrite = overwrite;
      if (keyframes || stagger || _isFuncOrString(duration) || _isFuncOrString(delay)) {
        vars = _this3.vars;
        tl = _this3.timeline = new Timeline({
          data: "nested",
          defaults: defaults4 || {},
          targets: parent && parent.data === "nested" ? parent.vars.targets : parsedTargets
        });
        tl.kill();
        tl.parent = tl._dp = _assertThisInitialized(_this3);
        tl._start = 0;
        if (stagger || _isFuncOrString(duration) || _isFuncOrString(delay)) {
          l6 = parsedTargets.length;
          staggerFunc = stagger && distribute(stagger);
          if (_isObject(stagger)) {
            for (p2 in stagger) {
              if (~_staggerTweenProps.indexOf(p2)) {
                staggerVarsToMerge || (staggerVarsToMerge = {});
                staggerVarsToMerge[p2] = stagger[p2];
              }
            }
          }
          for (i5 = 0; i5 < l6; i5++) {
            copy = _copyExcluding(vars, _staggerPropsToSkip);
            copy.stagger = 0;
            yoyoEase && (copy.yoyoEase = yoyoEase);
            staggerVarsToMerge && _merge(copy, staggerVarsToMerge);
            curTarget = parsedTargets[i5];
            copy.duration = +_parseFuncOrString(duration, _assertThisInitialized(_this3), i5, curTarget, parsedTargets);
            copy.delay = (+_parseFuncOrString(delay, _assertThisInitialized(_this3), i5, curTarget, parsedTargets) || 0) - _this3._delay;
            if (!stagger && l6 === 1 && copy.delay) {
              _this3._delay = delay = copy.delay;
              _this3._start += delay;
              copy.delay = 0;
            }
            tl.to(curTarget, copy, staggerFunc ? staggerFunc(i5, curTarget, parsedTargets) : 0);
            tl._ease = _easeMap.none;
          }
          tl.duration() ? duration = delay = 0 : _this3.timeline = 0;
        } else if (keyframes) {
          _inheritDefaults(_setDefaults(tl.vars.defaults, {
            ease: "none"
          }));
          tl._ease = _parseEase(keyframes.ease || vars.ease || "none");
          var time = 0, a4, kf, v2;
          if (_isArray(keyframes)) {
            keyframes.forEach(function(frame) {
              return tl.to(parsedTargets, frame, ">");
            });
            tl.duration();
          } else {
            copy = {};
            for (p2 in keyframes) {
              p2 === "ease" || p2 === "easeEach" || _parseKeyframe(p2, keyframes[p2], copy, keyframes.easeEach);
            }
            for (p2 in copy) {
              a4 = copy[p2].sort(function(a5, b2) {
                return a5.t - b2.t;
              });
              time = 0;
              for (i5 = 0; i5 < a4.length; i5++) {
                kf = a4[i5];
                v2 = {
                  ease: kf.e,
                  duration: (kf.t - (i5 ? a4[i5 - 1].t : 0)) / 100 * duration
                };
                v2[p2] = kf.v;
                tl.to(parsedTargets, v2, time);
                time += v2.duration;
              }
            }
            tl.duration() < duration && tl.to({}, {
              duration: duration - tl.duration()
            });
          }
        }
        duration || _this3.duration(duration = tl.duration());
      } else {
        _this3.timeline = 0;
      }
      if (overwrite === true && !_suppressOverwrites) {
        _overwritingTween = _assertThisInitialized(_this3);
        _globalTimeline.killTweensOf(parsedTargets);
        _overwritingTween = 0;
      }
      _addToTimeline(parent, _assertThisInitialized(_this3), position);
      vars.reversed && _this3.reverse();
      vars.paused && _this3.paused(true);
      if (immediateRender || !duration && !keyframes && _this3._start === _roundPrecise(parent._time) && _isNotFalse(immediateRender) && _hasNoPausedAncestors(_assertThisInitialized(_this3)) && parent.data !== "nested") {
        _this3._tTime = -_tinyNum;
        _this3.render(Math.max(0, -delay) || 0);
      }
      scrollTrigger && _scrollTrigger(_assertThisInitialized(_this3), scrollTrigger);
      return _this3;
    }
    var _proto3 = Tween2.prototype;
    _proto3.render = function render4(totalTime, suppressEvents, force) {
      var prevTime = this._time, tDur = this._tDur, dur = this._dur, isNegative = totalTime < 0, tTime = totalTime > tDur - _tinyNum && !isNegative ? tDur : totalTime < _tinyNum ? 0 : totalTime, time, pt, iteration, cycleDuration, prevIteration, isYoyo, ratio, timeline2, yoyoEase;
      if (!dur) {
        _renderZeroDurationTween(this, totalTime, suppressEvents, force);
      } else if (tTime !== this._tTime || !totalTime || force || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== isNegative) {
        time = tTime;
        timeline2 = this.timeline;
        if (this._repeat) {
          cycleDuration = dur + this._rDelay;
          if (this._repeat < -1 && isNegative) {
            return this.totalTime(cycleDuration * 100 + totalTime, suppressEvents, force);
          }
          time = _roundPrecise(tTime % cycleDuration);
          if (tTime === tDur) {
            iteration = this._repeat;
            time = dur;
          } else {
            iteration = ~~(tTime / cycleDuration);
            if (iteration && iteration === _roundPrecise(tTime / cycleDuration)) {
              time = dur;
              iteration--;
            }
            time > dur && (time = dur);
          }
          isYoyo = this._yoyo && iteration & 1;
          if (isYoyo) {
            yoyoEase = this._yEase;
            time = dur - time;
          }
          prevIteration = _animationCycle(this._tTime, cycleDuration);
          if (time === prevTime && !force && this._initted && iteration === prevIteration) {
            this._tTime = tTime;
            return this;
          }
          if (iteration !== prevIteration) {
            timeline2 && this._yEase && _propagateYoyoEase(timeline2, isYoyo);
            if (this.vars.repeatRefresh && !isYoyo && !this._lock && this._time !== cycleDuration && this._initted) {
              this._lock = force = 1;
              this.render(_roundPrecise(cycleDuration * iteration), true).invalidate()._lock = 0;
            }
          }
        }
        if (!this._initted) {
          if (_attemptInitTween(this, isNegative ? totalTime : time, force, suppressEvents, tTime)) {
            this._tTime = 0;
            return this;
          }
          if (prevTime !== this._time && !(force && this.vars.repeatRefresh && iteration !== prevIteration)) {
            return this;
          }
          if (dur !== this._dur) {
            return this.render(totalTime, suppressEvents, force);
          }
        }
        this._tTime = tTime;
        this._time = time;
        if (!this._act && this._ts) {
          this._act = 1;
          this._lazy = 0;
        }
        this.ratio = ratio = (yoyoEase || this._ease)(time / dur);
        if (this._from) {
          this.ratio = ratio = 1 - ratio;
        }
        if (time && !prevTime && !suppressEvents && !iteration) {
          _callback(this, "onStart");
          if (this._tTime !== tTime) {
            return this;
          }
        }
        pt = this._pt;
        while (pt) {
          pt.r(ratio, pt.d);
          pt = pt._next;
        }
        timeline2 && timeline2.render(totalTime < 0 ? totalTime : timeline2._dur * timeline2._ease(time / this._dur), suppressEvents, force) || this._startAt && (this._zTime = totalTime);
        if (this._onUpdate && !suppressEvents) {
          isNegative && _rewindStartAt(this, totalTime, suppressEvents, force);
          _callback(this, "onUpdate");
        }
        this._repeat && iteration !== prevIteration && this.vars.onRepeat && !suppressEvents && this.parent && _callback(this, "onRepeat");
        if ((tTime === this._tDur || !tTime) && this._tTime === tTime) {
          isNegative && !this._onUpdate && _rewindStartAt(this, totalTime, true, true);
          (totalTime || !dur) && (tTime === this._tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1);
          if (!suppressEvents && !(isNegative && !prevTime) && (tTime || prevTime || isYoyo)) {
            _callback(this, tTime === tDur ? "onComplete" : "onReverseComplete", true);
            this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();
          }
        }
      }
      return this;
    };
    _proto3.targets = function targets() {
      return this._targets;
    };
    _proto3.invalidate = function invalidate(soft) {
      (!soft || !this.vars.runBackwards) && (this._startAt = 0);
      this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0;
      this._ptLookup = [];
      this.timeline && this.timeline.invalidate(soft);
      return _Animation2.prototype.invalidate.call(this, soft);
    };
    _proto3.resetTo = function resetTo(property, value, start, startIsRelative, skipRecursion) {
      _tickerActive || _ticker.wake();
      this._ts || this.play();
      var time = Math.min(this._dur, (this._dp._time - this._start) * this._ts), ratio;
      this._initted || _initTween(this, time);
      ratio = this._ease(time / this._dur);
      if (_updatePropTweens(this, property, value, start, startIsRelative, ratio, time, skipRecursion)) {
        return this.resetTo(property, value, start, startIsRelative, 1);
      }
      _alignPlayhead(this, 0);
      this.parent || _addLinkedListItem(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0);
      return this.render(0);
    };
    _proto3.kill = function kill2(targets, vars) {
      if (vars === void 0) {
        vars = "all";
      }
      if (!targets && (!vars || vars === "all")) {
        this._lazy = this._pt = 0;
        return this.parent ? _interrupt(this) : this;
      }
      if (this.timeline) {
        var tDur = this.timeline.totalDuration();
        this.timeline.killTweensOf(targets, vars, _overwritingTween && _overwritingTween.vars.overwrite !== true)._first || _interrupt(this);
        this.parent && tDur !== this.timeline.totalDuration() && _setDuration(this, this._dur * this.timeline._tDur / tDur, 0, 1);
        return this;
      }
      var parsedTargets = this._targets, killingTargets = targets ? toArray(targets) : parsedTargets, propTweenLookup = this._ptLookup, firstPT = this._pt, overwrittenProps, curLookup, curOverwriteProps, props, p2, pt, i5;
      if ((!vars || vars === "all") && _arraysMatch(parsedTargets, killingTargets)) {
        vars === "all" && (this._pt = 0);
        return _interrupt(this);
      }
      overwrittenProps = this._op = this._op || [];
      if (vars !== "all") {
        if (_isString(vars)) {
          p2 = {};
          _forEachName(vars, function(name) {
            return p2[name] = 1;
          });
          vars = p2;
        }
        vars = _addAliasesToVars(parsedTargets, vars);
      }
      i5 = parsedTargets.length;
      while (i5--) {
        if (~killingTargets.indexOf(parsedTargets[i5])) {
          curLookup = propTweenLookup[i5];
          if (vars === "all") {
            overwrittenProps[i5] = vars;
            props = curLookup;
            curOverwriteProps = {};
          } else {
            curOverwriteProps = overwrittenProps[i5] = overwrittenProps[i5] || {};
            props = vars;
          }
          for (p2 in props) {
            pt = curLookup && curLookup[p2];
            if (pt) {
              if (!("kill" in pt.d) || pt.d.kill(p2) === true) {
                _removeLinkedListItem(this, pt, "_pt");
              }
              delete curLookup[p2];
            }
            if (curOverwriteProps !== "all") {
              curOverwriteProps[p2] = 1;
            }
          }
        }
      }
      this._initted && !this._pt && firstPT && _interrupt(this);
      return this;
    };
    Tween2.to = function to(targets, vars) {
      return new Tween2(targets, vars, arguments[2]);
    };
    Tween2.from = function from(targets, vars) {
      return _createTweenType(1, arguments);
    };
    Tween2.delayedCall = function delayedCall(delay, callback, params, scope) {
      return new Tween2(callback, 0, {
        immediateRender: false,
        lazy: false,
        overwrite: false,
        delay,
        onComplete: callback,
        onReverseComplete: callback,
        onCompleteParams: params,
        onReverseCompleteParams: params,
        callbackScope: scope
      });
    };
    Tween2.fromTo = function fromTo(targets, fromVars, toVars) {
      return _createTweenType(2, arguments);
    };
    Tween2.set = function set(targets, vars) {
      vars.duration = 0;
      vars.repeatDelay || (vars.repeat = 0);
      return new Tween2(targets, vars);
    };
    Tween2.killTweensOf = function killTweensOf(targets, props, onlyActive) {
      return _globalTimeline.killTweensOf(targets, props, onlyActive);
    };
    return Tween2;
  }(Animation);
  _setDefaults(Tween.prototype, {
    _targets: [],
    _lazy: 0,
    _startAt: 0,
    _op: 0,
    _onInit: 0
  });
  _forEachName("staggerTo,staggerFrom,staggerFromTo", function(name) {
    Tween[name] = function() {
      var tl = new Timeline(), params = _slice.call(arguments, 0);
      params.splice(name === "staggerFromTo" ? 5 : 4, 0, 0);
      return tl[name].apply(tl, params);
    };
  });
  var _setterPlain = function _setterPlain2(target, property, value) {
    return target[property] = value;
  };
  var _setterFunc = function _setterFunc2(target, property, value) {
    return target[property](value);
  };
  var _setterFuncWithParam = function _setterFuncWithParam2(target, property, value, data) {
    return target[property](data.fp, value);
  };
  var _setterAttribute = function _setterAttribute2(target, property, value) {
    return target.setAttribute(property, value);
  };
  var _getSetter = function _getSetter2(target, property) {
    return _isFunction(target[property]) ? _setterFunc : _isUndefined(target[property]) && target.setAttribute ? _setterAttribute : _setterPlain;
  };
  var _renderPlain = function _renderPlain2(ratio, data) {
    return data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 1e6) / 1e6, data);
  };
  var _renderBoolean = function _renderBoolean2(ratio, data) {
    return data.set(data.t, data.p, !!(data.s + data.c * ratio), data);
  };
  var _renderComplexString = function _renderComplexString2(ratio, data) {
    var pt = data._pt, s5 = "";
    if (!ratio && data.b) {
      s5 = data.b;
    } else if (ratio === 1 && data.e) {
      s5 = data.e;
    } else {
      while (pt) {
        s5 = pt.p + (pt.m ? pt.m(pt.s + pt.c * ratio) : Math.round((pt.s + pt.c * ratio) * 1e4) / 1e4) + s5;
        pt = pt._next;
      }
      s5 += data.c;
    }
    data.set(data.t, data.p, s5, data);
  };
  var _renderPropTweens = function _renderPropTweens2(ratio, data) {
    var pt = data._pt;
    while (pt) {
      pt.r(ratio, pt.d);
      pt = pt._next;
    }
  };
  var _addPluginModifier = function _addPluginModifier2(modifier, tween, target, property) {
    var pt = this._pt, next;
    while (pt) {
      next = pt._next;
      pt.p === property && pt.modifier(modifier, tween, target);
      pt = next;
    }
  };
  var _killPropTweensOf = function _killPropTweensOf2(property) {
    var pt = this._pt, hasNonDependentRemaining, next;
    while (pt) {
      next = pt._next;
      if (pt.p === property && !pt.op || pt.op === property) {
        _removeLinkedListItem(this, pt, "_pt");
      } else if (!pt.dep) {
        hasNonDependentRemaining = 1;
      }
      pt = next;
    }
    return !hasNonDependentRemaining;
  };
  var _setterWithModifier = function _setterWithModifier2(target, property, value, data) {
    data.mSet(target, property, data.m.call(data.tween, value, data.mt), data);
  };
  var _sortPropTweensByPriority = function _sortPropTweensByPriority2(parent) {
    var pt = parent._pt, next, pt2, first, last;
    while (pt) {
      next = pt._next;
      pt2 = first;
      while (pt2 && pt2.pr > pt.pr) {
        pt2 = pt2._next;
      }
      if (pt._prev = pt2 ? pt2._prev : last) {
        pt._prev._next = pt;
      } else {
        first = pt;
      }
      if (pt._next = pt2) {
        pt2._prev = pt;
      } else {
        last = pt;
      }
      pt = next;
    }
    parent._pt = first;
  };
  var PropTween = /* @__PURE__ */ function() {
    function PropTween2(next, target, prop2, start, change, renderer, data, setter, priority) {
      this.t = target;
      this.s = start;
      this.c = change;
      this.p = prop2;
      this.r = renderer || _renderPlain;
      this.d = data || this;
      this.set = setter || _setterPlain;
      this.pr = priority || 0;
      this._next = next;
      if (next) {
        next._prev = this;
      }
    }
    var _proto4 = PropTween2.prototype;
    _proto4.modifier = function modifier(func, tween, target) {
      this.mSet = this.mSet || this.set;
      this.set = _setterWithModifier;
      this.m = func;
      this.mt = target;
      this.tween = tween;
    };
    return PropTween2;
  }();
  _forEachName(_callbackNames + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", function(name) {
    return _reservedProps[name] = 1;
  });
  _globals.TweenMax = _globals.TweenLite = Tween;
  _globals.TimelineLite = _globals.TimelineMax = Timeline;
  _globalTimeline = new Timeline({
    sortChildren: false,
    defaults: _defaults,
    autoRemoveChildren: true,
    id: "root",
    smoothChildTiming: true
  });
  _config.stringFilter = _colorStringFilter;
  var _media = [];
  var _listeners = {};
  var _emptyArray = [];
  var _lastMediaTime = 0;
  var _contextID = 0;
  var _dispatch = function _dispatch2(type) {
    return (_listeners[type] || _emptyArray).map(function(f2) {
      return f2();
    });
  };
  var _onMediaChange = function _onMediaChange2() {
    var time = Date.now(), matches = [];
    if (time - _lastMediaTime > 2) {
      _dispatch("matchMediaInit");
      _media.forEach(function(c4) {
        var queries = c4.queries, conditions = c4.conditions, match, p2, anyMatch, toggled;
        for (p2 in queries) {
          match = _win.matchMedia(queries[p2]).matches;
          match && (anyMatch = 1);
          if (match !== conditions[p2]) {
            conditions[p2] = match;
            toggled = 1;
          }
        }
        if (toggled) {
          c4.revert();
          anyMatch && matches.push(c4);
        }
      });
      _dispatch("matchMediaRevert");
      matches.forEach(function(c4) {
        return c4.onMatch(c4, function(func) {
          return c4.add(null, func);
        });
      });
      _lastMediaTime = time;
      _dispatch("matchMedia");
    }
  };
  var Context = /* @__PURE__ */ function() {
    function Context2(func, scope) {
      this.selector = scope && selector(scope);
      this.data = [];
      this._r = [];
      this.isReverted = false;
      this.id = _contextID++;
      func && this.add(func);
    }
    var _proto5 = Context2.prototype;
    _proto5.add = function add(name, func, scope) {
      if (_isFunction(name)) {
        scope = func;
        func = name;
        name = _isFunction;
      }
      var self = this, f2 = function f3() {
        var prev = _context, prevSelector = self.selector, result;
        prev && prev !== self && prev.data.push(self);
        scope && (self.selector = selector(scope));
        _context = self;
        result = func.apply(self, arguments);
        _isFunction(result) && self._r.push(result);
        _context = prev;
        self.selector = prevSelector;
        self.isReverted = false;
        return result;
      };
      self.last = f2;
      return name === _isFunction ? f2(self, function(func2) {
        return self.add(null, func2);
      }) : name ? self[name] = f2 : f2;
    };
    _proto5.ignore = function ignore(func) {
      var prev = _context;
      _context = null;
      func(this);
      _context = prev;
    };
    _proto5.getTweens = function getTweens() {
      var a4 = [];
      this.data.forEach(function(e8) {
        return e8 instanceof Context2 ? a4.push.apply(a4, e8.getTweens()) : e8 instanceof Tween && !(e8.parent && e8.parent.data === "nested") && a4.push(e8);
      });
      return a4;
    };
    _proto5.clear = function clear() {
      this._r.length = this.data.length = 0;
    };
    _proto5.kill = function kill2(revert, matchMedia2) {
      var _this4 = this;
      if (revert) {
        (function() {
          var tweens = _this4.getTweens(), i6 = _this4.data.length, t6;
          while (i6--) {
            t6 = _this4.data[i6];
            if (t6.data === "isFlip") {
              t6.revert();
              t6.getChildren(true, true, false).forEach(function(tween) {
                return tweens.splice(tweens.indexOf(tween), 1);
              });
            }
          }
          tweens.map(function(t7) {
            return {
              g: t7._dur || t7._delay || t7._sat && !t7._sat.vars.immediateRender ? t7.globalTime(0) : -Infinity,
              t: t7
            };
          }).sort(function(a4, b2) {
            return b2.g - a4.g || -Infinity;
          }).forEach(function(o7) {
            return o7.t.revert(revert);
          });
          i6 = _this4.data.length;
          while (i6--) {
            t6 = _this4.data[i6];
            if (t6 instanceof Timeline) {
              if (t6.data !== "nested") {
                t6.scrollTrigger && t6.scrollTrigger.revert();
                t6.kill();
              }
            } else {
              !(t6 instanceof Tween) && t6.revert && t6.revert(revert);
            }
          }
          _this4._r.forEach(function(f2) {
            return f2(revert, _this4);
          });
          _this4.isReverted = true;
        })();
      } else {
        this.data.forEach(function(e8) {
          return e8.kill && e8.kill();
        });
      }
      this.clear();
      if (matchMedia2) {
        var i5 = _media.length;
        while (i5--) {
          _media[i5].id === this.id && _media.splice(i5, 1);
        }
      }
    };
    _proto5.revert = function revert(config3) {
      this.kill(config3 || {});
    };
    return Context2;
  }();
  var MatchMedia = /* @__PURE__ */ function() {
    function MatchMedia2(scope) {
      this.contexts = [];
      this.scope = scope;
      _context && _context.data.push(this);
    }
    var _proto6 = MatchMedia2.prototype;
    _proto6.add = function add(conditions, func, scope) {
      _isObject(conditions) || (conditions = {
        matches: conditions
      });
      var context3 = new Context(0, scope || this.scope), cond = context3.conditions = {}, mq, p2, active;
      _context && !context3.selector && (context3.selector = _context.selector);
      this.contexts.push(context3);
      func = context3.add("onMatch", func);
      context3.queries = conditions;
      for (p2 in conditions) {
        if (p2 === "all") {
          active = 1;
        } else {
          mq = _win.matchMedia(conditions[p2]);
          if (mq) {
            _media.indexOf(context3) < 0 && _media.push(context3);
            (cond[p2] = mq.matches) && (active = 1);
            mq.addListener ? mq.addListener(_onMediaChange) : mq.addEventListener("change", _onMediaChange);
          }
        }
      }
      active && func(context3, function(f2) {
        return context3.add(null, f2);
      });
      return this;
    };
    _proto6.revert = function revert(config3) {
      this.kill(config3 || {});
    };
    _proto6.kill = function kill2(revert) {
      this.contexts.forEach(function(c4) {
        return c4.kill(revert, true);
      });
    };
    return MatchMedia2;
  }();
  var _gsap = {
    registerPlugin: function registerPlugin() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      args.forEach(function(config3) {
        return _createPlugin(config3);
      });
    },
    timeline: function timeline(vars) {
      return new Timeline(vars);
    },
    getTweensOf: function getTweensOf(targets, onlyActive) {
      return _globalTimeline.getTweensOf(targets, onlyActive);
    },
    getProperty: function getProperty(target, property, unit, uncache) {
      _isString(target) && (target = toArray(target)[0]);
      var getter = _getCache(target || {}).get, format = unit ? _passThrough : _numericIfPossible;
      unit === "native" && (unit = "");
      return !target ? target : !property ? function(property2, unit2, uncache2) {
        return format((_plugins[property2] && _plugins[property2].get || getter)(target, property2, unit2, uncache2));
      } : format((_plugins[property] && _plugins[property].get || getter)(target, property, unit, uncache));
    },
    quickSetter: function quickSetter(target, property, unit) {
      target = toArray(target);
      if (target.length > 1) {
        var setters = target.map(function(t6) {
          return gsap.quickSetter(t6, property, unit);
        }), l6 = setters.length;
        return function(value) {
          var i5 = l6;
          while (i5--) {
            setters[i5](value);
          }
        };
      }
      target = target[0] || {};
      var Plugin = _plugins[property], cache2 = _getCache(target), p2 = cache2.harness && (cache2.harness.aliases || {})[property] || property, setter = Plugin ? function(value) {
        var p3 = new Plugin();
        _quickTween._pt = 0;
        p3.init(target, unit ? value + unit : value, _quickTween, 0, [target]);
        p3.render(1, p3);
        _quickTween._pt && _renderPropTweens(1, _quickTween);
      } : cache2.set(target, p2);
      return Plugin ? setter : function(value) {
        return setter(target, p2, unit ? value + unit : value, cache2, 1);
      };
    },
    quickTo: function quickTo(target, property, vars) {
      var _merge22;
      var tween = gsap.to(target, _merge((_merge22 = {}, _merge22[property] = "+=0.1", _merge22.paused = true, _merge22), vars || {})), func = function func2(value, start, startIsRelative) {
        return tween.resetTo(property, value, start, startIsRelative);
      };
      func.tween = tween;
      return func;
    },
    isTweening: function isTweening(targets) {
      return _globalTimeline.getTweensOf(targets, true).length > 0;
    },
    defaults: function defaults(value) {
      value && value.ease && (value.ease = _parseEase(value.ease, _defaults.ease));
      return _mergeDeep(_defaults, value || {});
    },
    config: function config2(value) {
      return _mergeDeep(_config, value || {});
    },
    registerEffect: function registerEffect(_ref3) {
      var name = _ref3.name, effect2 = _ref3.effect, plugins = _ref3.plugins, defaults4 = _ref3.defaults, extendTimeline = _ref3.extendTimeline;
      (plugins || "").split(",").forEach(function(pluginName) {
        return pluginName && !_plugins[pluginName] && !_globals[pluginName] && _warn(name + " effect requires " + pluginName + " plugin.");
      });
      _effects[name] = function(targets, vars, tl) {
        return effect2(toArray(targets), _setDefaults(vars || {}, defaults4), tl);
      };
      if (extendTimeline) {
        Timeline.prototype[name] = function(targets, vars, position) {
          return this.add(_effects[name](targets, _isObject(vars) ? vars : (position = vars) && {}, this), position);
        };
      }
    },
    registerEase: function registerEase(name, ease) {
      _easeMap[name] = _parseEase(ease);
    },
    parseEase: function parseEase(ease, defaultEase) {
      return arguments.length ? _parseEase(ease, defaultEase) : _easeMap;
    },
    getById: function getById(id) {
      return _globalTimeline.getById(id);
    },
    exportRoot: function exportRoot(vars, includeDelayedCalls) {
      if (vars === void 0) {
        vars = {};
      }
      var tl = new Timeline(vars), child, next;
      tl.smoothChildTiming = _isNotFalse(vars.smoothChildTiming);
      _globalTimeline.remove(tl);
      tl._dp = 0;
      tl._time = tl._tTime = _globalTimeline._time;
      child = _globalTimeline._first;
      while (child) {
        next = child._next;
        if (includeDelayedCalls || !(!child._dur && child instanceof Tween && child.vars.onComplete === child._targets[0])) {
          _addToTimeline(tl, child, child._start - child._delay);
        }
        child = next;
      }
      _addToTimeline(_globalTimeline, tl, 0);
      return tl;
    },
    context: function context(func, scope) {
      return func ? new Context(func, scope) : _context;
    },
    matchMedia: function matchMedia(scope) {
      return new MatchMedia(scope);
    },
    matchMediaRefresh: function matchMediaRefresh() {
      return _media.forEach(function(c4) {
        var cond = c4.conditions, found, p2;
        for (p2 in cond) {
          if (cond[p2]) {
            cond[p2] = false;
            found = 1;
          }
        }
        found && c4.revert();
      }) || _onMediaChange();
    },
    addEventListener: function addEventListener(type, callback) {
      var a4 = _listeners[type] || (_listeners[type] = []);
      ~a4.indexOf(callback) || a4.push(callback);
    },
    removeEventListener: function removeEventListener(type, callback) {
      var a4 = _listeners[type], i5 = a4 && a4.indexOf(callback);
      i5 >= 0 && a4.splice(i5, 1);
    },
    utils: {
      wrap,
      wrapYoyo,
      distribute,
      random,
      snap,
      normalize,
      getUnit,
      clamp,
      splitColor,
      toArray,
      selector,
      mapRange,
      pipe,
      unitize,
      interpolate,
      shuffle
    },
    install: _install,
    effects: _effects,
    ticker: _ticker,
    updateRoot: Timeline.updateRoot,
    plugins: _plugins,
    globalTimeline: _globalTimeline,
    core: {
      PropTween,
      globals: _addGlobal,
      Tween,
      Timeline,
      Animation,
      getCache: _getCache,
      _removeLinkedListItem,
      reverting: function reverting() {
        return _reverting;
      },
      context: function context2(toAdd) {
        if (toAdd && _context) {
          _context.data.push(toAdd);
          toAdd._ctx = _context;
        }
        return _context;
      },
      suppressOverwrites: function suppressOverwrites(value) {
        return _suppressOverwrites = value;
      }
    }
  };
  _forEachName("to,from,fromTo,delayedCall,set,killTweensOf", function(name) {
    return _gsap[name] = Tween[name];
  });
  _ticker.add(Timeline.updateRoot);
  _quickTween = _gsap.to({}, {
    duration: 0
  });
  var _getPluginPropTween = function _getPluginPropTween2(plugin, prop2) {
    var pt = plugin._pt;
    while (pt && pt.p !== prop2 && pt.op !== prop2 && pt.fp !== prop2) {
      pt = pt._next;
    }
    return pt;
  };
  var _addModifiers = function _addModifiers2(tween, modifiers) {
    var targets = tween._targets, p2, i5, pt;
    for (p2 in modifiers) {
      i5 = targets.length;
      while (i5--) {
        pt = tween._ptLookup[i5][p2];
        if (pt && (pt = pt.d)) {
          if (pt._pt) {
            pt = _getPluginPropTween(pt, p2);
          }
          pt && pt.modifier && pt.modifier(modifiers[p2], tween, targets[i5], p2);
        }
      }
    }
  };
  var _buildModifierPlugin = function _buildModifierPlugin2(name, modifier) {
    return {
      name,
      rawVars: 1,
      //don't pre-process function-based values or "random()" strings.
      init: function init5(target, vars, tween) {
        tween._onInit = function(tween2) {
          var temp, p2;
          if (_isString(vars)) {
            temp = {};
            _forEachName(vars, function(name2) {
              return temp[name2] = 1;
            });
            vars = temp;
          }
          if (modifier) {
            temp = {};
            for (p2 in vars) {
              temp[p2] = modifier(vars[p2]);
            }
            vars = temp;
          }
          _addModifiers(tween2, vars);
        };
      }
    };
  };
  var gsap = _gsap.registerPlugin({
    name: "attr",
    init: function init(target, vars, tween, index, targets) {
      var p2, pt, v2;
      this.tween = tween;
      for (p2 in vars) {
        v2 = target.getAttribute(p2) || "";
        pt = this.add(target, "setAttribute", (v2 || 0) + "", vars[p2], index, targets, 0, 0, p2);
        pt.op = p2;
        pt.b = v2;
        this._props.push(p2);
      }
    },
    render: function render(ratio, data) {
      var pt = data._pt;
      while (pt) {
        _reverting ? pt.set(pt.t, pt.p, pt.b, pt) : pt.r(ratio, pt.d);
        pt = pt._next;
      }
    }
  }, {
    name: "endArray",
    init: function init2(target, value) {
      var i5 = value.length;
      while (i5--) {
        this.add(target, i5, target[i5] || 0, value[i5], 0, 0, 0, 0, 0, 1);
      }
    }
  }, _buildModifierPlugin("roundProps", _roundModifier), _buildModifierPlugin("modifiers"), _buildModifierPlugin("snap", snap)) || _gsap;
  Tween.version = Timeline.version = gsap.version = "3.12.5";
  _coreReady = 1;
  _windowExists() && _wake();
  var Power0 = _easeMap.Power0;
  var Power1 = _easeMap.Power1;
  var Power2 = _easeMap.Power2;
  var Power3 = _easeMap.Power3;
  var Power4 = _easeMap.Power4;
  var Linear = _easeMap.Linear;
  var Quad = _easeMap.Quad;
  var Cubic = _easeMap.Cubic;
  var Quart = _easeMap.Quart;
  var Quint = _easeMap.Quint;
  var Strong = _easeMap.Strong;
  var Elastic = _easeMap.Elastic;
  var Back = _easeMap.Back;
  var SteppedEase = _easeMap.SteppedEase;
  var Bounce = _easeMap.Bounce;
  var Sine = _easeMap.Sine;
  var Expo = _easeMap.Expo;
  var Circ = _easeMap.Circ;

  // node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/CSSPlugin.js
  init_live_reload();
  var _win2;
  var _doc2;
  var _docElement;
  var _pluginInitted;
  var _tempDiv;
  var _tempDivStyler;
  var _recentSetterPlugin;
  var _reverting2;
  var _windowExists3 = function _windowExists4() {
    return typeof window !== "undefined";
  };
  var _transformProps = {};
  var _RAD2DEG = 180 / Math.PI;
  var _DEG2RAD = Math.PI / 180;
  var _atan2 = Math.atan2;
  var _bigNum2 = 1e8;
  var _capsExp = /([A-Z])/g;
  var _horizontalExp = /(left|right|width|margin|padding|x)/i;
  var _complexExp = /[\s,\(]\S/;
  var _propertyAliases = {
    autoAlpha: "opacity,visibility",
    scale: "scaleX,scaleY",
    alpha: "opacity"
  };
  var _renderCSSProp = function _renderCSSProp2(ratio, data) {
    return data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 1e4) / 1e4 + data.u, data);
  };
  var _renderPropWithEnd = function _renderPropWithEnd2(ratio, data) {
    return data.set(data.t, data.p, ratio === 1 ? data.e : Math.round((data.s + data.c * ratio) * 1e4) / 1e4 + data.u, data);
  };
  var _renderCSSPropWithBeginning = function _renderCSSPropWithBeginning2(ratio, data) {
    return data.set(data.t, data.p, ratio ? Math.round((data.s + data.c * ratio) * 1e4) / 1e4 + data.u : data.b, data);
  };
  var _renderRoundedCSSProp = function _renderRoundedCSSProp2(ratio, data) {
    var value = data.s + data.c * ratio;
    data.set(data.t, data.p, ~~(value + (value < 0 ? -0.5 : 0.5)) + data.u, data);
  };
  var _renderNonTweeningValue = function _renderNonTweeningValue2(ratio, data) {
    return data.set(data.t, data.p, ratio ? data.e : data.b, data);
  };
  var _renderNonTweeningValueOnlyAtEnd = function _renderNonTweeningValueOnlyAtEnd2(ratio, data) {
    return data.set(data.t, data.p, ratio !== 1 ? data.b : data.e, data);
  };
  var _setterCSSStyle = function _setterCSSStyle2(target, property, value) {
    return target.style[property] = value;
  };
  var _setterCSSProp = function _setterCSSProp2(target, property, value) {
    return target.style.setProperty(property, value);
  };
  var _setterTransform = function _setterTransform2(target, property, value) {
    return target._gsap[property] = value;
  };
  var _setterScale = function _setterScale2(target, property, value) {
    return target._gsap.scaleX = target._gsap.scaleY = value;
  };
  var _setterScaleWithRender = function _setterScaleWithRender2(target, property, value, data, ratio) {
    var cache2 = target._gsap;
    cache2.scaleX = cache2.scaleY = value;
    cache2.renderTransform(ratio, cache2);
  };
  var _setterTransformWithRender = function _setterTransformWithRender2(target, property, value, data, ratio) {
    var cache2 = target._gsap;
    cache2[property] = value;
    cache2.renderTransform(ratio, cache2);
  };
  var _transformProp = "transform";
  var _transformOriginProp = _transformProp + "Origin";
  var _saveStyle = function _saveStyle2(property, isNotCSS) {
    var _this = this;
    var target = this.target, style = target.style, cache2 = target._gsap;
    if (property in _transformProps && style) {
      this.tfm = this.tfm || {};
      if (property !== "transform") {
        property = _propertyAliases[property] || property;
        ~property.indexOf(",") ? property.split(",").forEach(function(a4) {
          return _this.tfm[a4] = _get(target, a4);
        }) : this.tfm[property] = cache2.x ? cache2[property] : _get(target, property);
        property === _transformOriginProp && (this.tfm.zOrigin = cache2.zOrigin);
      } else {
        return _propertyAliases.transform.split(",").forEach(function(p2) {
          return _saveStyle2.call(_this, p2, isNotCSS);
        });
      }
      if (this.props.indexOf(_transformProp) >= 0) {
        return;
      }
      if (cache2.svg) {
        this.svgo = target.getAttribute("data-svg-origin");
        this.props.push(_transformOriginProp, isNotCSS, "");
      }
      property = _transformProp;
    }
    (style || isNotCSS) && this.props.push(property, isNotCSS, style[property]);
  };
  var _removeIndependentTransforms = function _removeIndependentTransforms2(style) {
    if (style.translate) {
      style.removeProperty("translate");
      style.removeProperty("scale");
      style.removeProperty("rotate");
    }
  };
  var _revertStyle = function _revertStyle2() {
    var props = this.props, target = this.target, style = target.style, cache2 = target._gsap, i5, p2;
    for (i5 = 0; i5 < props.length; i5 += 3) {
      props[i5 + 1] ? target[props[i5]] = props[i5 + 2] : props[i5 + 2] ? style[props[i5]] = props[i5 + 2] : style.removeProperty(props[i5].substr(0, 2) === "--" ? props[i5] : props[i5].replace(_capsExp, "-$1").toLowerCase());
    }
    if (this.tfm) {
      for (p2 in this.tfm) {
        cache2[p2] = this.tfm[p2];
      }
      if (cache2.svg) {
        cache2.renderTransform();
        target.setAttribute("data-svg-origin", this.svgo || "");
      }
      i5 = _reverting2();
      if ((!i5 || !i5.isStart) && !style[_transformProp]) {
        _removeIndependentTransforms(style);
        if (cache2.zOrigin && style[_transformOriginProp]) {
          style[_transformOriginProp] += " " + cache2.zOrigin + "px";
          cache2.zOrigin = 0;
          cache2.renderTransform();
        }
        cache2.uncache = 1;
      }
    }
  };
  var _getStyleSaver = function _getStyleSaver2(target, properties) {
    var saver = {
      target,
      props: [],
      revert: _revertStyle,
      save: _saveStyle
    };
    target._gsap || gsap.core.getCache(target);
    properties && properties.split(",").forEach(function(p2) {
      return saver.save(p2);
    });
    return saver;
  };
  var _supports3D;
  var _createElement = function _createElement2(type, ns) {
    var e8 = _doc2.createElementNS ? _doc2.createElementNS((ns || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), type) : _doc2.createElement(type);
    return e8 && e8.style ? e8 : _doc2.createElement(type);
  };
  var _getComputedProperty = function _getComputedProperty2(target, property, skipPrefixFallback) {
    var cs = getComputedStyle(target);
    return cs[property] || cs.getPropertyValue(property.replace(_capsExp, "-$1").toLowerCase()) || cs.getPropertyValue(property) || !skipPrefixFallback && _getComputedProperty2(target, _checkPropPrefix(property) || property, 1) || "";
  };
  var _prefixes = "O,Moz,ms,Ms,Webkit".split(",");
  var _checkPropPrefix = function _checkPropPrefix2(property, element, preferPrefix) {
    var e8 = element || _tempDiv, s5 = e8.style, i5 = 5;
    if (property in s5 && !preferPrefix) {
      return property;
    }
    property = property.charAt(0).toUpperCase() + property.substr(1);
    while (i5-- && !(_prefixes[i5] + property in s5)) {
    }
    return i5 < 0 ? null : (i5 === 3 ? "ms" : i5 >= 0 ? _prefixes[i5] : "") + property;
  };
  var _initCore = function _initCore2() {
    if (_windowExists3() && window.document) {
      _win2 = window;
      _doc2 = _win2.document;
      _docElement = _doc2.documentElement;
      _tempDiv = _createElement("div") || {
        style: {}
      };
      _tempDivStyler = _createElement("div");
      _transformProp = _checkPropPrefix(_transformProp);
      _transformOriginProp = _transformProp + "Origin";
      _tempDiv.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0";
      _supports3D = !!_checkPropPrefix("perspective");
      _reverting2 = gsap.core.reverting;
      _pluginInitted = 1;
    }
  };
  var _getBBoxHack = function _getBBoxHack2(swapIfPossible) {
    var svg = _createElement("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"), oldParent = this.parentNode, oldSibling = this.nextSibling, oldCSS = this.style.cssText, bbox;
    _docElement.appendChild(svg);
    svg.appendChild(this);
    this.style.display = "block";
    if (swapIfPossible) {
      try {
        bbox = this.getBBox();
        this._gsapBBox = this.getBBox;
        this.getBBox = _getBBoxHack2;
      } catch (e8) {
      }
    } else if (this._gsapBBox) {
      bbox = this._gsapBBox();
    }
    if (oldParent) {
      if (oldSibling) {
        oldParent.insertBefore(this, oldSibling);
      } else {
        oldParent.appendChild(this);
      }
    }
    _docElement.removeChild(svg);
    this.style.cssText = oldCSS;
    return bbox;
  };
  var _getAttributeFallbacks = function _getAttributeFallbacks2(target, attributesArray) {
    var i5 = attributesArray.length;
    while (i5--) {
      if (target.hasAttribute(attributesArray[i5])) {
        return target.getAttribute(attributesArray[i5]);
      }
    }
  };
  var _getBBox = function _getBBox2(target) {
    var bounds;
    try {
      bounds = target.getBBox();
    } catch (error) {
      bounds = _getBBoxHack.call(target, true);
    }
    bounds && (bounds.width || bounds.height) || target.getBBox === _getBBoxHack || (bounds = _getBBoxHack.call(target, true));
    return bounds && !bounds.width && !bounds.x && !bounds.y ? {
      x: +_getAttributeFallbacks(target, ["x", "cx", "x1"]) || 0,
      y: +_getAttributeFallbacks(target, ["y", "cy", "y1"]) || 0,
      width: 0,
      height: 0
    } : bounds;
  };
  var _isSVG = function _isSVG2(e8) {
    return !!(e8.getCTM && (!e8.parentNode || e8.ownerSVGElement) && _getBBox(e8));
  };
  var _removeProperty = function _removeProperty2(target, property) {
    if (property) {
      var style = target.style, first2Chars;
      if (property in _transformProps && property !== _transformOriginProp) {
        property = _transformProp;
      }
      if (style.removeProperty) {
        first2Chars = property.substr(0, 2);
        if (first2Chars === "ms" || property.substr(0, 6) === "webkit") {
          property = "-" + property;
        }
        style.removeProperty(first2Chars === "--" ? property : property.replace(_capsExp, "-$1").toLowerCase());
      } else {
        style.removeAttribute(property);
      }
    }
  };
  var _addNonTweeningPT = function _addNonTweeningPT2(plugin, target, property, beginning, end, onlySetAtEnd) {
    var pt = new PropTween(plugin._pt, target, property, 0, 1, onlySetAtEnd ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue);
    plugin._pt = pt;
    pt.b = beginning;
    pt.e = end;
    plugin._props.push(property);
    return pt;
  };
  var _nonConvertibleUnits = {
    deg: 1,
    rad: 1,
    turn: 1
  };
  var _nonStandardLayouts = {
    grid: 1,
    flex: 1
  };
  var _convertToUnit = function _convertToUnit2(target, property, value, unit) {
    var curValue = parseFloat(value) || 0, curUnit = (value + "").trim().substr((curValue + "").length) || "px", style = _tempDiv.style, horizontal = _horizontalExp.test(property), isRootSVG = target.tagName.toLowerCase() === "svg", measureProperty = (isRootSVG ? "client" : "offset") + (horizontal ? "Width" : "Height"), amount = 100, toPixels = unit === "px", toPercent = unit === "%", px, parent, cache2, isSVG;
    if (unit === curUnit || !curValue || _nonConvertibleUnits[unit] || _nonConvertibleUnits[curUnit]) {
      return curValue;
    }
    curUnit !== "px" && !toPixels && (curValue = _convertToUnit2(target, property, value, "px"));
    isSVG = target.getCTM && _isSVG(target);
    if ((toPercent || curUnit === "%") && (_transformProps[property] || ~property.indexOf("adius"))) {
      px = isSVG ? target.getBBox()[horizontal ? "width" : "height"] : target[measureProperty];
      return _round(toPercent ? curValue / px * amount : curValue / 100 * px);
    }
    style[horizontal ? "width" : "height"] = amount + (toPixels ? curUnit : unit);
    parent = ~property.indexOf("adius") || unit === "em" && target.appendChild && !isRootSVG ? target : target.parentNode;
    if (isSVG) {
      parent = (target.ownerSVGElement || {}).parentNode;
    }
    if (!parent || parent === _doc2 || !parent.appendChild) {
      parent = _doc2.body;
    }
    cache2 = parent._gsap;
    if (cache2 && toPercent && cache2.width && horizontal && cache2.time === _ticker.time && !cache2.uncache) {
      return _round(curValue / cache2.width * amount);
    } else {
      if (toPercent && (property === "height" || property === "width")) {
        var v2 = target.style[property];
        target.style[property] = amount + unit;
        px = target[measureProperty];
        v2 ? target.style[property] = v2 : _removeProperty(target, property);
      } else {
        (toPercent || curUnit === "%") && !_nonStandardLayouts[_getComputedProperty(parent, "display")] && (style.position = _getComputedProperty(target, "position"));
        parent === target && (style.position = "static");
        parent.appendChild(_tempDiv);
        px = _tempDiv[measureProperty];
        parent.removeChild(_tempDiv);
        style.position = "absolute";
      }
      if (horizontal && toPercent) {
        cache2 = _getCache(parent);
        cache2.time = _ticker.time;
        cache2.width = parent[measureProperty];
      }
    }
    return _round(toPixels ? px * curValue / amount : px && curValue ? amount / px * curValue : 0);
  };
  var _get = function _get2(target, property, unit, uncache) {
    var value;
    _pluginInitted || _initCore();
    if (property in _propertyAliases && property !== "transform") {
      property = _propertyAliases[property];
      if (~property.indexOf(",")) {
        property = property.split(",")[0];
      }
    }
    if (_transformProps[property] && property !== "transform") {
      value = _parseTransform(target, uncache);
      value = property !== "transformOrigin" ? value[property] : value.svg ? value.origin : _firstTwoOnly(_getComputedProperty(target, _transformOriginProp)) + " " + value.zOrigin + "px";
    } else {
      value = target.style[property];
      if (!value || value === "auto" || uncache || ~(value + "").indexOf("calc(")) {
        value = _specialProps[property] && _specialProps[property](target, property, unit) || _getComputedProperty(target, property) || _getProperty(target, property) || (property === "opacity" ? 1 : 0);
      }
    }
    return unit && !~(value + "").trim().indexOf(" ") ? _convertToUnit(target, property, value, unit) + unit : value;
  };
  var _tweenComplexCSSString = function _tweenComplexCSSString2(target, prop2, start, end) {
    if (!start || start === "none") {
      var p2 = _checkPropPrefix(prop2, target, 1), s5 = p2 && _getComputedProperty(target, p2, 1);
      if (s5 && s5 !== start) {
        prop2 = p2;
        start = s5;
      } else if (prop2 === "borderColor") {
        start = _getComputedProperty(target, "borderTopColor");
      }
    }
    var pt = new PropTween(this._pt, target.style, prop2, 0, 1, _renderComplexString), index = 0, matchIndex = 0, a4, result, startValues, startNum, color, startValue, endValue, endNum, chunk, endUnit, startUnit, endValues;
    pt.b = start;
    pt.e = end;
    start += "";
    end += "";
    if (end === "auto") {
      startValue = target.style[prop2];
      target.style[prop2] = end;
      end = _getComputedProperty(target, prop2) || end;
      startValue ? target.style[prop2] = startValue : _removeProperty(target, prop2);
    }
    a4 = [start, end];
    _colorStringFilter(a4);
    start = a4[0];
    end = a4[1];
    startValues = start.match(_numWithUnitExp) || [];
    endValues = end.match(_numWithUnitExp) || [];
    if (endValues.length) {
      while (result = _numWithUnitExp.exec(end)) {
        endValue = result[0];
        chunk = end.substring(index, result.index);
        if (color) {
          color = (color + 1) % 5;
        } else if (chunk.substr(-5) === "rgba(" || chunk.substr(-5) === "hsla(") {
          color = 1;
        }
        if (endValue !== (startValue = startValues[matchIndex++] || "")) {
          startNum = parseFloat(startValue) || 0;
          startUnit = startValue.substr((startNum + "").length);
          endValue.charAt(1) === "=" && (endValue = _parseRelative(startNum, endValue) + startUnit);
          endNum = parseFloat(endValue);
          endUnit = endValue.substr((endNum + "").length);
          index = _numWithUnitExp.lastIndex - endUnit.length;
          if (!endUnit) {
            endUnit = endUnit || _config.units[prop2] || startUnit;
            if (index === end.length) {
              end += endUnit;
              pt.e += endUnit;
            }
          }
          if (startUnit !== endUnit) {
            startNum = _convertToUnit(target, prop2, startValue, endUnit) || 0;
          }
          pt._pt = {
            _next: pt._pt,
            p: chunk || matchIndex === 1 ? chunk : ",",
            //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.
            s: startNum,
            c: endNum - startNum,
            m: color && color < 4 || prop2 === "zIndex" ? Math.round : 0
          };
        }
      }
      pt.c = index < end.length ? end.substring(index, end.length) : "";
    } else {
      pt.r = prop2 === "display" && end === "none" ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue;
    }
    _relExp.test(end) && (pt.e = 0);
    this._pt = pt;
    return pt;
  };
  var _keywordToPercent = {
    top: "0%",
    bottom: "100%",
    left: "0%",
    right: "100%",
    center: "50%"
  };
  var _convertKeywordsToPercentages = function _convertKeywordsToPercentages2(value) {
    var split = value.split(" "), x2 = split[0], y2 = split[1] || "50%";
    if (x2 === "top" || x2 === "bottom" || y2 === "left" || y2 === "right") {
      value = x2;
      x2 = y2;
      y2 = value;
    }
    split[0] = _keywordToPercent[x2] || x2;
    split[1] = _keywordToPercent[y2] || y2;
    return split.join(" ");
  };
  var _renderClearProps = function _renderClearProps2(ratio, data) {
    if (data.tween && data.tween._time === data.tween._dur) {
      var target = data.t, style = target.style, props = data.u, cache2 = target._gsap, prop2, clearTransforms, i5;
      if (props === "all" || props === true) {
        style.cssText = "";
        clearTransforms = 1;
      } else {
        props = props.split(",");
        i5 = props.length;
        while (--i5 > -1) {
          prop2 = props[i5];
          if (_transformProps[prop2]) {
            clearTransforms = 1;
            prop2 = prop2 === "transformOrigin" ? _transformOriginProp : _transformProp;
          }
          _removeProperty(target, prop2);
        }
      }
      if (clearTransforms) {
        _removeProperty(target, _transformProp);
        if (cache2) {
          cache2.svg && target.removeAttribute("transform");
          _parseTransform(target, 1);
          cache2.uncache = 1;
          _removeIndependentTransforms(style);
        }
      }
    }
  };
  var _specialProps = {
    clearProps: function clearProps(plugin, target, property, endValue, tween) {
      if (tween.data !== "isFromStart") {
        var pt = plugin._pt = new PropTween(plugin._pt, target, property, 0, 0, _renderClearProps);
        pt.u = endValue;
        pt.pr = -10;
        pt.tween = tween;
        plugin._props.push(property);
        return 1;
      }
    }
    /* className feature (about 0.4kb gzipped).
    , className(plugin, target, property, endValue, tween) {
    	let _renderClassName = (ratio, data) => {
    			data.css.render(ratio, data.css);
    			if (!ratio || ratio === 1) {
    				let inline = data.rmv,
    					target = data.t,
    					p;
    				target.setAttribute("class", ratio ? data.e : data.b);
    				for (p in inline) {
    					_removeProperty(target, p);
    				}
    			}
    		},
    		_getAllStyles = (target) => {
    			let styles = {},
    				computed = getComputedStyle(target),
    				p;
    			for (p in computed) {
    				if (isNaN(p) && p !== "cssText" && p !== "length") {
    					styles[p] = computed[p];
    				}
    			}
    			_setDefaults(styles, _parseTransform(target, 1));
    			return styles;
    		},
    		startClassList = target.getAttribute("class"),
    		style = target.style,
    		cssText = style.cssText,
    		cache = target._gsap,
    		classPT = cache.classPT,
    		inlineToRemoveAtEnd = {},
    		data = {t:target, plugin:plugin, rmv:inlineToRemoveAtEnd, b:startClassList, e:(endValue.charAt(1) !== "=") ? endValue : startClassList.replace(new RegExp("(?:\\s|^)" + endValue.substr(2) + "(?![\\w-])"), "") + ((endValue.charAt(0) === "+") ? " " + endValue.substr(2) : "")},
    		changingVars = {},
    		startVars = _getAllStyles(target),
    		transformRelated = /(transform|perspective)/i,
    		endVars, p;
    	if (classPT) {
    		classPT.r(1, classPT.d);
    		_removeLinkedListItem(classPT.d.plugin, classPT, "_pt");
    	}
    	target.setAttribute("class", data.e);
    	endVars = _getAllStyles(target, true);
    	target.setAttribute("class", startClassList);
    	for (p in endVars) {
    		if (endVars[p] !== startVars[p] && !transformRelated.test(p)) {
    			changingVars[p] = endVars[p];
    			if (!style[p] && style[p] !== "0") {
    				inlineToRemoveAtEnd[p] = 1;
    			}
    		}
    	}
    	cache.classPT = plugin._pt = new PropTween(plugin._pt, target, "className", 0, 0, _renderClassName, data, 0, -11);
    	if (style.cssText !== cssText) { //only apply if things change. Otherwise, in cases like a background-image that's pulled dynamically, it could cause a refresh. See https://gsap.com/forums/topic/20368-possible-gsap-bug-switching-classnames-in-chrome/.
    		style.cssText = cssText; //we recorded cssText before we swapped classes and ran _getAllStyles() because in cases when a className tween is overwritten, we remove all the related tweening properties from that class change (otherwise class-specific stuff can't override properties we've directly set on the target's style object due to specificity).
    	}
    	_parseTransform(target, true); //to clear the caching of transforms
    	data.css = new gsap.plugins.css();
    	data.css.init(target, changingVars, tween);
    	plugin._props.push(...data.css._props);
    	return 1;
    }
    */
  };
  var _identity2DMatrix = [1, 0, 0, 1, 0, 0];
  var _rotationalProperties = {};
  var _isNullTransform = function _isNullTransform2(value) {
    return value === "matrix(1, 0, 0, 1, 0, 0)" || value === "none" || !value;
  };
  var _getComputedTransformMatrixAsArray = function _getComputedTransformMatrixAsArray2(target) {
    var matrixString = _getComputedProperty(target, _transformProp);
    return _isNullTransform(matrixString) ? _identity2DMatrix : matrixString.substr(7).match(_numExp).map(_round);
  };
  var _getMatrix = function _getMatrix2(target, force2D) {
    var cache2 = target._gsap || _getCache(target), style = target.style, matrix = _getComputedTransformMatrixAsArray(target), parent, nextSibling, temp, addedToDOM;
    if (cache2.svg && target.getAttribute("transform")) {
      temp = target.transform.baseVal.consolidate().matrix;
      matrix = [temp.a, temp.b, temp.c, temp.d, temp.e, temp.f];
      return matrix.join(",") === "1,0,0,1,0,0" ? _identity2DMatrix : matrix;
    } else if (matrix === _identity2DMatrix && !target.offsetParent && target !== _docElement && !cache2.svg) {
      temp = style.display;
      style.display = "block";
      parent = target.parentNode;
      if (!parent || !target.offsetParent) {
        addedToDOM = 1;
        nextSibling = target.nextElementSibling;
        _docElement.appendChild(target);
      }
      matrix = _getComputedTransformMatrixAsArray(target);
      temp ? style.display = temp : _removeProperty(target, "display");
      if (addedToDOM) {
        nextSibling ? parent.insertBefore(target, nextSibling) : parent ? parent.appendChild(target) : _docElement.removeChild(target);
      }
    }
    return force2D && matrix.length > 6 ? [matrix[0], matrix[1], matrix[4], matrix[5], matrix[12], matrix[13]] : matrix;
  };
  var _applySVGOrigin = function _applySVGOrigin2(target, origin, originIsAbsolute, smooth, matrixArray, pluginToAddPropTweensTo) {
    var cache2 = target._gsap, matrix = matrixArray || _getMatrix(target, true), xOriginOld = cache2.xOrigin || 0, yOriginOld = cache2.yOrigin || 0, xOffsetOld = cache2.xOffset || 0, yOffsetOld = cache2.yOffset || 0, a4 = matrix[0], b2 = matrix[1], c4 = matrix[2], d2 = matrix[3], tx = matrix[4], ty = matrix[5], originSplit = origin.split(" "), xOrigin = parseFloat(originSplit[0]) || 0, yOrigin = parseFloat(originSplit[1]) || 0, bounds, determinant, x2, y2;
    if (!originIsAbsolute) {
      bounds = _getBBox(target);
      xOrigin = bounds.x + (~originSplit[0].indexOf("%") ? xOrigin / 100 * bounds.width : xOrigin);
      yOrigin = bounds.y + (~(originSplit[1] || originSplit[0]).indexOf("%") ? yOrigin / 100 * bounds.height : yOrigin);
    } else if (matrix !== _identity2DMatrix && (determinant = a4 * d2 - b2 * c4)) {
      x2 = xOrigin * (d2 / determinant) + yOrigin * (-c4 / determinant) + (c4 * ty - d2 * tx) / determinant;
      y2 = xOrigin * (-b2 / determinant) + yOrigin * (a4 / determinant) - (a4 * ty - b2 * tx) / determinant;
      xOrigin = x2;
      yOrigin = y2;
    }
    if (smooth || smooth !== false && cache2.smooth) {
      tx = xOrigin - xOriginOld;
      ty = yOrigin - yOriginOld;
      cache2.xOffset = xOffsetOld + (tx * a4 + ty * c4) - tx;
      cache2.yOffset = yOffsetOld + (tx * b2 + ty * d2) - ty;
    } else {
      cache2.xOffset = cache2.yOffset = 0;
    }
    cache2.xOrigin = xOrigin;
    cache2.yOrigin = yOrigin;
    cache2.smooth = !!smooth;
    cache2.origin = origin;
    cache2.originIsAbsolute = !!originIsAbsolute;
    target.style[_transformOriginProp] = "0px 0px";
    if (pluginToAddPropTweensTo) {
      _addNonTweeningPT(pluginToAddPropTweensTo, cache2, "xOrigin", xOriginOld, xOrigin);
      _addNonTweeningPT(pluginToAddPropTweensTo, cache2, "yOrigin", yOriginOld, yOrigin);
      _addNonTweeningPT(pluginToAddPropTweensTo, cache2, "xOffset", xOffsetOld, cache2.xOffset);
      _addNonTweeningPT(pluginToAddPropTweensTo, cache2, "yOffset", yOffsetOld, cache2.yOffset);
    }
    target.setAttribute("data-svg-origin", xOrigin + " " + yOrigin);
  };
  var _parseTransform = function _parseTransform2(target, uncache) {
    var cache2 = target._gsap || new GSCache(target);
    if ("x" in cache2 && !uncache && !cache2.uncache) {
      return cache2;
    }
    var style = target.style, invertedScaleX = cache2.scaleX < 0, px = "px", deg = "deg", cs = getComputedStyle(target), origin = _getComputedProperty(target, _transformOriginProp) || "0", x2, y2, z2, scaleX, scaleY, rotation, rotationX, rotationY, skewX, skewY, perspective, xOrigin, yOrigin, matrix, angle, cos, sin, a4, b2, c4, d2, a12, a22, t1, t22, t32, a13, a23, a33, a42, a43, a32;
    x2 = y2 = z2 = rotation = rotationX = rotationY = skewX = skewY = perspective = 0;
    scaleX = scaleY = 1;
    cache2.svg = !!(target.getCTM && _isSVG(target));
    if (cs.translate) {
      if (cs.translate !== "none" || cs.scale !== "none" || cs.rotate !== "none") {
        style[_transformProp] = (cs.translate !== "none" ? "translate3d(" + (cs.translate + " 0 0").split(" ").slice(0, 3).join(", ") + ") " : "") + (cs.rotate !== "none" ? "rotate(" + cs.rotate + ") " : "") + (cs.scale !== "none" ? "scale(" + cs.scale.split(" ").join(",") + ") " : "") + (cs[_transformProp] !== "none" ? cs[_transformProp] : "");
      }
      style.scale = style.rotate = style.translate = "none";
    }
    matrix = _getMatrix(target, cache2.svg);
    if (cache2.svg) {
      if (cache2.uncache) {
        t22 = target.getBBox();
        origin = cache2.xOrigin - t22.x + "px " + (cache2.yOrigin - t22.y) + "px";
        t1 = "";
      } else {
        t1 = !uncache && target.getAttribute("data-svg-origin");
      }
      _applySVGOrigin(target, t1 || origin, !!t1 || cache2.originIsAbsolute, cache2.smooth !== false, matrix);
    }
    xOrigin = cache2.xOrigin || 0;
    yOrigin = cache2.yOrigin || 0;
    if (matrix !== _identity2DMatrix) {
      a4 = matrix[0];
      b2 = matrix[1];
      c4 = matrix[2];
      d2 = matrix[3];
      x2 = a12 = matrix[4];
      y2 = a22 = matrix[5];
      if (matrix.length === 6) {
        scaleX = Math.sqrt(a4 * a4 + b2 * b2);
        scaleY = Math.sqrt(d2 * d2 + c4 * c4);
        rotation = a4 || b2 ? _atan2(b2, a4) * _RAD2DEG : 0;
        skewX = c4 || d2 ? _atan2(c4, d2) * _RAD2DEG + rotation : 0;
        skewX && (scaleY *= Math.abs(Math.cos(skewX * _DEG2RAD)));
        if (cache2.svg) {
          x2 -= xOrigin - (xOrigin * a4 + yOrigin * c4);
          y2 -= yOrigin - (xOrigin * b2 + yOrigin * d2);
        }
      } else {
        a32 = matrix[6];
        a42 = matrix[7];
        a13 = matrix[8];
        a23 = matrix[9];
        a33 = matrix[10];
        a43 = matrix[11];
        x2 = matrix[12];
        y2 = matrix[13];
        z2 = matrix[14];
        angle = _atan2(a32, a33);
        rotationX = angle * _RAD2DEG;
        if (angle) {
          cos = Math.cos(-angle);
          sin = Math.sin(-angle);
          t1 = a12 * cos + a13 * sin;
          t22 = a22 * cos + a23 * sin;
          t32 = a32 * cos + a33 * sin;
          a13 = a12 * -sin + a13 * cos;
          a23 = a22 * -sin + a23 * cos;
          a33 = a32 * -sin + a33 * cos;
          a43 = a42 * -sin + a43 * cos;
          a12 = t1;
          a22 = t22;
          a32 = t32;
        }
        angle = _atan2(-c4, a33);
        rotationY = angle * _RAD2DEG;
        if (angle) {
          cos = Math.cos(-angle);
          sin = Math.sin(-angle);
          t1 = a4 * cos - a13 * sin;
          t22 = b2 * cos - a23 * sin;
          t32 = c4 * cos - a33 * sin;
          a43 = d2 * sin + a43 * cos;
          a4 = t1;
          b2 = t22;
          c4 = t32;
        }
        angle = _atan2(b2, a4);
        rotation = angle * _RAD2DEG;
        if (angle) {
          cos = Math.cos(angle);
          sin = Math.sin(angle);
          t1 = a4 * cos + b2 * sin;
          t22 = a12 * cos + a22 * sin;
          b2 = b2 * cos - a4 * sin;
          a22 = a22 * cos - a12 * sin;
          a4 = t1;
          a12 = t22;
        }
        if (rotationX && Math.abs(rotationX) + Math.abs(rotation) > 359.9) {
          rotationX = rotation = 0;
          rotationY = 180 - rotationY;
        }
        scaleX = _round(Math.sqrt(a4 * a4 + b2 * b2 + c4 * c4));
        scaleY = _round(Math.sqrt(a22 * a22 + a32 * a32));
        angle = _atan2(a12, a22);
        skewX = Math.abs(angle) > 2e-4 ? angle * _RAD2DEG : 0;
        perspective = a43 ? 1 / (a43 < 0 ? -a43 : a43) : 0;
      }
      if (cache2.svg) {
        t1 = target.getAttribute("transform");
        cache2.forceCSS = target.setAttribute("transform", "") || !_isNullTransform(_getComputedProperty(target, _transformProp));
        t1 && target.setAttribute("transform", t1);
      }
    }
    if (Math.abs(skewX) > 90 && Math.abs(skewX) < 270) {
      if (invertedScaleX) {
        scaleX *= -1;
        skewX += rotation <= 0 ? 180 : -180;
        rotation += rotation <= 0 ? 180 : -180;
      } else {
        scaleY *= -1;
        skewX += skewX <= 0 ? 180 : -180;
      }
    }
    uncache = uncache || cache2.uncache;
    cache2.x = x2 - ((cache2.xPercent = x2 && (!uncache && cache2.xPercent || (Math.round(target.offsetWidth / 2) === Math.round(-x2) ? -50 : 0))) ? target.offsetWidth * cache2.xPercent / 100 : 0) + px;
    cache2.y = y2 - ((cache2.yPercent = y2 && (!uncache && cache2.yPercent || (Math.round(target.offsetHeight / 2) === Math.round(-y2) ? -50 : 0))) ? target.offsetHeight * cache2.yPercent / 100 : 0) + px;
    cache2.z = z2 + px;
    cache2.scaleX = _round(scaleX);
    cache2.scaleY = _round(scaleY);
    cache2.rotation = _round(rotation) + deg;
    cache2.rotationX = _round(rotationX) + deg;
    cache2.rotationY = _round(rotationY) + deg;
    cache2.skewX = skewX + deg;
    cache2.skewY = skewY + deg;
    cache2.transformPerspective = perspective + px;
    if (cache2.zOrigin = parseFloat(origin.split(" ")[2]) || !uncache && cache2.zOrigin || 0) {
      style[_transformOriginProp] = _firstTwoOnly(origin);
    }
    cache2.xOffset = cache2.yOffset = 0;
    cache2.force3D = _config.force3D;
    cache2.renderTransform = cache2.svg ? _renderSVGTransforms : _supports3D ? _renderCSSTransforms : _renderNon3DTransforms;
    cache2.uncache = 0;
    return cache2;
  };
  var _firstTwoOnly = function _firstTwoOnly2(value) {
    return (value = value.split(" "))[0] + " " + value[1];
  };
  var _addPxTranslate = function _addPxTranslate2(target, start, value) {
    var unit = getUnit(start);
    return _round(parseFloat(start) + parseFloat(_convertToUnit(target, "x", value + "px", unit))) + unit;
  };
  var _renderNon3DTransforms = function _renderNon3DTransforms2(ratio, cache2) {
    cache2.z = "0px";
    cache2.rotationY = cache2.rotationX = "0deg";
    cache2.force3D = 0;
    _renderCSSTransforms(ratio, cache2);
  };
  var _zeroDeg = "0deg";
  var _zeroPx = "0px";
  var _endParenthesis = ") ";
  var _renderCSSTransforms = function _renderCSSTransforms2(ratio, cache2) {
    var _ref = cache2 || this, xPercent = _ref.xPercent, yPercent = _ref.yPercent, x2 = _ref.x, y2 = _ref.y, z2 = _ref.z, rotation = _ref.rotation, rotationY = _ref.rotationY, rotationX = _ref.rotationX, skewX = _ref.skewX, skewY = _ref.skewY, scaleX = _ref.scaleX, scaleY = _ref.scaleY, transformPerspective = _ref.transformPerspective, force3D = _ref.force3D, target = _ref.target, zOrigin = _ref.zOrigin, transforms = "", use3D = force3D === "auto" && ratio && ratio !== 1 || force3D === true;
    if (zOrigin && (rotationX !== _zeroDeg || rotationY !== _zeroDeg)) {
      var angle = parseFloat(rotationY) * _DEG2RAD, a13 = Math.sin(angle), a33 = Math.cos(angle), cos;
      angle = parseFloat(rotationX) * _DEG2RAD;
      cos = Math.cos(angle);
      x2 = _addPxTranslate(target, x2, a13 * cos * -zOrigin);
      y2 = _addPxTranslate(target, y2, -Math.sin(angle) * -zOrigin);
      z2 = _addPxTranslate(target, z2, a33 * cos * -zOrigin + zOrigin);
    }
    if (transformPerspective !== _zeroPx) {
      transforms += "perspective(" + transformPerspective + _endParenthesis;
    }
    if (xPercent || yPercent) {
      transforms += "translate(" + xPercent + "%, " + yPercent + "%) ";
    }
    if (use3D || x2 !== _zeroPx || y2 !== _zeroPx || z2 !== _zeroPx) {
      transforms += z2 !== _zeroPx || use3D ? "translate3d(" + x2 + ", " + y2 + ", " + z2 + ") " : "translate(" + x2 + ", " + y2 + _endParenthesis;
    }
    if (rotation !== _zeroDeg) {
      transforms += "rotate(" + rotation + _endParenthesis;
    }
    if (rotationY !== _zeroDeg) {
      transforms += "rotateY(" + rotationY + _endParenthesis;
    }
    if (rotationX !== _zeroDeg) {
      transforms += "rotateX(" + rotationX + _endParenthesis;
    }
    if (skewX !== _zeroDeg || skewY !== _zeroDeg) {
      transforms += "skew(" + skewX + ", " + skewY + _endParenthesis;
    }
    if (scaleX !== 1 || scaleY !== 1) {
      transforms += "scale(" + scaleX + ", " + scaleY + _endParenthesis;
    }
    target.style[_transformProp] = transforms || "translate(0, 0)";
  };
  var _renderSVGTransforms = function _renderSVGTransforms2(ratio, cache2) {
    var _ref2 = cache2 || this, xPercent = _ref2.xPercent, yPercent = _ref2.yPercent, x2 = _ref2.x, y2 = _ref2.y, rotation = _ref2.rotation, skewX = _ref2.skewX, skewY = _ref2.skewY, scaleX = _ref2.scaleX, scaleY = _ref2.scaleY, target = _ref2.target, xOrigin = _ref2.xOrigin, yOrigin = _ref2.yOrigin, xOffset = _ref2.xOffset, yOffset = _ref2.yOffset, forceCSS = _ref2.forceCSS, tx = parseFloat(x2), ty = parseFloat(y2), a11, a21, a12, a22, temp;
    rotation = parseFloat(rotation);
    skewX = parseFloat(skewX);
    skewY = parseFloat(skewY);
    if (skewY) {
      skewY = parseFloat(skewY);
      skewX += skewY;
      rotation += skewY;
    }
    if (rotation || skewX) {
      rotation *= _DEG2RAD;
      skewX *= _DEG2RAD;
      a11 = Math.cos(rotation) * scaleX;
      a21 = Math.sin(rotation) * scaleX;
      a12 = Math.sin(rotation - skewX) * -scaleY;
      a22 = Math.cos(rotation - skewX) * scaleY;
      if (skewX) {
        skewY *= _DEG2RAD;
        temp = Math.tan(skewX - skewY);
        temp = Math.sqrt(1 + temp * temp);
        a12 *= temp;
        a22 *= temp;
        if (skewY) {
          temp = Math.tan(skewY);
          temp = Math.sqrt(1 + temp * temp);
          a11 *= temp;
          a21 *= temp;
        }
      }
      a11 = _round(a11);
      a21 = _round(a21);
      a12 = _round(a12);
      a22 = _round(a22);
    } else {
      a11 = scaleX;
      a22 = scaleY;
      a21 = a12 = 0;
    }
    if (tx && !~(x2 + "").indexOf("px") || ty && !~(y2 + "").indexOf("px")) {
      tx = _convertToUnit(target, "x", x2, "px");
      ty = _convertToUnit(target, "y", y2, "px");
    }
    if (xOrigin || yOrigin || xOffset || yOffset) {
      tx = _round(tx + xOrigin - (xOrigin * a11 + yOrigin * a12) + xOffset);
      ty = _round(ty + yOrigin - (xOrigin * a21 + yOrigin * a22) + yOffset);
    }
    if (xPercent || yPercent) {
      temp = target.getBBox();
      tx = _round(tx + xPercent / 100 * temp.width);
      ty = _round(ty + yPercent / 100 * temp.height);
    }
    temp = "matrix(" + a11 + "," + a21 + "," + a12 + "," + a22 + "," + tx + "," + ty + ")";
    target.setAttribute("transform", temp);
    forceCSS && (target.style[_transformProp] = temp);
  };
  var _addRotationalPropTween = function _addRotationalPropTween2(plugin, target, property, startNum, endValue) {
    var cap = 360, isString2 = _isString(endValue), endNum = parseFloat(endValue) * (isString2 && ~endValue.indexOf("rad") ? _RAD2DEG : 1), change = endNum - startNum, finalValue = startNum + change + "deg", direction, pt;
    if (isString2) {
      direction = endValue.split("_")[1];
      if (direction === "short") {
        change %= cap;
        if (change !== change % (cap / 2)) {
          change += change < 0 ? cap : -cap;
        }
      }
      if (direction === "cw" && change < 0) {
        change = (change + cap * _bigNum2) % cap - ~~(change / cap) * cap;
      } else if (direction === "ccw" && change > 0) {
        change = (change - cap * _bigNum2) % cap - ~~(change / cap) * cap;
      }
    }
    plugin._pt = pt = new PropTween(plugin._pt, target, property, startNum, change, _renderPropWithEnd);
    pt.e = finalValue;
    pt.u = "deg";
    plugin._props.push(property);
    return pt;
  };
  var _assign = function _assign2(target, source) {
    for (var p2 in source) {
      target[p2] = source[p2];
    }
    return target;
  };
  var _addRawTransformPTs = function _addRawTransformPTs2(plugin, transforms, target) {
    var startCache = _assign({}, target._gsap), exclude = "perspective,force3D,transformOrigin,svgOrigin", style = target.style, endCache, p2, startValue, endValue, startNum, endNum, startUnit, endUnit;
    if (startCache.svg) {
      startValue = target.getAttribute("transform");
      target.setAttribute("transform", "");
      style[_transformProp] = transforms;
      endCache = _parseTransform(target, 1);
      _removeProperty(target, _transformProp);
      target.setAttribute("transform", startValue);
    } else {
      startValue = getComputedStyle(target)[_transformProp];
      style[_transformProp] = transforms;
      endCache = _parseTransform(target, 1);
      style[_transformProp] = startValue;
    }
    for (p2 in _transformProps) {
      startValue = startCache[p2];
      endValue = endCache[p2];
      if (startValue !== endValue && exclude.indexOf(p2) < 0) {
        startUnit = getUnit(startValue);
        endUnit = getUnit(endValue);
        startNum = startUnit !== endUnit ? _convertToUnit(target, p2, startValue, endUnit) : parseFloat(startValue);
        endNum = parseFloat(endValue);
        plugin._pt = new PropTween(plugin._pt, endCache, p2, startNum, endNum - startNum, _renderCSSProp);
        plugin._pt.u = endUnit || 0;
        plugin._props.push(p2);
      }
    }
    _assign(endCache, startCache);
  };
  _forEachName("padding,margin,Width,Radius", function(name, index) {
    var t6 = "Top", r5 = "Right", b2 = "Bottom", l6 = "Left", props = (index < 3 ? [t6, r5, b2, l6] : [t6 + l6, t6 + r5, b2 + r5, b2 + l6]).map(function(side) {
      return index < 2 ? name + side : "border" + side + name;
    });
    _specialProps[index > 1 ? "border" + name : name] = function(plugin, target, property, endValue, tween) {
      var a4, vars;
      if (arguments.length < 4) {
        a4 = props.map(function(prop2) {
          return _get(plugin, prop2, property);
        });
        vars = a4.join(" ");
        return vars.split(a4[0]).length === 5 ? a4[0] : vars;
      }
      a4 = (endValue + "").split(" ");
      vars = {};
      props.forEach(function(prop2, i5) {
        return vars[prop2] = a4[i5] = a4[i5] || a4[(i5 - 1) / 2 | 0];
      });
      plugin.init(target, vars, tween);
    };
  });
  var CSSPlugin = {
    name: "css",
    register: _initCore,
    targetTest: function targetTest(target) {
      return target.style && target.nodeType;
    },
    init: function init3(target, vars, tween, index, targets) {
      var props = this._props, style = target.style, startAt = tween.vars.startAt, startValue, endValue, endNum, startNum, type, specialProp, p2, startUnit, endUnit, relative, isTransformRelated, transformPropTween, cache2, smooth, hasPriority, inlineProps;
      _pluginInitted || _initCore();
      this.styles = this.styles || _getStyleSaver(target);
      inlineProps = this.styles.props;
      this.tween = tween;
      for (p2 in vars) {
        if (p2 === "autoRound") {
          continue;
        }
        endValue = vars[p2];
        if (_plugins[p2] && _checkPlugin(p2, vars, tween, index, target, targets)) {
          continue;
        }
        type = typeof endValue;
        specialProp = _specialProps[p2];
        if (type === "function") {
          endValue = endValue.call(tween, index, target, targets);
          type = typeof endValue;
        }
        if (type === "string" && ~endValue.indexOf("random(")) {
          endValue = _replaceRandom(endValue);
        }
        if (specialProp) {
          specialProp(this, target, p2, endValue, tween) && (hasPriority = 1);
        } else if (p2.substr(0, 2) === "--") {
          startValue = (getComputedStyle(target).getPropertyValue(p2) + "").trim();
          endValue += "";
          _colorExp.lastIndex = 0;
          if (!_colorExp.test(startValue)) {
            startUnit = getUnit(startValue);
            endUnit = getUnit(endValue);
          }
          endUnit ? startUnit !== endUnit && (startValue = _convertToUnit(target, p2, startValue, endUnit) + endUnit) : startUnit && (endValue += startUnit);
          this.add(style, "setProperty", startValue, endValue, index, targets, 0, 0, p2);
          props.push(p2);
          inlineProps.push(p2, 0, style[p2]);
        } else if (type !== "undefined") {
          if (startAt && p2 in startAt) {
            startValue = typeof startAt[p2] === "function" ? startAt[p2].call(tween, index, target, targets) : startAt[p2];
            _isString(startValue) && ~startValue.indexOf("random(") && (startValue = _replaceRandom(startValue));
            getUnit(startValue + "") || startValue === "auto" || (startValue += _config.units[p2] || getUnit(_get(target, p2)) || "");
            (startValue + "").charAt(1) === "=" && (startValue = _get(target, p2));
          } else {
            startValue = _get(target, p2);
          }
          startNum = parseFloat(startValue);
          relative = type === "string" && endValue.charAt(1) === "=" && endValue.substr(0, 2);
          relative && (endValue = endValue.substr(2));
          endNum = parseFloat(endValue);
          if (p2 in _propertyAliases) {
            if (p2 === "autoAlpha") {
              if (startNum === 1 && _get(target, "visibility") === "hidden" && endNum) {
                startNum = 0;
              }
              inlineProps.push("visibility", 0, style.visibility);
              _addNonTweeningPT(this, style, "visibility", startNum ? "inherit" : "hidden", endNum ? "inherit" : "hidden", !endNum);
            }
            if (p2 !== "scale" && p2 !== "transform") {
              p2 = _propertyAliases[p2];
              ~p2.indexOf(",") && (p2 = p2.split(",")[0]);
            }
          }
          isTransformRelated = p2 in _transformProps;
          if (isTransformRelated) {
            this.styles.save(p2);
            if (!transformPropTween) {
              cache2 = target._gsap;
              cache2.renderTransform && !vars.parseTransform || _parseTransform(target, vars.parseTransform);
              smooth = vars.smoothOrigin !== false && cache2.smooth;
              transformPropTween = this._pt = new PropTween(this._pt, style, _transformProp, 0, 1, cache2.renderTransform, cache2, 0, -1);
              transformPropTween.dep = 1;
            }
            if (p2 === "scale") {
              this._pt = new PropTween(this._pt, cache2, "scaleY", cache2.scaleY, (relative ? _parseRelative(cache2.scaleY, relative + endNum) : endNum) - cache2.scaleY || 0, _renderCSSProp);
              this._pt.u = 0;
              props.push("scaleY", p2);
              p2 += "X";
            } else if (p2 === "transformOrigin") {
              inlineProps.push(_transformOriginProp, 0, style[_transformOriginProp]);
              endValue = _convertKeywordsToPercentages(endValue);
              if (cache2.svg) {
                _applySVGOrigin(target, endValue, 0, smooth, 0, this);
              } else {
                endUnit = parseFloat(endValue.split(" ")[2]) || 0;
                endUnit !== cache2.zOrigin && _addNonTweeningPT(this, cache2, "zOrigin", cache2.zOrigin, endUnit);
                _addNonTweeningPT(this, style, p2, _firstTwoOnly(startValue), _firstTwoOnly(endValue));
              }
              continue;
            } else if (p2 === "svgOrigin") {
              _applySVGOrigin(target, endValue, 1, smooth, 0, this);
              continue;
            } else if (p2 in _rotationalProperties) {
              _addRotationalPropTween(this, cache2, p2, startNum, relative ? _parseRelative(startNum, relative + endValue) : endValue);
              continue;
            } else if (p2 === "smoothOrigin") {
              _addNonTweeningPT(this, cache2, "smooth", cache2.smooth, endValue);
              continue;
            } else if (p2 === "force3D") {
              cache2[p2] = endValue;
              continue;
            } else if (p2 === "transform") {
              _addRawTransformPTs(this, endValue, target);
              continue;
            }
          } else if (!(p2 in style)) {
            p2 = _checkPropPrefix(p2) || p2;
          }
          if (isTransformRelated || (endNum || endNum === 0) && (startNum || startNum === 0) && !_complexExp.test(endValue) && p2 in style) {
            startUnit = (startValue + "").substr((startNum + "").length);
            endNum || (endNum = 0);
            endUnit = getUnit(endValue) || (p2 in _config.units ? _config.units[p2] : startUnit);
            startUnit !== endUnit && (startNum = _convertToUnit(target, p2, startValue, endUnit));
            this._pt = new PropTween(this._pt, isTransformRelated ? cache2 : style, p2, startNum, (relative ? _parseRelative(startNum, relative + endNum) : endNum) - startNum, !isTransformRelated && (endUnit === "px" || p2 === "zIndex") && vars.autoRound !== false ? _renderRoundedCSSProp : _renderCSSProp);
            this._pt.u = endUnit || 0;
            if (startUnit !== endUnit && endUnit !== "%") {
              this._pt.b = startValue;
              this._pt.r = _renderCSSPropWithBeginning;
            }
          } else if (!(p2 in style)) {
            if (p2 in target) {
              this.add(target, p2, startValue || target[p2], relative ? relative + endValue : endValue, index, targets);
            } else if (p2 !== "parseTransform") {
              _missingPlugin(p2, endValue);
              continue;
            }
          } else {
            _tweenComplexCSSString.call(this, target, p2, startValue, relative ? relative + endValue : endValue);
          }
          isTransformRelated || (p2 in style ? inlineProps.push(p2, 0, style[p2]) : inlineProps.push(p2, 1, startValue || target[p2]));
          props.push(p2);
        }
      }
      hasPriority && _sortPropTweensByPriority(this);
    },
    render: function render2(ratio, data) {
      if (data.tween._time || !_reverting2()) {
        var pt = data._pt;
        while (pt) {
          pt.r(ratio, pt.d);
          pt = pt._next;
        }
      } else {
        data.styles.revert();
      }
    },
    get: _get,
    aliases: _propertyAliases,
    getSetter: function getSetter(target, property, plugin) {
      var p2 = _propertyAliases[property];
      p2 && p2.indexOf(",") < 0 && (property = p2);
      return property in _transformProps && property !== _transformOriginProp && (target._gsap.x || _get(target, "x")) ? plugin && _recentSetterPlugin === plugin ? property === "scale" ? _setterScale : _setterTransform : (_recentSetterPlugin = plugin || {}) && (property === "scale" ? _setterScaleWithRender : _setterTransformWithRender) : target.style && !_isUndefined(target.style[property]) ? _setterCSSStyle : ~property.indexOf("-") ? _setterCSSProp : _getSetter(target, property);
    },
    core: {
      _removeProperty,
      _getMatrix
    }
  };
  gsap.utils.checkPrefix = _checkPropPrefix;
  gsap.core.getStyleSaver = _getStyleSaver;
  (function(positionAndScale, rotation, others, aliases) {
    var all = _forEachName(positionAndScale + "," + rotation + "," + others, function(name) {
      _transformProps[name] = 1;
    });
    _forEachName(rotation, function(name) {
      _config.units[name] = "deg";
      _rotationalProperties[name] = 1;
    });
    _propertyAliases[all[13]] = positionAndScale + "," + rotation;
    _forEachName(aliases, function(name) {
      var split = name.split(":");
      _propertyAliases[split[1]] = all[split[0]];
    });
  })("x,y,z,scale,scaleX,scaleY,xPercent,yPercent", "rotation,rotationX,rotationY,skewX,skewY", "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY");
  _forEachName("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function(name) {
    _config.units[name] = "px";
  });
  gsap.registerPlugin(CSSPlugin);

  // node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/index.js
  var gsapWithCSS = gsap.registerPlugin(CSSPlugin) || gsap;
  var TweenMaxWithCSS = gsapWithCSS.core.Tween;

  // node_modules/.pnpm/locomotive-scroll@5.0.0-beta.13_react@18.3.1/node_modules/locomotive-scroll/dist/locomotive-scroll.modern.mjs
  init_live_reload();

  // node_modules/.pnpm/lenis@1.0.45_react@18.3.1/node_modules/lenis/dist/lenis.mjs
  init_live_reload();
  var __assign = function() {
    return __assign = Object.assign || function __assign2(t6) {
      for (var e8, i5 = 1, o7 = arguments.length; i5 < o7; i5++)
        for (var s5 in e8 = arguments[i5])
          Object.prototype.hasOwnProperty.call(e8, s5) && (t6[s5] = e8[s5]);
      return t6;
    }, __assign.apply(this, arguments);
  };
  function clamp3(t6, e8, i5) {
    return Math.max(t6, Math.min(e8, i5));
  }
  var Animate = class {
    advance(t6) {
      if (!this.isRunning)
        return;
      let e8 = false;
      if (this.lerp)
        this.value = function damp(t7, e9, i5, o7) {
          return function lerp(t8, e10, i6) {
            return (1 - i6) * t8 + i6 * e10;
          }(t7, e9, 1 - Math.exp(-i5 * o7));
        }(this.value, this.to, 60 * this.lerp, t6), Math.round(this.value) === this.to && (this.value = this.to, e8 = true);
      else {
        this.currentTime += t6;
        const i5 = clamp3(0, this.currentTime / this.duration, 1);
        e8 = i5 >= 1;
        const o7 = e8 ? 1 : this.easing(i5);
        this.value = this.from + (this.to - this.from) * o7;
      }
      e8 && this.stop(), this.onUpdate?.(this.value, e8);
    }
    stop() {
      this.isRunning = false;
    }
    fromTo(t6, e8, { lerp: i5 = 0.1, duration: o7 = 1, easing: s5 = (t7) => t7, onStart: n6, onUpdate: r5 }) {
      this.from = this.value = t6, this.to = e8, this.lerp = i5, this.duration = o7, this.easing = s5, this.currentTime = 0, this.isRunning = true, n6?.(), this.onUpdate = r5;
    }
  };
  var Dimensions = class {
    constructor({ wrapper: t6, content: e8, autoResize: i5 = true, debounce: o7 = 250 } = {}) {
      this.wrapper = t6, this.content = e8, i5 && (this.debouncedResize = /* @__PURE__ */ function debounce3(t7, e9) {
        let i6;
        return function() {
          let o8 = arguments, s5 = this;
          clearTimeout(i6), i6 = setTimeout(function() {
            t7.apply(s5, o8);
          }, e9);
        };
      }(this.resize, o7), this.wrapper === window ? window.addEventListener("resize", this.debouncedResize, false) : (this.wrapperResizeObserver = new ResizeObserver(this.debouncedResize), this.wrapperResizeObserver.observe(this.wrapper)), this.contentResizeObserver = new ResizeObserver(this.debouncedResize), this.contentResizeObserver.observe(this.content)), this.resize();
    }
    destroy() {
      this.wrapperResizeObserver?.disconnect(), this.contentResizeObserver?.disconnect(), window.removeEventListener("resize", this.debouncedResize, false);
    }
    resize = () => {
      this.onWrapperResize(), this.onContentResize();
    };
    onWrapperResize = () => {
      this.wrapper === window ? (this.width = window.innerWidth, this.height = window.innerHeight) : (this.width = this.wrapper.clientWidth, this.height = this.wrapper.clientHeight);
    };
    onContentResize = () => {
      this.wrapper === window ? (this.scrollHeight = this.content.scrollHeight, this.scrollWidth = this.content.scrollWidth) : (this.scrollHeight = this.wrapper.scrollHeight, this.scrollWidth = this.wrapper.scrollWidth);
    };
    get limit() {
      return { x: this.scrollWidth - this.width, y: this.scrollHeight - this.height };
    }
  };
  var Emitter = class {
    constructor() {
      this.events = {};
    }
    emit(t6, ...e8) {
      let i5 = this.events[t6] || [];
      for (let t7 = 0, o7 = i5.length; t7 < o7; t7++)
        i5[t7](...e8);
    }
    on(t6, e8) {
      return this.events[t6]?.push(e8) || (this.events[t6] = [e8]), () => {
        this.events[t6] = this.events[t6]?.filter((t7) => e8 !== t7);
      };
    }
    off(t6, e8) {
      this.events[t6] = this.events[t6]?.filter((t7) => e8 !== t7);
    }
    destroy() {
      this.events = {};
    }
  };
  var t = 100 / 6;
  var VirtualScroll = class {
    constructor(t6, { wheelMultiplier: e8 = 1, touchMultiplier: i5 = 1 }) {
      this.element = t6, this.wheelMultiplier = e8, this.touchMultiplier = i5, this.touchStart = { x: null, y: null }, this.emitter = new Emitter(), window.addEventListener("resize", this.onWindowResize, false), this.onWindowResize(), this.element.addEventListener("wheel", this.onWheel, { passive: false }), this.element.addEventListener("touchstart", this.onTouchStart, { passive: false }), this.element.addEventListener("touchmove", this.onTouchMove, { passive: false }), this.element.addEventListener("touchend", this.onTouchEnd, { passive: false });
    }
    on(t6, e8) {
      return this.emitter.on(t6, e8);
    }
    destroy() {
      this.emitter.destroy(), window.removeEventListener("resize", this.onWindowResize, false), this.element.removeEventListener("wheel", this.onWheel, { passive: false }), this.element.removeEventListener("touchstart", this.onTouchStart, { passive: false }), this.element.removeEventListener("touchmove", this.onTouchMove, { passive: false }), this.element.removeEventListener("touchend", this.onTouchEnd, { passive: false });
    }
    onTouchStart = (t6) => {
      const { clientX: e8, clientY: i5 } = t6.targetTouches ? t6.targetTouches[0] : t6;
      this.touchStart.x = e8, this.touchStart.y = i5, this.lastDelta = { x: 0, y: 0 }, this.emitter.emit("scroll", { deltaX: 0, deltaY: 0, event: t6 });
    };
    onTouchMove = (t6) => {
      const { clientX: e8, clientY: i5 } = t6.targetTouches ? t6.targetTouches[0] : t6, o7 = -(e8 - this.touchStart.x) * this.touchMultiplier, s5 = -(i5 - this.touchStart.y) * this.touchMultiplier;
      this.touchStart.x = e8, this.touchStart.y = i5, this.lastDelta = { x: o7, y: s5 }, this.emitter.emit("scroll", { deltaX: o7, deltaY: s5, event: t6 });
    };
    onTouchEnd = (t6) => {
      this.emitter.emit("scroll", { deltaX: this.lastDelta.x, deltaY: this.lastDelta.y, event: t6 });
    };
    onWheel = (e8) => {
      let { deltaX: i5, deltaY: o7, deltaMode: s5 } = e8;
      i5 *= 1 === s5 ? t : 2 === s5 ? this.windowWidth : 1, o7 *= 1 === s5 ? t : 2 === s5 ? this.windowHeight : 1, i5 *= this.wheelMultiplier, o7 *= this.wheelMultiplier, this.emitter.emit("scroll", { deltaX: i5, deltaY: o7, event: e8 });
    };
    onWindowResize = () => {
      this.windowWidth = window.innerWidth, this.windowHeight = window.innerHeight;
    };
  };
  var e = function() {
    function Lenis(t6) {
      var e8 = void 0 === t6 ? {} : t6, i5 = e8.wrapper, o7 = void 0 === i5 ? window : i5, s5 = e8.content, n6 = void 0 === s5 ? document.documentElement : s5, r5 = e8.wheelEventsTarget, l6 = void 0 === r5 ? o7 : r5, h5 = e8.eventsTarget, a4 = void 0 === h5 ? l6 : h5, c4 = e8.smoothWheel, p2 = void 0 === c4 || c4, u2 = e8.syncTouch, d2 = void 0 !== u2 && u2, m2 = e8.syncTouchLerp, v2 = void 0 === m2 ? 0.075 : m2, g2 = e8.touchInertiaMultiplier, f2 = void 0 === g2 ? 35 : g2, S2 = e8.duration, w2 = e8.easing, y2 = void 0 === w2 ? function(t7) {
        return Math.min(1, 1.001 - Math.pow(2, -10 * t7));
      } : w2, b2 = e8.lerp, L2 = void 0 === b2 ? !S2 && 0.1 : b2, _2 = e8.infinite, z2 = void 0 !== _2 && _2, E2 = e8.orientation, T2 = void 0 === E2 ? "vertical" : E2, M2 = e8.gestureOrientation, R2 = void 0 === M2 ? "vertical" : M2, O = e8.touchMultiplier, W = void 0 === O ? 1 : O, x2 = e8.wheelMultiplier, H2 = void 0 === x2 ? 1 : x2, N2 = e8.autoResize, k2 = void 0 === N2 || N2, C2 = e8.__experimental__naiveDimensions, j2 = void 0 !== C2 && C2, P2 = this;
      this.__isSmooth = false, this.__isScrolling = false, this.__isStopped = false, this.__isLocked = false, this.onVirtualScroll = function(t7) {
        var e9 = t7.deltaX, i6 = t7.deltaY, o8 = t7.event;
        if (!o8.ctrlKey) {
          var s6 = o8.type.includes("touch"), n7 = o8.type.includes("wheel");
          if (P2.options.syncTouch && s6 && "touchstart" === o8.type && !P2.isStopped && !P2.isLocked)
            P2.reset();
          else {
            var r6 = 0 === e9 && 0 === i6, l7 = "vertical" === P2.options.gestureOrientation && 0 === i6 || "horizontal" === P2.options.gestureOrientation && 0 === e9;
            if (!r6 && !l7) {
              var h6 = o8.composedPath();
              if (!(h6 = h6.slice(0, h6.indexOf(P2.rootElement))).find(function(t8) {
                var e10, i7, o9, r7, l8;
                return (null === (e10 = t8.hasAttribute) || void 0 === e10 ? void 0 : e10.call(t8, "data-lenis-prevent")) || s6 && (null === (i7 = t8.hasAttribute) || void 0 === i7 ? void 0 : i7.call(t8, "data-lenis-prevent-touch")) || n7 && (null === (o9 = t8.hasAttribute) || void 0 === o9 ? void 0 : o9.call(t8, "data-lenis-prevent-wheel")) || (null === (r7 = t8.classList) || void 0 === r7 ? void 0 : r7.contains("lenis")) && !(null === (l8 = t8.classList) || void 0 === l8 ? void 0 : l8.contains("lenis-stopped"));
              }))
                if (P2.isStopped || P2.isLocked)
                  o8.preventDefault();
                else {
                  if (P2.isSmooth = P2.options.syncTouch && s6 || P2.options.smoothWheel && n7, !P2.isSmooth)
                    return P2.isScrolling = false, void P2.animate.stop();
                  o8.preventDefault();
                  var a5 = i6;
                  "both" === P2.options.gestureOrientation ? a5 = Math.abs(i6) > Math.abs(e9) ? i6 : e9 : "horizontal" === P2.options.gestureOrientation && (a5 = e9);
                  var c5 = s6 && P2.options.syncTouch, p3 = s6 && "touchend" === o8.type && Math.abs(a5) > 5;
                  p3 && (a5 = P2.velocity * P2.options.touchInertiaMultiplier), P2.scrollTo(P2.targetScroll + a5, __assign({ programmatic: false }, c5 ? { lerp: p3 ? P2.options.syncTouchLerp : 1 } : { lerp: P2.options.lerp, duration: P2.options.duration, easing: P2.options.easing }));
                }
            }
          }
        }
      }, this.onNativeScroll = function() {
        if (!P2.__preventNextScrollEvent && !P2.isScrolling) {
          var t7 = P2.animatedScroll;
          P2.animatedScroll = P2.targetScroll = P2.actualScroll, P2.velocity = 0, P2.direction = Math.sign(P2.animatedScroll - t7), P2.emit();
        }
      }, window.lenisVersion = "1.0.45", o7 !== document.documentElement && o7 !== document.body || (o7 = window), this.options = { wrapper: o7, content: n6, wheelEventsTarget: l6, eventsTarget: a4, smoothWheel: p2, syncTouch: d2, syncTouchLerp: v2, touchInertiaMultiplier: f2, duration: S2, easing: y2, lerp: L2, infinite: z2, gestureOrientation: R2, orientation: T2, touchMultiplier: W, wheelMultiplier: H2, autoResize: k2, __experimental__naiveDimensions: j2 }, this.animate = new Animate(), this.emitter = new Emitter(), this.dimensions = new Dimensions({ wrapper: o7, content: n6, autoResize: k2 }), this.toggleClassName("lenis", true), this.velocity = 0, this.isLocked = false, this.isStopped = false, this.isSmooth = d2 || p2, this.isScrolling = false, this.targetScroll = this.animatedScroll = this.actualScroll, this.options.wrapper.addEventListener("scroll", this.onNativeScroll, false), this.virtualScroll = new VirtualScroll(a4, { touchMultiplier: W, wheelMultiplier: H2 }), this.virtualScroll.on("scroll", this.onVirtualScroll);
    }
    return Lenis.prototype.destroy = function() {
      this.emitter.destroy(), this.options.wrapper.removeEventListener("scroll", this.onNativeScroll, false), this.virtualScroll.destroy(), this.dimensions.destroy(), this.toggleClassName("lenis", false), this.toggleClassName("lenis-smooth", false), this.toggleClassName("lenis-scrolling", false), this.toggleClassName("lenis-stopped", false), this.toggleClassName("lenis-locked", false);
    }, Lenis.prototype.on = function(t6, e8) {
      return this.emitter.on(t6, e8);
    }, Lenis.prototype.off = function(t6, e8) {
      return this.emitter.off(t6, e8);
    }, Lenis.prototype.setScroll = function(t6) {
      this.isHorizontal ? this.rootElement.scrollLeft = t6 : this.rootElement.scrollTop = t6;
    }, Lenis.prototype.resize = function() {
      this.dimensions.resize();
    }, Lenis.prototype.emit = function() {
      this.emitter.emit("scroll", this);
    }, Lenis.prototype.reset = function() {
      this.isLocked = false, this.isScrolling = false, this.animatedScroll = this.targetScroll = this.actualScroll, this.velocity = 0, this.animate.stop();
    }, Lenis.prototype.start = function() {
      this.isStopped && (this.isStopped = false, this.reset());
    }, Lenis.prototype.stop = function() {
      this.isStopped || (this.isStopped = true, this.animate.stop(), this.reset());
    }, Lenis.prototype.raf = function(t6) {
      var e8 = t6 - (this.time || t6);
      this.time = t6, this.animate.advance(1e-3 * e8);
    }, Lenis.prototype.scrollTo = function(t6, e8) {
      var i5 = this, o7 = void 0 === e8 ? {} : e8, s5 = o7.offset, n6 = void 0 === s5 ? 0 : s5, r5 = o7.immediate, l6 = void 0 !== r5 && r5, h5 = o7.lock, a4 = void 0 !== h5 && h5, c4 = o7.duration, p2 = void 0 === c4 ? this.options.duration : c4, u2 = o7.easing, d2 = void 0 === u2 ? this.options.easing : u2, m2 = o7.lerp, v2 = void 0 === m2 ? !p2 && this.options.lerp : m2, g2 = o7.onComplete, f2 = o7.force, S2 = void 0 !== f2 && f2, w2 = o7.programmatic, y2 = void 0 === w2 || w2;
      if (!this.isStopped && !this.isLocked || S2) {
        if (["top", "left", "start"].includes(t6))
          t6 = 0;
        else if (["bottom", "right", "end"].includes(t6))
          t6 = this.limit;
        else {
          var b2 = void 0;
          if ("string" == typeof t6 ? b2 = document.querySelector(t6) : (null == t6 ? void 0 : t6.nodeType) && (b2 = t6), b2) {
            if (this.options.wrapper !== window) {
              var L2 = this.options.wrapper.getBoundingClientRect();
              n6 -= this.isHorizontal ? L2.left : L2.top;
            }
            var _2 = b2.getBoundingClientRect();
            t6 = (this.isHorizontal ? _2.left : _2.top) + this.animatedScroll;
          }
        }
        if ("number" == typeof t6) {
          if (t6 += n6, t6 = Math.round(t6), this.options.infinite ? y2 && (this.targetScroll = this.animatedScroll = this.scroll) : t6 = clamp3(0, t6, this.limit), l6)
            return this.animatedScroll = this.targetScroll = t6, this.setScroll(this.scroll), this.reset(), void (null == g2 || g2(this));
          if (!y2) {
            if (t6 === this.targetScroll)
              return;
            this.targetScroll = t6;
          }
          this.animate.fromTo(this.animatedScroll, t6, { duration: p2, easing: d2, lerp: v2, onStart: function() {
            a4 && (i5.isLocked = true), i5.isScrolling = true;
          }, onUpdate: function(t7, e9) {
            i5.isScrolling = true, i5.velocity = t7 - i5.animatedScroll, i5.direction = Math.sign(i5.velocity), i5.animatedScroll = t7, i5.setScroll(i5.scroll), y2 && (i5.targetScroll = t7), e9 || i5.emit(), e9 && (i5.reset(), i5.emit(), null == g2 || g2(i5), i5.__preventNextScrollEvent = true, requestAnimationFrame(function() {
              delete i5.__preventNextScrollEvent;
            }));
          } });
        }
      }
    }, Object.defineProperty(Lenis.prototype, "rootElement", { get: function() {
      return this.options.wrapper === window ? document.documentElement : this.options.wrapper;
    }, enumerable: false, configurable: true }), Object.defineProperty(Lenis.prototype, "limit", { get: function() {
      return this.options.__experimental__naiveDimensions ? this.isHorizontal ? this.rootElement.scrollWidth - this.rootElement.clientWidth : this.rootElement.scrollHeight - this.rootElement.clientHeight : this.dimensions.limit[this.isHorizontal ? "x" : "y"];
    }, enumerable: false, configurable: true }), Object.defineProperty(Lenis.prototype, "isHorizontal", { get: function() {
      return "horizontal" === this.options.orientation;
    }, enumerable: false, configurable: true }), Object.defineProperty(Lenis.prototype, "actualScroll", { get: function() {
      return this.isHorizontal ? this.rootElement.scrollLeft : this.rootElement.scrollTop;
    }, enumerable: false, configurable: true }), Object.defineProperty(Lenis.prototype, "scroll", { get: function() {
      return this.options.infinite ? function modulo(t6, e8) {
        return (t6 % e8 + e8) % e8;
      }(this.animatedScroll, this.limit) : this.animatedScroll;
    }, enumerable: false, configurable: true }), Object.defineProperty(Lenis.prototype, "progress", { get: function() {
      return 0 === this.limit ? 1 : this.scroll / this.limit;
    }, enumerable: false, configurable: true }), Object.defineProperty(Lenis.prototype, "isSmooth", { get: function() {
      return this.__isSmooth;
    }, set: function(t6) {
      this.__isSmooth !== t6 && (this.__isSmooth = t6, this.toggleClassName("lenis-smooth", t6));
    }, enumerable: false, configurable: true }), Object.defineProperty(Lenis.prototype, "isScrolling", { get: function() {
      return this.__isScrolling;
    }, set: function(t6) {
      this.__isScrolling !== t6 && (this.__isScrolling = t6, this.toggleClassName("lenis-scrolling", t6));
    }, enumerable: false, configurable: true }), Object.defineProperty(Lenis.prototype, "isStopped", { get: function() {
      return this.__isStopped;
    }, set: function(t6) {
      this.__isStopped !== t6 && (this.__isStopped = t6, this.toggleClassName("lenis-stopped", t6));
    }, enumerable: false, configurable: true }), Object.defineProperty(Lenis.prototype, "isLocked", { get: function() {
      return this.__isLocked;
    }, set: function(t6) {
      this.__isLocked !== t6 && (this.__isLocked = t6, this.toggleClassName("lenis-locked", t6));
    }, enumerable: false, configurable: true }), Object.defineProperty(Lenis.prototype, "className", { get: function() {
      var t6 = "lenis";
      return this.isStopped && (t6 += " lenis-stopped"), this.isLocked && (t6 += " lenis-locked"), this.isScrolling && (t6 += " lenis-scrolling"), this.isSmooth && (t6 += " lenis-smooth"), t6;
    }, enumerable: false, configurable: true }), Lenis.prototype.toggleClassName = function(t6, e8) {
      this.rootElement.classList.toggle(t6, e8), this.emitter.emit("className change", this);
    }, Lenis;
  }();

  // node_modules/.pnpm/locomotive-scroll@5.0.0-beta.13_react@18.3.1/node_modules/locomotive-scroll/dist/locomotive-scroll.modern.mjs
  function s() {
    return s = Object.assign ? Object.assign.bind() : function(t6) {
      for (var s5 = 1; s5 < arguments.length; s5++) {
        var e8 = arguments[s5];
        for (var i5 in e8)
          Object.prototype.hasOwnProperty.call(e8, i5) && (t6[i5] = e8[i5]);
      }
      return t6;
    }, s.apply(this, arguments);
  }
  var e2 = class {
    constructor({ scrollElements: t6, rootMargin: s5 = "-1px -1px -1px -1px", IORaf: e8 }) {
      this.scrollElements = void 0, this.rootMargin = void 0, this.IORaf = void 0, this.observer = void 0, this.scrollElements = t6, this.rootMargin = s5, this.IORaf = e8, this._init();
    }
    _init() {
      this.observer = new IntersectionObserver((t6) => {
        t6.forEach((t7) => {
          const s5 = this.scrollElements.find((s6) => s6.$el === t7.target);
          t7.isIntersecting ? (s5 && (s5.isAlreadyIntersected = true), this._setInview(t7)) : s5 && s5.isAlreadyIntersected && this._setOutOfView(t7);
        });
      }, { rootMargin: this.rootMargin });
      for (const t6 of this.scrollElements)
        this.observe(t6.$el);
    }
    destroy() {
      this.observer.disconnect();
    }
    observe(t6) {
      t6 && this.observer.observe(t6);
    }
    unobserve(t6) {
      t6 && this.observer.unobserve(t6);
    }
    _setInview(t6) {
      const s5 = this.scrollElements.find((s6) => s6.$el === t6.target);
      this.IORaf && (null == s5 || s5.setInteractivityOn()), !this.IORaf && (null == s5 || s5.setInview());
    }
    _setOutOfView(t6) {
      const s5 = this.scrollElements.find((s6) => s6.$el === t6.target);
      this.IORaf && (null == s5 || s5.setInteractivityOff()), !this.IORaf && (null == s5 || s5.setOutOfView()), null != s5 && s5.attributes.scrollRepeat || this.IORaf || this.unobserve(t6.target);
    }
  };
  function i(t6, s5, e8, i5, r5) {
    return e8 + ((r5 - t6) / (s5 - t6) * (i5 - e8) || 0);
  }
  function r(t6, s5) {
    return t6.reduce((t7, e8) => Math.abs(e8 - s5) < Math.abs(t7 - s5) ? e8 : t7);
  }
  var l = class {
    constructor({ $el: t6, id: s5, modularInstance: e8, subscribeElementUpdateFn: i5, unsubscribeElementUpdateFn: r5, needRaf: l6, scrollOrientation: n6 }) {
      var o7, a4, c4, h5, d2;
      this.$el = void 0, this.id = void 0, this.needRaf = void 0, this.attributes = void 0, this.scrollOrientation = void 0, this.isAlreadyIntersected = void 0, this.intersection = void 0, this.metrics = void 0, this.currentScroll = void 0, this.translateValue = void 0, this.progress = void 0, this.lastProgress = void 0, this.modularInstance = void 0, this.progressModularModules = void 0, this.isInview = void 0, this.isInteractive = void 0, this.isInFold = void 0, this.isFirstResize = void 0, this.subscribeElementUpdateFn = void 0, this.unsubscribeElementUpdateFn = void 0, this.$el = t6, this.id = s5, this.needRaf = l6, this.scrollOrientation = n6, this.modularInstance = e8, this.subscribeElementUpdateFn = i5, this.unsubscribeElementUpdateFn = r5, this.attributes = { scrollClass: null != (o7 = this.$el.dataset.scrollClass) ? o7 : "is-inview", scrollOffset: null != (a4 = this.$el.dataset.scrollOffset) ? a4 : "0,0", scrollPosition: null != (c4 = this.$el.dataset.scrollPosition) ? c4 : "start,end", scrollModuleProgress: null != this.$el.dataset.scrollModuleProgress, scrollCssProgress: null != this.$el.dataset.scrollCssProgress, scrollEventProgress: null != (h5 = this.$el.dataset.scrollEventProgress) ? h5 : null, scrollSpeed: null != this.$el.dataset.scrollSpeed ? parseFloat(this.$el.dataset.scrollSpeed) : null, scrollRepeat: null != this.$el.dataset.scrollRepeat, scrollCall: null != (d2 = this.$el.dataset.scrollCall) ? d2 : null, scrollCallSelf: null != this.$el.dataset.scrollCallSelf, scrollIgnoreFold: null != this.$el.dataset.scrollIgnoreFold, scrollEnableTouchSpeed: null != this.$el.dataset.scrollEnableTouchSpeed }, this.intersection = { start: 0, end: 0 }, this.metrics = { offsetStart: 0, offsetEnd: 0, bcr: {} }, this.currentScroll = "vertical" === this.scrollOrientation ? window.scrollY : window.scrollX, this.translateValue = 0, this.progress = 0, this.lastProgress = null, this.progressModularModules = [], this.isInview = false, this.isInteractive = false, this.isAlreadyIntersected = false, this.isInFold = false, this.isFirstResize = true, this._init();
    }
    _init() {
      this.needRaf && (this.modularInstance && this.attributes.scrollModuleProgress && this._getProgressModularModules(), this._resize());
    }
    onResize({ currentScroll: t6 }) {
      this.currentScroll = t6, this._resize();
    }
    onRender({ currentScroll: t6, smooth: s5 }) {
      const e8 = "vertical" === this.scrollOrientation ? window.innerHeight : window.innerWidth;
      if (this.currentScroll = t6, this._computeProgress(), this.attributes.scrollSpeed && !isNaN(this.attributes.scrollSpeed))
        if (this.attributes.scrollEnableTouchSpeed || s5) {
          if (this.isInFold) {
            const t7 = Math.max(0, this.progress);
            this.translateValue = t7 * e8 * this.attributes.scrollSpeed * -1;
          } else {
            const t7 = i(0, 1, -1, 1, this.progress);
            this.translateValue = t7 * e8 * this.attributes.scrollSpeed * -1;
          }
          this.$el.style.transform = "vertical" === this.scrollOrientation ? `translate3d(0, ${this.translateValue}px, 0)` : `translate3d(${this.translateValue}px, 0, 0)`;
        } else
          this.translateValue && (this.$el.style.transform = "translate3d(0, 0, 0)"), this.translateValue = 0;
    }
    setInview() {
      if (this.isInview)
        return;
      this.isInview = true, this.$el.classList.add(this.attributes.scrollClass);
      const t6 = this._getScrollCallFrom();
      this.attributes.scrollCall && this._dispatchCall("enter", t6);
    }
    setOutOfView() {
      if (!this.isInview || !this.attributes.scrollRepeat)
        return;
      this.isInview = false, this.$el.classList.remove(this.attributes.scrollClass);
      const t6 = this._getScrollCallFrom();
      this.attributes.scrollCall && this._dispatchCall("leave", t6);
    }
    setInteractivityOn() {
      this.isInteractive || (this.isInteractive = true, this.subscribeElementUpdateFn(this));
    }
    setInteractivityOff() {
      this.isInteractive && (this.isInteractive = false, this.unsubscribeElementUpdateFn(this), null != this.lastProgress && this._computeProgress(r([0, 1], this.lastProgress)));
    }
    _resize() {
      this.metrics.bcr = this.$el.getBoundingClientRect(), this._computeMetrics(), this._computeIntersection(), this.isFirstResize && (this.isFirstResize = false, this.isInFold && this.setInview());
    }
    _computeMetrics() {
      const { top: t6, left: s5, height: e8, width: i5 } = this.metrics.bcr, r5 = "vertical" === this.scrollOrientation ? window.innerHeight : window.innerWidth, l6 = "vertical" === this.scrollOrientation ? e8 : i5;
      this.metrics.offsetStart = this.currentScroll + ("vertical" === this.scrollOrientation ? t6 : s5) - this.translateValue, this.metrics.offsetEnd = this.metrics.offsetStart + l6, this.isInFold = this.metrics.offsetStart < r5 && !this.attributes.scrollIgnoreFold;
    }
    _computeIntersection() {
      const t6 = "vertical" === this.scrollOrientation ? window.innerHeight : window.innerWidth, s5 = "vertical" === this.scrollOrientation ? this.metrics.bcr.height : this.metrics.bcr.width, e8 = this.attributes.scrollOffset.split(","), i5 = null != e8[0] ? e8[0].trim() : "0", r5 = null != e8[1] ? e8[1].trim() : "0", l6 = this.attributes.scrollPosition.split(",");
      let n6 = null != l6[0] ? l6[0].trim() : "start";
      const o7 = null != l6[1] ? l6[1].trim() : "end", a4 = i5.includes("%") ? t6 * parseInt(i5.replace("%", "").trim()) * 0.01 : parseInt(i5), c4 = r5.includes("%") ? t6 * parseInt(r5.replace("%", "").trim()) * 0.01 : parseInt(r5);
      switch (this.isInFold && (n6 = "fold"), n6) {
        case "start":
        default:
          this.intersection.start = this.metrics.offsetStart - t6 + a4;
          break;
        case "middle":
          this.intersection.start = this.metrics.offsetStart - t6 + a4 + 0.5 * s5;
          break;
        case "end":
          this.intersection.start = this.metrics.offsetStart - t6 + a4 + s5;
          break;
        case "fold":
          this.intersection.start = 0;
      }
      switch (o7) {
        case "start":
          this.intersection.end = this.metrics.offsetStart - c4;
          break;
        case "middle":
          this.intersection.end = this.metrics.offsetStart - c4 + 0.5 * s5;
          break;
        default:
          this.intersection.end = this.metrics.offsetStart - c4 + s5;
      }
      if (this.intersection.end <= this.intersection.start)
        switch (o7) {
          case "start":
          default:
            this.intersection.end = this.intersection.start + 1;
            break;
          case "middle":
            this.intersection.end = this.intersection.start + 0.5 * s5;
            break;
          case "end":
            this.intersection.end = this.intersection.start + s5;
        }
    }
    _computeProgress(t6) {
      const s5 = null != t6 ? t6 : (e8 = i(this.intersection.start, this.intersection.end, 0, 1, this.currentScroll)) < 0 ? 0 : e8 > 1 ? 1 : e8;
      var e8;
      if (this.progress = s5, s5 != this.lastProgress) {
        if (this.lastProgress = s5, this.attributes.scrollCssProgress && this._setCssProgress(s5), this.attributes.scrollEventProgress && this._setCustomEventProgress(s5), this.attributes.scrollModuleProgress)
          for (const t7 of this.progressModularModules)
            this.modularInstance && this.modularInstance.call("onScrollProgress", s5, t7.moduleName, t7.moduleId);
        s5 > 0 && s5 < 1 && this.setInview(), 0 === s5 && this.setOutOfView(), 1 === s5 && this.setOutOfView();
      }
    }
    _setCssProgress(t6 = 0) {
      this.$el.style.setProperty("--progress", t6.toString());
    }
    _setCustomEventProgress(t6 = 0) {
      const s5 = this.attributes.scrollEventProgress;
      if (!s5)
        return;
      const e8 = new CustomEvent(s5, { detail: { target: this.$el, progress: t6 } });
      window.dispatchEvent(e8);
    }
    _getProgressModularModules() {
      if (!this.modularInstance)
        return;
      const t6 = Object.keys(this.$el.dataset).filter((t7) => t7.includes("module")), s5 = Object.entries(this.modularInstance.modules);
      if (t6.length)
        for (const e8 of t6) {
          const t7 = this.$el.dataset[e8];
          if (!t7)
            return;
          for (const e9 of s5) {
            const [s6, i5] = e9;
            t7 in i5 && this.progressModularModules.push({ moduleName: s6, moduleId: t7 });
          }
        }
    }
    _getScrollCallFrom() {
      const t6 = r([this.intersection.start, this.intersection.end], this.currentScroll);
      return this.intersection.start === t6 ? "start" : "end";
    }
    _dispatchCall(t6, s5) {
      var e8, i5;
      const r5 = null == (e8 = this.attributes.scrollCall) ? void 0 : e8.split(","), l6 = null == (i5 = this.attributes) ? void 0 : i5.scrollCallSelf;
      if (r5 && r5.length > 1) {
        var n6;
        const [e9, i6, o7] = r5;
        let a4;
        a4 = l6 ? this.$el.dataset[`module${i6.trim()}`] : o7, this.modularInstance && this.modularInstance.call(e9.trim(), { target: this.$el, way: t6, from: s5 }, i6.trim(), null == (n6 = a4) ? void 0 : n6.trim());
      } else if (r5) {
        const [e9] = r5, i6 = new CustomEvent(e9, { detail: { target: this.$el, way: t6, from: s5 } });
        window.dispatchEvent(i6);
      }
    }
  };
  var n = ["scrollOffset", "scrollPosition", "scrollModuleProgress", "scrollCssProgress", "scrollEventProgress", "scrollSpeed"];
  var o = class {
    constructor({ $el: t6, modularInstance: s5, triggerRootMargin: e8, rafRootMargin: i5, scrollOrientation: r5 }) {
      this.$scrollContainer = void 0, this.modularInstance = void 0, this.triggerRootMargin = void 0, this.rafRootMargin = void 0, this.scrollElements = void 0, this.triggeredScrollElements = void 0, this.RAFScrollElements = void 0, this.scrollElementsToUpdate = void 0, this.IOTriggerInstance = void 0, this.IORafInstance = void 0, this.scrollOrientation = void 0, t6 ? (this.$scrollContainer = t6, this.modularInstance = s5, this.scrollOrientation = r5, this.triggerRootMargin = null != e8 ? e8 : "-1px -1px -1px -1px", this.rafRootMargin = null != i5 ? i5 : "100% 100% 100% 100%", this.scrollElements = [], this.triggeredScrollElements = [], this.RAFScrollElements = [], this.scrollElementsToUpdate = [], this._init()) : console.error("Please provide a DOM Element as scrollContainer");
    }
    _init() {
      const t6 = this.$scrollContainer.querySelectorAll("[data-scroll]"), s5 = Array.from(t6);
      this._subscribeScrollElements(s5), this.IOTriggerInstance = new e2({ scrollElements: [...this.triggeredScrollElements], rootMargin: this.triggerRootMargin, IORaf: false }), this.IORafInstance = new e2({ scrollElements: [...this.RAFScrollElements], rootMargin: this.rafRootMargin, IORaf: true });
    }
    destroy() {
      this.IOTriggerInstance.destroy(), this.IORafInstance.destroy(), this._unsubscribeAllScrollElements();
    }
    onResize({ currentScroll: t6 }) {
      for (const s5 of this.RAFScrollElements)
        s5.onResize({ currentScroll: t6 });
    }
    onRender({ currentScroll: t6, smooth: s5 }) {
      for (const e8 of this.scrollElementsToUpdate)
        e8.onRender({ currentScroll: t6, smooth: s5 });
    }
    removeScrollElements(t6) {
      const s5 = t6.querySelectorAll("[data-scroll]");
      if (s5.length) {
        for (let t7 = 0; t7 < this.triggeredScrollElements.length; t7++) {
          const e8 = this.triggeredScrollElements[t7];
          Array.from(s5).indexOf(e8.$el) > -1 && (this.IOTriggerInstance.unobserve(e8.$el), this.triggeredScrollElements.splice(t7, 1));
        }
        for (let t7 = 0; t7 < this.RAFScrollElements.length; t7++) {
          const e8 = this.RAFScrollElements[t7];
          Array.from(s5).indexOf(e8.$el) > -1 && (this.IORafInstance.unobserve(e8.$el), this.RAFScrollElements.splice(t7, 1));
        }
        s5.forEach((t7) => {
          const s6 = this.scrollElementsToUpdate.find((s7) => s7.$el === t7), e8 = this.scrollElements.find((s7) => s7.$el === t7);
          s6 && this._unsubscribeElementUpdate(s6), e8 && (this.scrollElements = this.scrollElements.filter((t8) => t8.id != e8.id));
        });
      }
    }
    addScrollElements(t6) {
      const s5 = t6.querySelectorAll("[data-scroll]"), e8 = [];
      this.scrollElements.forEach((t7) => {
        e8.push(t7.id);
      });
      const i5 = Math.max(...e8) + 1, r5 = Array.from(s5);
      this._subscribeScrollElements(r5, i5, true);
    }
    _subscribeScrollElements(t6, s5 = 0, e8 = false) {
      for (let i5 = 0; i5 < t6.length; i5++) {
        const r5 = t6[i5], n6 = this._checkRafNeeded(r5), o7 = new l({ $el: r5, id: s5 + i5, scrollOrientation: this.scrollOrientation, modularInstance: this.modularInstance, subscribeElementUpdateFn: this._subscribeElementUpdate.bind(this), unsubscribeElementUpdateFn: this._unsubscribeElementUpdate.bind(this), needRaf: n6 });
        this.scrollElements.push(o7), n6 ? (this.RAFScrollElements.push(o7), e8 && (this.IORafInstance.scrollElements.push(o7), this.IORafInstance.observe(o7.$el))) : (this.triggeredScrollElements.push(o7), e8 && (this.IOTriggerInstance.scrollElements.push(o7), this.IOTriggerInstance.observe(o7.$el)));
      }
    }
    _unsubscribeAllScrollElements() {
      this.scrollElements = [], this.RAFScrollElements = [], this.triggeredScrollElements = [], this.scrollElementsToUpdate = [];
    }
    _subscribeElementUpdate(t6) {
      this.scrollElementsToUpdate.push(t6);
    }
    _unsubscribeElementUpdate(t6) {
      this.scrollElementsToUpdate = this.scrollElementsToUpdate.filter((s5) => s5.id != t6.id);
    }
    _checkRafNeeded(t6) {
      let s5 = [...n];
      const e8 = (t7) => {
        s5 = s5.filter((s6) => s6 != t7);
      };
      if (t6.dataset.scrollOffset) {
        if ("0,0" != t6.dataset.scrollOffset.split(",").map((t7) => t7.replace("%", "").trim()).join(","))
          return true;
        e8("scrollOffset");
      } else
        e8("scrollOffset");
      if (t6.dataset.scrollPosition) {
        if ("top,bottom" != t6.dataset.scrollPosition.trim())
          return true;
        e8("scrollPosition");
      } else
        e8("scrollPosition");
      if (t6.dataset.scrollSpeed && !isNaN(parseFloat(t6.dataset.scrollSpeed)))
        return true;
      e8("scrollSpeed");
      for (const e9 of s5)
        if (e9 in t6.dataset)
          return true;
      return false;
    }
  };
  var a = class {
    constructor({ resizeElements: t6, resizeCallback: s5 = () => {
    } }) {
      this.$resizeElements = void 0, this.isFirstObserve = void 0, this.observer = void 0, this.resizeCallback = void 0, this.$resizeElements = t6, this.resizeCallback = s5, this.isFirstObserve = true, this._init();
    }
    _init() {
      this.observer = new ResizeObserver((t6) => {
        var s5;
        !this.isFirstObserve && (null == (s5 = this.resizeCallback) || s5.call(this)), this.isFirstObserve = false;
      });
      for (const t6 of this.$resizeElements)
        this.observer.observe(t6);
    }
    destroy() {
      this.observer.disconnect();
    }
  };
  var c = { wrapper: window, content: document.documentElement, wheelEventsTarget: window, eventsTarget: window, smoothWheel: true, syncTouch: false, syncTouchLerp: 0.075, touchInertiaMultiplier: 35, duration: 0.75, easing: (t6) => Math.min(1, 1.001 - Math.pow(2, -10 * t6)), lerp: 0.1, infinite: false, orientation: "vertical", gestureOrientation: "vertical", touchMultiplier: 1, wheelMultiplier: 1, autoResize: true };
  var h = class {
    constructor({ lenisOptions: t6 = {}, modularInstance: e8, triggerRootMargin: i5, rafRootMargin: r5, autoResize: l6 = true, autoStart: n6 = true, scrollCallback: o7 = () => {
    }, initCustomTicker: a4, destroyCustomTicker: h5 } = {}) {
      this.rafPlaying = void 0, this.lenisInstance = void 0, this.coreInstance = void 0, this.lenisOptions = void 0, this.modularInstance = void 0, this.triggerRootMargin = void 0, this.rafRootMargin = void 0, this.rafInstance = void 0, this.autoResize = void 0, this.autoStart = void 0, this.ROInstance = void 0, this.initCustomTicker = void 0, this.destroyCustomTicker = void 0, this._onRenderBind = void 0, this._onResizeBind = void 0, this._onScrollToBind = void 0, this.lenisOptions = s({}, c, t6), Object.assign(this, { lenisOptions: t6, modularInstance: e8, triggerRootMargin: i5, rafRootMargin: r5, autoResize: l6, autoStart: n6, scrollCallback: o7, initCustomTicker: a4, destroyCustomTicker: h5 }), this._onRenderBind = this._onRender.bind(this), this._onScrollToBind = this._onScrollTo.bind(this), this._onResizeBind = this._onResize.bind(this), this.rafPlaying = false, this._init();
    }
    _init() {
      var s5;
      this.lenisInstance = new e({ wrapper: this.lenisOptions.wrapper, content: this.lenisOptions.content, eventsTarget: this.lenisOptions.eventsTarget, lerp: this.lenisOptions.lerp, duration: this.lenisOptions.duration, orientation: this.lenisOptions.orientation, gestureOrientation: this.lenisOptions.gestureOrientation, smoothWheel: this.lenisOptions.smoothWheel, syncTouch: this.lenisOptions.syncTouch, syncTouchLerp: this.lenisOptions.syncTouchLerp, touchInertiaMultiplier: this.lenisOptions.touchInertiaMultiplier, wheelMultiplier: this.lenisOptions.wheelMultiplier, touchMultiplier: this.lenisOptions.touchMultiplier, easing: this.lenisOptions.easing }), null == (s5 = this.lenisInstance) || s5.on("scroll", this.scrollCallback), document.documentElement.setAttribute("data-scroll-orientation", this.lenisInstance.options.orientation), requestAnimationFrame(() => {
        this.coreInstance = new o({ $el: this.lenisInstance.rootElement, modularInstance: this.modularInstance, triggerRootMargin: this.triggerRootMargin, rafRootMargin: this.rafRootMargin, scrollOrientation: this.lenisInstance.options.orientation }), this._bindEvents(), this.initCustomTicker && !this.destroyCustomTicker ? console.warn("initCustomTicker callback is declared, but destroyCustomTicker is not. Please pay attention. It could cause trouble.") : !this.initCustomTicker && this.destroyCustomTicker && console.warn("destroyCustomTicker callback is declared, but initCustomTicker is not. Please pay attention. It could cause trouble."), this.autoStart && this.start();
      });
    }
    destroy() {
      var t6;
      this.stop(), this._unbindEvents(), this.lenisInstance.destroy(), null == (t6 = this.coreInstance) || t6.destroy(), requestAnimationFrame(() => {
        var t7;
        null == (t7 = this.coreInstance) || t7.destroy();
      });
    }
    _bindEvents() {
      this._bindScrollToEvents(), this.autoResize && ("ResizeObserver" in window ? this.ROInstance = new a({ resizeElements: [document.body], resizeCallback: this._onResizeBind }) : window.addEventListener("resize", this._onResizeBind));
    }
    _unbindEvents() {
      this._unbindScrollToEvents(), this.autoResize && ("ResizeObserver" in window ? this.ROInstance && this.ROInstance.destroy() : window.removeEventListener("resize", this._onResizeBind));
    }
    _bindScrollToEvents(t6) {
      const s5 = t6 || this.lenisInstance.rootElement, e8 = null == s5 ? void 0 : s5.querySelectorAll("[data-scroll-to]");
      (null == e8 ? void 0 : e8.length) && e8.forEach((t7) => {
        t7.addEventListener("click", this._onScrollToBind, false);
      });
    }
    _unbindScrollToEvents(t6) {
      const s5 = t6 || this.lenisInstance.rootElement, e8 = null == s5 ? void 0 : s5.querySelectorAll("[data-scroll-to]");
      (null == e8 ? void 0 : e8.length) && e8.forEach((t7) => {
        t7.removeEventListener("click", this._onScrollToBind, false);
      });
    }
    _onResize() {
      requestAnimationFrame(() => {
        var t6;
        null == (t6 = this.coreInstance) || t6.onResize({ currentScroll: this.lenisInstance.scroll });
      });
    }
    _onRender() {
      var t6, s5;
      null == (t6 = this.lenisInstance) || t6.raf(Date.now()), null == (s5 = this.coreInstance) || s5.onRender({ currentScroll: this.lenisInstance.scroll, smooth: this.lenisInstance.isSmooth });
    }
    _onScrollTo(t6) {
      var s5;
      t6.preventDefault();
      const e8 = null != (s5 = t6.currentTarget) ? s5 : null;
      if (!e8)
        return;
      const i5 = e8.getAttribute("data-scroll-to-href") || e8.getAttribute("href"), r5 = e8.getAttribute("data-scroll-to-offset") || 0, l6 = e8.getAttribute("data-scroll-to-duration") || this.lenisOptions.duration || c.duration;
      i5 && this.scrollTo(i5, { offset: "string" == typeof r5 ? parseInt(r5) : r5, duration: "string" == typeof l6 ? parseInt(l6) : l6 });
    }
    start() {
      var t6;
      this.rafPlaying || (null == (t6 = this.lenisInstance) || t6.start(), this.rafPlaying = true, this.initCustomTicker ? this.initCustomTicker(this._onRenderBind) : this._raf());
    }
    stop() {
      var t6;
      this.rafPlaying && (null == (t6 = this.lenisInstance) || t6.stop(), this.rafPlaying = false, this.destroyCustomTicker ? this.destroyCustomTicker(this._onRenderBind) : this.rafInstance && cancelAnimationFrame(this.rafInstance));
    }
    removeScrollElements(t6) {
      var s5;
      t6 ? (this._unbindScrollToEvents(t6), null == (s5 = this.coreInstance) || s5.removeScrollElements(t6)) : console.error("Please provide a DOM Element as $oldContainer");
    }
    addScrollElements(t6) {
      var s5;
      t6 ? (null == (s5 = this.coreInstance) || s5.addScrollElements(t6), requestAnimationFrame(() => {
        this._bindScrollToEvents(t6);
      })) : console.error("Please provide a DOM Element as $newContainer");
    }
    resize() {
      this._onResizeBind();
    }
    scrollTo(t6, s5) {
      var e8;
      null == (e8 = this.lenisInstance) || e8.scrollTo(t6, { offset: null == s5 ? void 0 : s5.offset, lerp: null == s5 ? void 0 : s5.lerp, duration: null == s5 ? void 0 : s5.duration, immediate: null == s5 ? void 0 : s5.immediate, lock: null == s5 ? void 0 : s5.lock, force: null == s5 ? void 0 : s5.force, easing: null == s5 ? void 0 : s5.easing, onComplete: null == s5 ? void 0 : s5.onComplete });
    }
    _raf() {
      this._onRenderBind(), this.rafInstance = requestAnimationFrame(() => this._raf());
    }
  };

  // node_modules/.pnpm/mouse-follower@1.1.2/node_modules/mouse-follower/dist/index.module.js
  init_live_reload();
  var MouseFollower = /* @__PURE__ */ function() {
    MouseFollower2.registerGSAP = function registerGSAP(gsap5) {
      MouseFollower2.gsap = gsap5;
    };
    function MouseFollower2(options) {
      if (options === void 0) {
        options = {};
      }
      this.options = Object.assign({}, {
        el: null,
        container: document.body,
        className: "mf-cursor",
        innerClassName: "mf-cursor-inner",
        textClassName: "mf-cursor-text",
        mediaClassName: "mf-cursor-media",
        mediaBoxClassName: "mf-cursor-media-box",
        iconSvgClassName: "mf-svgsprite",
        iconSvgNamePrefix: "-",
        iconSvgSrc: "",
        dataAttr: "cursor",
        hiddenState: "-hidden",
        textState: "-text",
        iconState: "-icon",
        activeState: "-active",
        mediaState: "-media",
        stateDetection: {
          "-pointer": "a,button"
        },
        visible: true,
        visibleOnState: false,
        speed: 0.55,
        ease: "expo.out",
        overwrite: true,
        skewing: 0,
        skewingText: 2,
        skewingIcon: 2,
        skewingMedia: 2,
        skewingDelta: 1e-3,
        skewingDeltaMax: 0.15,
        stickDelta: 0.15,
        showTimeout: 0,
        hideOnLeave: true,
        hideTimeout: 300,
        hideMediaTimeout: 300,
        initialPos: [-window.innerWidth, -window.innerHeight]
      }, options);
      if (this.options.visible && options.stateDetection == null)
        this.options.stateDetection["-hidden"] = "iframe";
      this.gsap = MouseFollower2.gsap || window.gsap;
      this.el = typeof this.options.el === "string" ? document.querySelector(this.options.el) : this.options.el;
      this.container = typeof this.options.container === "string" ? document.querySelector(this.options.container) : this.options.container;
      this.skewing = this.options.skewing;
      this.pos = {
        x: this.options.initialPos[0],
        y: this.options.initialPos[1]
      };
      this.vel = {
        x: 0,
        y: 0
      };
      this.event = {};
      this.events = [];
      this.init();
    }
    var _proto = MouseFollower2.prototype;
    _proto.init = function init5() {
      if (!this.el)
        this.create();
      this.createSetter();
      this.bind();
      this.render(true);
      this.ticker = this.render.bind(this, false);
      this.gsap.ticker.add(this.ticker);
    };
    _proto.create = function create() {
      this.el = document.createElement("div");
      this.el.className = this.options.className;
      this.el.classList.add(this.options.hiddenState);
      this.inner = document.createElement("div");
      this.inner.className = this.options.innerClassName;
      this.text = document.createElement("div");
      this.text.className = this.options.textClassName;
      this.media = document.createElement("div");
      this.media.className = this.options.mediaClassName;
      this.mediaBox = document.createElement("div");
      this.mediaBox.className = this.options.mediaBoxClassName;
      this.media.appendChild(this.mediaBox);
      this.inner.appendChild(this.media);
      this.inner.appendChild(this.text);
      this.el.appendChild(this.inner);
      this.container.appendChild(this.el);
    };
    _proto.createSetter = function createSetter() {
      this.setter = {
        x: this.gsap.quickSetter(this.el, "x", "px"),
        y: this.gsap.quickSetter(this.el, "y", "px"),
        rotation: this.gsap.quickSetter(this.el, "rotation", "deg"),
        scaleX: this.gsap.quickSetter(this.el, "scaleX"),
        scaleY: this.gsap.quickSetter(this.el, "scaleY"),
        wc: this.gsap.quickSetter(this.el, "willChange"),
        inner: {
          rotation: this.gsap.quickSetter(this.inner, "rotation", "deg")
        }
      };
    };
    _proto.bind = function bind() {
      var _this = this;
      this.event.mouseleave = function() {
        return _this.hide();
      };
      this.event.mouseenter = function() {
        return _this.show();
      };
      this.event.mousedown = function() {
        return _this.addState(_this.options.activeState);
      };
      this.event.mouseup = function() {
        return _this.removeState(_this.options.activeState);
      };
      this.event.mousemoveOnce = function() {
        return _this.show();
      };
      this.event.mousemove = function(e8) {
        _this.gsap.to(_this.pos, {
          x: _this.stick ? _this.stick.x - (_this.stick.x - e8.clientX) * _this.options.stickDelta : e8.clientX,
          y: _this.stick ? _this.stick.y - (_this.stick.y - e8.clientY) * _this.options.stickDelta : e8.clientY,
          overwrite: _this.options.overwrite,
          ease: _this.options.ease,
          duration: _this.visible ? _this.options.speed : 0,
          onUpdate: function onUpdate() {
            return _this.vel = {
              x: e8.clientX - _this.pos.x,
              y: e8.clientY - _this.pos.y
            };
          }
        });
      };
      this.event.mouseover = function(e8) {
        for (var target = e8.target; target && target !== _this.container; target = target.parentNode) {
          if (e8.relatedTarget && target.contains(e8.relatedTarget))
            break;
          for (var state in _this.options.stateDetection) {
            if (target.matches(_this.options.stateDetection[state]))
              _this.addState(state);
          }
          if (_this.options.dataAttr) {
            var params = _this.getFromDataset(target);
            if (params.state)
              _this.addState(params.state);
            if (params.text)
              _this.setText(params.text);
            if (params.icon)
              _this.setIcon(params.icon);
            if (params.img)
              _this.setImg(params.img);
            if (params.video)
              _this.setVideo(params.video);
            if (typeof params.show !== "undefined")
              _this.show();
            if (typeof params.stick !== "undefined")
              _this.setStick(params.stick || target);
          }
        }
      };
      this.event.mouseout = function(e8) {
        for (var target = e8.target; target && target !== _this.container; target = target.parentNode) {
          if (e8.relatedTarget && target.contains(e8.relatedTarget))
            break;
          for (var state in _this.options.stateDetection) {
            if (target.matches(_this.options.stateDetection[state]))
              _this.removeState(state);
          }
          if (_this.options.dataAttr) {
            var params = _this.getFromDataset(target);
            if (params.state)
              _this.removeState(params.state);
            if (params.text)
              _this.removeText();
            if (params.icon)
              _this.removeIcon();
            if (params.img)
              _this.removeImg();
            if (params.video)
              _this.removeVideo();
            if (typeof params.show !== "undefined")
              _this.hide();
            if (typeof params.stick !== "undefined")
              _this.removeStick();
          }
        }
      };
      if (this.options.hideOnLeave) {
        this.container.addEventListener("mouseleave", this.event.mouseleave, {
          passive: true
        });
      }
      if (this.options.visible) {
        this.container.addEventListener("mouseenter", this.event.mouseenter, {
          passive: true
        });
      }
      if (this.options.activeState) {
        this.container.addEventListener("mousedown", this.event.mousedown, {
          passive: true
        });
        this.container.addEventListener("mouseup", this.event.mouseup, {
          passive: true
        });
      }
      this.container.addEventListener("mousemove", this.event.mousemove, {
        passive: true
      });
      if (this.options.visible) {
        this.container.addEventListener("mousemove", this.event.mousemoveOnce, {
          passive: true,
          once: true
        });
      }
      if (this.options.stateDetection || this.options.dataAttr) {
        this.container.addEventListener("mouseover", this.event.mouseover, {
          passive: true
        });
        this.container.addEventListener("mouseout", this.event.mouseout, {
          passive: true
        });
      }
    };
    _proto.render = function render4(force) {
      if (force !== true && (this.vel.y === 0 || this.vel.x === 0)) {
        this.setter.wc("auto");
        return;
      }
      this.trigger("render");
      this.setter.wc("transform");
      this.setter.x(this.pos.x);
      this.setter.y(this.pos.y);
      if (this.skewing) {
        var distance = Math.sqrt(Math.pow(this.vel.x, 2) + Math.pow(this.vel.y, 2));
        var scale = Math.min(distance * this.options.skewingDelta, this.options.skewingDeltaMax) * this.skewing;
        var angle = Math.atan2(this.vel.y, this.vel.x) * 180 / Math.PI;
        this.setter.rotation(angle);
        this.setter.scaleX(1 + scale);
        this.setter.scaleY(1 - scale);
        this.setter.inner.rotation(-angle);
      }
    };
    _proto.show = function show() {
      var _this2 = this;
      this.trigger("show");
      clearInterval(this.visibleInt);
      this.visibleInt = setTimeout(function() {
        _this2.el.classList.remove(_this2.options.hiddenState);
        _this2.visible = true;
        _this2.render(true);
      }, this.options.showTimeout);
    };
    _proto.hide = function hide2() {
      var _this3 = this;
      this.trigger("hide");
      clearInterval(this.visibleInt);
      this.el.classList.add(this.options.hiddenState);
      this.visibleInt = setTimeout(function() {
        return _this3.visible = false;
      }, this.options.hideTimeout);
    };
    _proto.toggle = function toggle(force) {
      if (force === true || force !== false && !this.visible) {
        this.show();
      } else {
        this.hide();
      }
    };
    _proto.addState = function addState(state) {
      var _this$el$classList;
      this.trigger("addState", state);
      if (state === this.options.hiddenState)
        return this.hide();
      (_this$el$classList = this.el.classList).add.apply(_this$el$classList, state.split(" "));
      if (this.options.visibleOnState)
        this.show();
    };
    _proto.removeState = function removeState(state) {
      var _this$el$classList2;
      this.trigger("removeState", state);
      if (state === this.options.hiddenState)
        return this.show();
      (_this$el$classList2 = this.el.classList).remove.apply(_this$el$classList2, state.split(" "));
      if (this.options.visibleOnState && this.el.className === this.options.className)
        this.hide();
    };
    _proto.toggleState = function toggleState(state, force) {
      if (force === true || force !== false && !this.el.classList.contains(state)) {
        this.addState(state);
      } else {
        this.removeState(state);
      }
    };
    _proto.setSkewing = function setSkewing(value) {
      this.gsap.to(this, {
        skewing: value
      });
    };
    _proto.removeSkewing = function removeSkewing() {
      this.gsap.to(this, {
        skewing: this.options.skewing
      });
    };
    _proto.setStick = function setStick(element) {
      var el = typeof element === "string" ? document.querySelector(element) : element;
      var rect = el.getBoundingClientRect();
      this.stick = {
        y: rect.top + rect.height / 2,
        x: rect.left + rect.width / 2
      };
    };
    _proto.removeStick = function removeStick() {
      this.stick = false;
    };
    _proto.setText = function setText(text) {
      this.text.innerHTML = text;
      this.addState(this.options.textState);
      this.setSkewing(this.options.skewingText);
    };
    _proto.removeText = function removeText() {
      this.removeState(this.options.textState);
      this.removeSkewing();
    };
    _proto.setIcon = function setIcon(name, style) {
      if (style === void 0) {
        style = "";
      }
      this.text.innerHTML = "<svg class='" + this.options.iconSvgClassName + " " + this.options.iconSvgNamePrefix + name + "'" + (" style='" + style + "'><use xlink:href='" + this.options.iconSvgSrc + "#" + name + "'></use></svg>");
      this.addState(this.options.iconState);
      this.setSkewing(this.options.skewingIcon);
    };
    _proto.removeIcon = function removeIcon() {
      this.removeState(this.options.iconState);
      this.removeSkewing();
    };
    _proto.setMedia = function setMedia(element) {
      var _this4 = this;
      clearTimeout(this.mediaInt);
      if (element) {
        this.mediaBox.innerHTML = "";
        this.mediaBox.appendChild(element);
      }
      this.mediaInt = setTimeout(function() {
        return _this4.addState(_this4.options.mediaState);
      }, 20);
      this.setSkewing(this.options.skewingMedia);
    };
    _proto.removeMedia = function removeMedia() {
      var _this5 = this;
      clearTimeout(this.mediaInt);
      this.removeState(this.options.mediaState);
      this.mediaInt = setTimeout(function() {
        return _this5.mediaBox.innerHTML = "";
      }, this.options.hideMediaTimeout);
      this.removeSkewing();
    };
    _proto.setImg = function setImg(url) {
      if (!this.mediaImg)
        this.mediaImg = new Image();
      if (this.mediaImg.src !== url)
        this.mediaImg.src = url;
      this.setMedia(this.mediaImg);
    };
    _proto.removeImg = function removeImg() {
      this.removeMedia();
    };
    _proto.setVideo = function setVideo(url) {
      if (!this.mediaVideo) {
        this.mediaVideo = document.createElement("video");
        this.mediaVideo.muted = true;
        this.mediaVideo.loop = true;
        this.mediaVideo.autoplay = true;
      }
      if (this.mediaVideo.src !== url) {
        this.mediaVideo.src = url;
        this.mediaVideo.load();
      }
      this.mediaVideo.play();
      this.setMedia(this.mediaVideo);
    };
    _proto.removeVideo = function removeVideo() {
      if (this.mediaVideo && this.mediaVideo.readyState > 2)
        this.mediaVideo.pause();
      this.removeMedia();
    };
    _proto.on = function on(event2, callback) {
      if (!(this.events[event2] instanceof Array))
        this.off(event2);
      this.events[event2].push(callback);
    };
    _proto.off = function off(event2, callback) {
      if (callback) {
        this.events[event2] = this.events[event2].filter(function(f2) {
          return f2 !== callback;
        });
      } else {
        this.events[event2] = [];
      }
    };
    _proto.trigger = function trigger(event2) {
      var _arguments = arguments, _this6 = this;
      if (!this.events[event2])
        return;
      this.events[event2].forEach(function(f2) {
        return f2.call.apply(f2, [_this6, _this6].concat([].slice.call(_arguments, 1)));
      });
    };
    _proto.getFromDataset = function getFromDataset(element) {
      var dataset = element.dataset;
      return {
        state: dataset[this.options.dataAttr],
        show: dataset[this.options.dataAttr + "Show"],
        text: dataset[this.options.dataAttr + "Text"],
        icon: dataset[this.options.dataAttr + "Icon"],
        img: dataset[this.options.dataAttr + "Img"],
        video: dataset[this.options.dataAttr + "Video"],
        stick: dataset[this.options.dataAttr + "Stick"]
      };
    };
    _proto.destroy = function destroy() {
      this.trigger("destroy");
      this.gsap.ticker.remove(this.ticker);
      this.container.removeEventListener("mouseleave", this.event.mouseleave);
      this.container.removeEventListener("mouseenter", this.event.mouseenter);
      this.container.removeEventListener("mousedown", this.event.mousedown);
      this.container.removeEventListener("mouseup", this.event.mouseup);
      this.container.removeEventListener("mousemove", this.event.mousemove);
      this.container.removeEventListener("mousemove", this.event.mousemoveOnce);
      this.container.removeEventListener("mouseover", this.event.mouseover);
      this.container.removeEventListener("mouseout", this.event.mouseout);
      if (this.el) {
        this.container.removeChild(this.el);
        this.el = null;
        this.mediaImg = null;
        this.mediaVideo = null;
      }
    };
    return MouseFollower2;
  }();

  // node_modules/.pnpm/split-type@0.3.4/node_modules/split-type/dist/index.js
  init_live_reload();
  (function() {
    function append() {
      var length = arguments.length;
      for (var i5 = 0; i5 < length; i5++) {
        var node = i5 < 0 || arguments.length <= i5 ? void 0 : arguments[i5];
        if (node.nodeType === 1 || node.nodeType === 11)
          this.appendChild(node);
        else
          this.appendChild(document.createTextNode(String(node)));
      }
    }
    function replaceChildren() {
      while (this.lastChild) {
        this.removeChild(this.lastChild);
      }
      if (arguments.length)
        this.append.apply(this, arguments);
    }
    function replaceWith() {
      var parent = this.parentNode;
      for (var _len = arguments.length, nodes = new Array(_len), _key = 0; _key < _len; _key++) {
        nodes[_key] = arguments[_key];
      }
      var i5 = nodes.length;
      if (!parent)
        return;
      if (!i5)
        parent.removeChild(this);
      while (i5--) {
        var node = nodes[i5];
        if (typeof node !== "object") {
          node = this.ownerDocument.createTextNode(node);
        } else if (node.parentNode) {
          node.parentNode.removeChild(node);
        }
        if (!i5) {
          parent.replaceChild(node, this);
        } else {
          parent.insertBefore(this.previousSibling, node);
        }
      }
    }
    if (typeof Element !== "undefined") {
      if (!Element.prototype.append) {
        Element.prototype.append = append;
        DocumentFragment.prototype.append = append;
      }
      if (!Element.prototype.replaceChildren) {
        Element.prototype.replaceChildren = replaceChildren;
        DocumentFragment.prototype.replaceChildren = replaceChildren;
      }
      if (!Element.prototype.replaceWith) {
        Element.prototype.replaceWith = replaceWith;
        DocumentFragment.prototype.replaceWith = replaceWith;
      }
    }
  })();
  function extend(target, object) {
    return Object.getOwnPropertyNames(Object(target)).reduce(function(extended, key2) {
      var currentValue = Object.getOwnPropertyDescriptor(Object(target), key2);
      var newValue = Object.getOwnPropertyDescriptor(Object(object), key2);
      return Object.defineProperty(extended, key2, newValue || currentValue);
    }, {});
  }
  var rsAstralRange = "\\ud800-\\udfff";
  var rsComboMarksRange = "\\u0300-\\u036f\\ufe20-\\ufe23";
  var rsComboSymbolsRange = "\\u20d0-\\u20f0";
  var rsVarRange = "\\ufe0e\\ufe0f";
  var rsAstral = "[".concat(rsAstralRange, "]");
  var rsCombo = "[".concat(rsComboMarksRange).concat(rsComboSymbolsRange, "]");
  var rsFitz = "\\ud83c[\\udffb-\\udfff]";
  var rsModifier = "(?:".concat(rsCombo, "|").concat(rsFitz, ")");
  var rsNonAstral = "[^".concat(rsAstralRange, "]");
  var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
  var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
  var rsZWJ = "\\u200d";
  var reOptMod = "".concat(rsModifier, "?");
  var rsOptVar = "[".concat(rsVarRange, "]?");
  var rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
  var rsSeq = rsOptVar + reOptMod + rsOptJoin;
  var rsSymbol = "(?:".concat(["".concat(rsNonAstral).concat(rsCombo, "?"), rsCombo, rsRegional, rsSurrPair, rsAstral].join("|"), "\n)");
  var reUnicode = RegExp("".concat(rsFitz, "(?=").concat(rsFitz, ")|").concat(rsSymbol).concat(rsSeq), "g");
  var unicodeRange = [rsZWJ, rsAstralRange, rsComboMarksRange, rsComboSymbolsRange, rsVarRange];
  var reHasUnicode = RegExp("[".concat(unicodeRange.join(""), "]"));
  var defaults2 = {
    splitClass: "",
    lineClass: "line",
    wordClass: "word",
    charClass: "char",
    types: ["lines", "words", "chars"],
    absolute: false,
    tagName: "div"
  };
  var _defaults2 = extend(defaults2, {});

  // src/globalCode.ts
  function initializeglobalCode() {
    const locomotiveScroll = new h();
    MouseFollower.registerGSAP(gsapWithCSS);
    const cursor = new MouseFollower();
  }

  // src/iconsRotacao.ts
  init_live_reload();
  function initializeMarqueeAnimation() {
    $(".marquee").each(function() {
      const track = $(this).find(".marquee_track");
      const items = $(this).find(".marquee_item");
      const tl = gsapWithCSS.timeline({
        repeat: -1,
        defaults: { ease: "expo.inOut", duration: 1, delay: 1 }
      });
      items.each((index, item) => {
        tl.to(track, { yPercent: (index + 1) * -100 });
      });
      items.first().clone().appendTo(track);
    });
  }

  // src/missaoAnimation.ts
  init_live_reload();

  // node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/ScrollToPlugin.js
  init_live_reload();
  var gsap2;
  var _coreInitted2;
  var _window;
  var _docEl;
  var _body;
  var _toArray;
  var _config2;
  var ScrollTrigger;
  var _windowExists5 = function _windowExists6() {
    return typeof window !== "undefined";
  };
  var _getGSAP = function _getGSAP2() {
    return gsap2 || _windowExists5() && (gsap2 = window.gsap) && gsap2.registerPlugin && gsap2;
  };
  var _isString3 = function _isString4(value) {
    return typeof value === "string";
  };
  var _isFunction3 = function _isFunction4(value) {
    return typeof value === "function";
  };
  var _max = function _max2(element, axis) {
    var dim = axis === "x" ? "Width" : "Height", scroll = "scroll" + dim, client = "client" + dim;
    return element === _window || element === _docEl || element === _body ? Math.max(_docEl[scroll], _body[scroll]) - (_window["inner" + dim] || _docEl[client] || _body[client]) : element[scroll] - element["offset" + dim];
  };
  var _buildGetter = function _buildGetter2(e8, axis) {
    var p2 = "scroll" + (axis === "x" ? "Left" : "Top");
    if (e8 === _window) {
      if (e8.pageXOffset != null) {
        p2 = "page" + axis.toUpperCase() + "Offset";
      } else {
        e8 = _docEl[p2] != null ? _docEl : _body;
      }
    }
    return function() {
      return e8[p2];
    };
  };
  var _clean = function _clean2(value, index, target, targets) {
    _isFunction3(value) && (value = value(index, target, targets));
    if (typeof value !== "object") {
      return _isString3(value) && value !== "max" && value.charAt(1) !== "=" ? {
        x: value,
        y: value
      } : {
        y: value
      };
    } else if (value.nodeType) {
      return {
        y: value,
        x: value
      };
    } else {
      var result = {}, p2;
      for (p2 in value) {
        result[p2] = p2 !== "onAutoKill" && _isFunction3(value[p2]) ? value[p2](index, target, targets) : value[p2];
      }
      return result;
    }
  };
  var _getOffset = function _getOffset2(element, container) {
    element = _toArray(element)[0];
    if (!element || !element.getBoundingClientRect) {
      return console.warn("scrollTo target doesn't exist. Using 0") || {
        x: 0,
        y: 0
      };
    }
    var rect = element.getBoundingClientRect(), isRoot = !container || container === _window || container === _body, cRect = isRoot ? {
      top: _docEl.clientTop - (_window.pageYOffset || _docEl.scrollTop || _body.scrollTop || 0),
      left: _docEl.clientLeft - (_window.pageXOffset || _docEl.scrollLeft || _body.scrollLeft || 0)
    } : container.getBoundingClientRect(), offsets = {
      x: rect.left - cRect.left,
      y: rect.top - cRect.top
    };
    if (!isRoot && container) {
      offsets.x += _buildGetter(container, "x")();
      offsets.y += _buildGetter(container, "y")();
    }
    return offsets;
  };
  var _parseVal = function _parseVal2(value, target, axis, currentVal, offset2) {
    return !isNaN(value) && typeof value !== "object" ? parseFloat(value) - offset2 : _isString3(value) && value.charAt(1) === "=" ? parseFloat(value.substr(2)) * (value.charAt(0) === "-" ? -1 : 1) + currentVal - offset2 : value === "max" ? _max(target, axis) - offset2 : Math.min(_max(target, axis), _getOffset(value, target)[axis] - offset2);
  };
  var _initCore3 = function _initCore4() {
    gsap2 = _getGSAP();
    if (_windowExists5() && gsap2 && typeof document !== "undefined" && document.body) {
      _window = window;
      _body = document.body;
      _docEl = document.documentElement;
      _toArray = gsap2.utils.toArray;
      gsap2.config({
        autoKillThreshold: 7
      });
      _config2 = gsap2.config();
      _coreInitted2 = 1;
    }
  };
  var ScrollToPlugin = {
    version: "3.12.5",
    name: "scrollTo",
    rawVars: 1,
    register: function register(core) {
      gsap2 = core;
      _initCore3();
    },
    init: function init4(target, value, tween, index, targets) {
      _coreInitted2 || _initCore3();
      var data = this, snapType = gsap2.getProperty(target, "scrollSnapType");
      data.isWin = target === _window;
      data.target = target;
      data.tween = tween;
      value = _clean(value, index, target, targets);
      data.vars = value;
      data.autoKill = !!value.autoKill;
      data.getX = _buildGetter(target, "x");
      data.getY = _buildGetter(target, "y");
      data.x = data.xPrev = data.getX();
      data.y = data.yPrev = data.getY();
      ScrollTrigger || (ScrollTrigger = gsap2.core.globals().ScrollTrigger);
      gsap2.getProperty(target, "scrollBehavior") === "smooth" && gsap2.set(target, {
        scrollBehavior: "auto"
      });
      if (snapType && snapType !== "none") {
        data.snap = 1;
        data.snapInline = target.style.scrollSnapType;
        target.style.scrollSnapType = "none";
      }
      if (value.x != null) {
        data.add(data, "x", data.x, _parseVal(value.x, target, "x", data.x, value.offsetX || 0), index, targets);
        data._props.push("scrollTo_x");
      } else {
        data.skipX = 1;
      }
      if (value.y != null) {
        data.add(data, "y", data.y, _parseVal(value.y, target, "y", data.y, value.offsetY || 0), index, targets);
        data._props.push("scrollTo_y");
      } else {
        data.skipY = 1;
      }
    },
    render: function render3(ratio, data) {
      var pt = data._pt, target = data.target, tween = data.tween, autoKill = data.autoKill, xPrev = data.xPrev, yPrev = data.yPrev, isWin = data.isWin, snap3 = data.snap, snapInline = data.snapInline, x2, y2, yDif, xDif, threshold;
      while (pt) {
        pt.r(ratio, pt.d);
        pt = pt._next;
      }
      x2 = isWin || !data.skipX ? data.getX() : xPrev;
      y2 = isWin || !data.skipY ? data.getY() : yPrev;
      yDif = y2 - yPrev;
      xDif = x2 - xPrev;
      threshold = _config2.autoKillThreshold;
      if (data.x < 0) {
        data.x = 0;
      }
      if (data.y < 0) {
        data.y = 0;
      }
      if (autoKill) {
        if (!data.skipX && (xDif > threshold || xDif < -threshold) && x2 < _max(target, "x")) {
          data.skipX = 1;
        }
        if (!data.skipY && (yDif > threshold || yDif < -threshold) && y2 < _max(target, "y")) {
          data.skipY = 1;
        }
        if (data.skipX && data.skipY) {
          tween.kill();
          data.vars.onAutoKill && data.vars.onAutoKill.apply(tween, data.vars.onAutoKillParams || []);
        }
      }
      if (isWin) {
        _window.scrollTo(!data.skipX ? data.x : x2, !data.skipY ? data.y : y2);
      } else {
        data.skipY || (target.scrollTop = data.y);
        data.skipX || (target.scrollLeft = data.x);
      }
      if (snap3 && (ratio === 1 || ratio === 0)) {
        y2 = target.scrollTop;
        x2 = target.scrollLeft;
        snapInline ? target.style.scrollSnapType = snapInline : target.style.removeProperty("scroll-snap-type");
        target.scrollTop = y2 + 1;
        target.scrollLeft = x2 + 1;
        target.scrollTop = y2;
        target.scrollLeft = x2;
      }
      data.xPrev = data.x;
      data.yPrev = data.y;
      ScrollTrigger && ScrollTrigger.update();
    },
    kill: function kill(property) {
      var both = property === "scrollTo", i5 = this._props.indexOf(property);
      if (both || property === "scrollTo_x") {
        this.skipX = 1;
      }
      if (both || property === "scrollTo_y") {
        this.skipY = 1;
      }
      i5 > -1 && this._props.splice(i5, 1);
      return !this._props.length;
    }
  };
  ScrollToPlugin.max = _max;
  ScrollToPlugin.getOffset = _getOffset;
  ScrollToPlugin.buildGetter = _buildGetter;
  _getGSAP() && gsap2.registerPlugin(ScrollToPlugin);

  // node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/ScrollTrigger.js
  init_live_reload();

  // node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/Observer.js
  init_live_reload();
  function _defineProperties(target, props) {
    for (var i5 = 0; i5 < props.length; i5++) {
      var descriptor = props[i5];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties(Constructor, staticProps);
    return Constructor;
  }
  var gsap3;
  var _coreInitted3;
  var _clamp3;
  var _win3;
  var _doc3;
  var _docEl2;
  var _body2;
  var _isTouch;
  var _pointerType;
  var ScrollTrigger2;
  var _root;
  var _normalizer;
  var _eventTypes;
  var _context2;
  var _getGSAP3 = function _getGSAP4() {
    return gsap3 || typeof window !== "undefined" && (gsap3 = window.gsap) && gsap3.registerPlugin && gsap3;
  };
  var _startup = 1;
  var _observers = [];
  var _scrollers = [];
  var _proxies = [];
  var _getTime = Date.now;
  var _bridge = function _bridge2(name, value) {
    return value;
  };
  var _integrate = function _integrate2() {
    var core = ScrollTrigger2.core, data = core.bridge || {}, scrollers = core._scrollers, proxies = core._proxies;
    scrollers.push.apply(scrollers, _scrollers);
    proxies.push.apply(proxies, _proxies);
    _scrollers = scrollers;
    _proxies = proxies;
    _bridge = function _bridge3(name, value) {
      return data[name](value);
    };
  };
  var _getProxyProp = function _getProxyProp2(element, property) {
    return ~_proxies.indexOf(element) && _proxies[_proxies.indexOf(element) + 1][property];
  };
  var _isViewport = function _isViewport2(el) {
    return !!~_root.indexOf(el);
  };
  var _addListener = function _addListener2(element, type, func, passive, capture) {
    return element.addEventListener(type, func, {
      passive: passive !== false,
      capture: !!capture
    });
  };
  var _removeListener = function _removeListener2(element, type, func, capture) {
    return element.removeEventListener(type, func, !!capture);
  };
  var _scrollLeft = "scrollLeft";
  var _scrollTop = "scrollTop";
  var _onScroll = function _onScroll2() {
    return _normalizer && _normalizer.isPressed || _scrollers.cache++;
  };
  var _scrollCacheFunc = function _scrollCacheFunc2(f2, doNotCache) {
    var cachingFunc = function cachingFunc2(value) {
      if (value || value === 0) {
        _startup && (_win3.history.scrollRestoration = "manual");
        var isNormalizing = _normalizer && _normalizer.isPressed;
        value = cachingFunc2.v = Math.round(value) || (_normalizer && _normalizer.iOS ? 1 : 0);
        f2(value);
        cachingFunc2.cacheID = _scrollers.cache;
        isNormalizing && _bridge("ss", value);
      } else if (doNotCache || _scrollers.cache !== cachingFunc2.cacheID || _bridge("ref")) {
        cachingFunc2.cacheID = _scrollers.cache;
        cachingFunc2.v = f2();
      }
      return cachingFunc2.v + cachingFunc2.offset;
    };
    cachingFunc.offset = 0;
    return f2 && cachingFunc;
  };
  var _horizontal = {
    s: _scrollLeft,
    p: "left",
    p2: "Left",
    os: "right",
    os2: "Right",
    d: "width",
    d2: "Width",
    a: "x",
    sc: _scrollCacheFunc(function(value) {
      return arguments.length ? _win3.scrollTo(value, _vertical.sc()) : _win3.pageXOffset || _doc3[_scrollLeft] || _docEl2[_scrollLeft] || _body2[_scrollLeft] || 0;
    })
  };
  var _vertical = {
    s: _scrollTop,
    p: "top",
    p2: "Top",
    os: "bottom",
    os2: "Bottom",
    d: "height",
    d2: "Height",
    a: "y",
    op: _horizontal,
    sc: _scrollCacheFunc(function(value) {
      return arguments.length ? _win3.scrollTo(_horizontal.sc(), value) : _win3.pageYOffset || _doc3[_scrollTop] || _docEl2[_scrollTop] || _body2[_scrollTop] || 0;
    })
  };
  var _getTarget = function _getTarget2(t6, self) {
    return (self && self._ctx && self._ctx.selector || gsap3.utils.toArray)(t6)[0] || (typeof t6 === "string" && gsap3.config().nullTargetWarn !== false ? console.warn("Element not found:", t6) : null);
  };
  var _getScrollFunc = function _getScrollFunc2(element, _ref) {
    var s5 = _ref.s, sc = _ref.sc;
    _isViewport(element) && (element = _doc3.scrollingElement || _docEl2);
    var i5 = _scrollers.indexOf(element), offset2 = sc === _vertical.sc ? 1 : 2;
    !~i5 && (i5 = _scrollers.push(element) - 1);
    _scrollers[i5 + offset2] || _addListener(element, "scroll", _onScroll);
    var prev = _scrollers[i5 + offset2], func = prev || (_scrollers[i5 + offset2] = _scrollCacheFunc(_getProxyProp(element, s5), true) || (_isViewport(element) ? sc : _scrollCacheFunc(function(value) {
      return arguments.length ? element[s5] = value : element[s5];
    })));
    func.target = element;
    prev || (func.smooth = gsap3.getProperty(element, "scrollBehavior") === "smooth");
    return func;
  };
  var _getVelocityProp = function _getVelocityProp2(value, minTimeRefresh, useDelta) {
    var v1 = value, v2 = value, t1 = _getTime(), t22 = t1, min2 = minTimeRefresh || 50, dropToZeroTime = Math.max(500, min2 * 3), update3 = function update4(value2, force) {
      var t6 = _getTime();
      if (force || t6 - t1 > min2) {
        v2 = v1;
        v1 = value2;
        t22 = t1;
        t1 = t6;
      } else if (useDelta) {
        v1 += value2;
      } else {
        v1 = v2 + (value2 - v2) / (t6 - t22) * (t1 - t22);
      }
    }, reset = function reset2() {
      v2 = v1 = useDelta ? 0 : v1;
      t22 = t1 = 0;
    }, getVelocity = function getVelocity2(latestValue) {
      var tOld = t22, vOld = v2, t6 = _getTime();
      (latestValue || latestValue === 0) && latestValue !== v1 && update3(latestValue);
      return t1 === t22 || t6 - t22 > dropToZeroTime ? 0 : (v1 + (useDelta ? vOld : -vOld)) / ((useDelta ? t6 : t1) - tOld) * 1e3;
    };
    return {
      update: update3,
      reset,
      getVelocity
    };
  };
  var _getEvent = function _getEvent2(e8, preventDefault) {
    preventDefault && !e8._gsapAllow && e8.preventDefault();
    return e8.changedTouches ? e8.changedTouches[0] : e8;
  };
  var _getAbsoluteMax = function _getAbsoluteMax2(a4) {
    var max2 = Math.max.apply(Math, a4), min2 = Math.min.apply(Math, a4);
    return Math.abs(max2) >= Math.abs(min2) ? max2 : min2;
  };
  var _setScrollTrigger = function _setScrollTrigger2() {
    ScrollTrigger2 = gsap3.core.globals().ScrollTrigger;
    ScrollTrigger2 && ScrollTrigger2.core && _integrate();
  };
  var _initCore5 = function _initCore6(core) {
    gsap3 = core || _getGSAP3();
    if (!_coreInitted3 && gsap3 && typeof document !== "undefined" && document.body) {
      _win3 = window;
      _doc3 = document;
      _docEl2 = _doc3.documentElement;
      _body2 = _doc3.body;
      _root = [_win3, _doc3, _docEl2, _body2];
      _clamp3 = gsap3.utils.clamp;
      _context2 = gsap3.core.context || function() {
      };
      _pointerType = "onpointerenter" in _body2 ? "pointer" : "mouse";
      _isTouch = Observer.isTouch = _win3.matchMedia && _win3.matchMedia("(hover: none), (pointer: coarse)").matches ? 1 : "ontouchstart" in _win3 || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0 ? 2 : 0;
      _eventTypes = Observer.eventTypes = ("ontouchstart" in _docEl2 ? "touchstart,touchmove,touchcancel,touchend" : !("onpointerdown" in _docEl2) ? "mousedown,mousemove,mouseup,mouseup" : "pointerdown,pointermove,pointercancel,pointerup").split(",");
      setTimeout(function() {
        return _startup = 0;
      }, 500);
      _setScrollTrigger();
      _coreInitted3 = 1;
    }
    return _coreInitted3;
  };
  _horizontal.op = _vertical;
  _scrollers.cache = 0;
  var Observer = /* @__PURE__ */ function() {
    function Observer3(vars) {
      this.init(vars);
    }
    var _proto = Observer3.prototype;
    _proto.init = function init5(vars) {
      _coreInitted3 || _initCore5(gsap3) || console.warn("Please gsap.registerPlugin(Observer)");
      ScrollTrigger2 || _setScrollTrigger();
      var tolerance = vars.tolerance, dragMinimum = vars.dragMinimum, type = vars.type, target = vars.target, lineHeight = vars.lineHeight, debounce3 = vars.debounce, preventDefault = vars.preventDefault, onStop = vars.onStop, onStopDelay = vars.onStopDelay, ignore = vars.ignore, wheelSpeed = vars.wheelSpeed, event2 = vars.event, onDragStart = vars.onDragStart, onDragEnd = vars.onDragEnd, onDrag = vars.onDrag, onPress2 = vars.onPress, onRelease = vars.onRelease, onRight = vars.onRight, onLeft = vars.onLeft, onUp = vars.onUp, onDown = vars.onDown, onChangeX = vars.onChangeX, onChangeY = vars.onChangeY, onChange = vars.onChange, onToggleX = vars.onToggleX, onToggleY = vars.onToggleY, onHover = vars.onHover, onHoverEnd = vars.onHoverEnd, onMove = vars.onMove, ignoreCheck = vars.ignoreCheck, isNormalizer = vars.isNormalizer, onGestureStart = vars.onGestureStart, onGestureEnd = vars.onGestureEnd, onWheel = vars.onWheel, onEnable = vars.onEnable, onDisable = vars.onDisable, onClick2 = vars.onClick, scrollSpeed = vars.scrollSpeed, capture = vars.capture, allowClicks = vars.allowClicks, lockAxis = vars.lockAxis, onLockAxis = vars.onLockAxis;
      this.target = target = _getTarget(target) || _docEl2;
      this.vars = vars;
      ignore && (ignore = gsap3.utils.toArray(ignore));
      tolerance = tolerance || 1e-9;
      dragMinimum = dragMinimum || 0;
      wheelSpeed = wheelSpeed || 1;
      scrollSpeed = scrollSpeed || 1;
      type = type || "wheel,touch,pointer";
      debounce3 = debounce3 !== false;
      lineHeight || (lineHeight = parseFloat(_win3.getComputedStyle(_body2).lineHeight) || 22);
      var id, onStopDelayedCall, dragged, moved, wheeled, locked, axis, self = this, prevDeltaX = 0, prevDeltaY = 0, passive = vars.passive || !preventDefault, scrollFuncX = _getScrollFunc(target, _horizontal), scrollFuncY = _getScrollFunc(target, _vertical), scrollX = scrollFuncX(), scrollY = scrollFuncY(), limitToTouch = ~type.indexOf("touch") && !~type.indexOf("pointer") && _eventTypes[0] === "pointerdown", isViewport = _isViewport(target), ownerDoc = target.ownerDocument || _doc3, deltaX = [0, 0, 0], deltaY = [0, 0, 0], onClickTime = 0, clickCapture = function clickCapture2() {
        return onClickTime = _getTime();
      }, _ignoreCheck = function _ignoreCheck2(e8, isPointerOrTouch) {
        return (self.event = e8) && ignore && ~ignore.indexOf(e8.target) || isPointerOrTouch && limitToTouch && e8.pointerType !== "touch" || ignoreCheck && ignoreCheck(e8, isPointerOrTouch);
      }, onStopFunc = function onStopFunc2() {
        self._vx.reset();
        self._vy.reset();
        onStopDelayedCall.pause();
        onStop && onStop(self);
      }, update3 = function update4() {
        var dx = self.deltaX = _getAbsoluteMax(deltaX), dy = self.deltaY = _getAbsoluteMax(deltaY), changedX = Math.abs(dx) >= tolerance, changedY = Math.abs(dy) >= tolerance;
        onChange && (changedX || changedY) && onChange(self, dx, dy, deltaX, deltaY);
        if (changedX) {
          onRight && self.deltaX > 0 && onRight(self);
          onLeft && self.deltaX < 0 && onLeft(self);
          onChangeX && onChangeX(self);
          onToggleX && self.deltaX < 0 !== prevDeltaX < 0 && onToggleX(self);
          prevDeltaX = self.deltaX;
          deltaX[0] = deltaX[1] = deltaX[2] = 0;
        }
        if (changedY) {
          onDown && self.deltaY > 0 && onDown(self);
          onUp && self.deltaY < 0 && onUp(self);
          onChangeY && onChangeY(self);
          onToggleY && self.deltaY < 0 !== prevDeltaY < 0 && onToggleY(self);
          prevDeltaY = self.deltaY;
          deltaY[0] = deltaY[1] = deltaY[2] = 0;
        }
        if (moved || dragged) {
          onMove && onMove(self);
          if (dragged) {
            onDrag(self);
            dragged = false;
          }
          moved = false;
        }
        locked && !(locked = false) && onLockAxis && onLockAxis(self);
        if (wheeled) {
          onWheel(self);
          wheeled = false;
        }
        id = 0;
      }, onDelta = function onDelta2(x2, y2, index) {
        deltaX[index] += x2;
        deltaY[index] += y2;
        self._vx.update(x2);
        self._vy.update(y2);
        debounce3 ? id || (id = requestAnimationFrame(update3)) : update3();
      }, onTouchOrPointerDelta = function onTouchOrPointerDelta2(x2, y2) {
        if (lockAxis && !axis) {
          self.axis = axis = Math.abs(x2) > Math.abs(y2) ? "x" : "y";
          locked = true;
        }
        if (axis !== "y") {
          deltaX[2] += x2;
          self._vx.update(x2, true);
        }
        if (axis !== "x") {
          deltaY[2] += y2;
          self._vy.update(y2, true);
        }
        debounce3 ? id || (id = requestAnimationFrame(update3)) : update3();
      }, _onDrag = function _onDrag2(e8) {
        if (_ignoreCheck(e8, 1)) {
          return;
        }
        e8 = _getEvent(e8, preventDefault);
        var x2 = e8.clientX, y2 = e8.clientY, dx = x2 - self.x, dy = y2 - self.y, isDragging = self.isDragging;
        self.x = x2;
        self.y = y2;
        if (isDragging || Math.abs(self.startX - x2) >= dragMinimum || Math.abs(self.startY - y2) >= dragMinimum) {
          onDrag && (dragged = true);
          isDragging || (self.isDragging = true);
          onTouchOrPointerDelta(dx, dy);
          isDragging || onDragStart && onDragStart(self);
        }
      }, _onPress = self.onPress = function(e8) {
        if (_ignoreCheck(e8, 1) || e8 && e8.button) {
          return;
        }
        self.axis = axis = null;
        onStopDelayedCall.pause();
        self.isPressed = true;
        e8 = _getEvent(e8);
        prevDeltaX = prevDeltaY = 0;
        self.startX = self.x = e8.clientX;
        self.startY = self.y = e8.clientY;
        self._vx.reset();
        self._vy.reset();
        _addListener(isNormalizer ? target : ownerDoc, _eventTypes[1], _onDrag, passive, true);
        self.deltaX = self.deltaY = 0;
        onPress2 && onPress2(self);
      }, _onRelease = self.onRelease = function(e8) {
        if (_ignoreCheck(e8, 1)) {
          return;
        }
        _removeListener(isNormalizer ? target : ownerDoc, _eventTypes[1], _onDrag, true);
        var isTrackingDrag = !isNaN(self.y - self.startY), wasDragging = self.isDragging, isDragNotClick = wasDragging && (Math.abs(self.x - self.startX) > 3 || Math.abs(self.y - self.startY) > 3), eventData = _getEvent(e8);
        if (!isDragNotClick && isTrackingDrag) {
          self._vx.reset();
          self._vy.reset();
          if (preventDefault && allowClicks) {
            gsap3.delayedCall(0.08, function() {
              if (_getTime() - onClickTime > 300 && !e8.defaultPrevented) {
                if (e8.target.click) {
                  e8.target.click();
                } else if (ownerDoc.createEvent) {
                  var syntheticEvent = ownerDoc.createEvent("MouseEvents");
                  syntheticEvent.initMouseEvent("click", true, true, _win3, 1, eventData.screenX, eventData.screenY, eventData.clientX, eventData.clientY, false, false, false, false, 0, null);
                  e8.target.dispatchEvent(syntheticEvent);
                }
              }
            });
          }
        }
        self.isDragging = self.isGesturing = self.isPressed = false;
        onStop && wasDragging && !isNormalizer && onStopDelayedCall.restart(true);
        onDragEnd && wasDragging && onDragEnd(self);
        onRelease && onRelease(self, isDragNotClick);
      }, _onGestureStart = function _onGestureStart2(e8) {
        return e8.touches && e8.touches.length > 1 && (self.isGesturing = true) && onGestureStart(e8, self.isDragging);
      }, _onGestureEnd = function _onGestureEnd2() {
        return (self.isGesturing = false) || onGestureEnd(self);
      }, onScroll2 = function onScroll3(e8) {
        if (_ignoreCheck(e8)) {
          return;
        }
        var x2 = scrollFuncX(), y2 = scrollFuncY();
        onDelta((x2 - scrollX) * scrollSpeed, (y2 - scrollY) * scrollSpeed, 1);
        scrollX = x2;
        scrollY = y2;
        onStop && onStopDelayedCall.restart(true);
      }, _onWheel = function _onWheel2(e8) {
        if (_ignoreCheck(e8)) {
          return;
        }
        e8 = _getEvent(e8, preventDefault);
        onWheel && (wheeled = true);
        var multiplier = (e8.deltaMode === 1 ? lineHeight : e8.deltaMode === 2 ? _win3.innerHeight : 1) * wheelSpeed;
        onDelta(e8.deltaX * multiplier, e8.deltaY * multiplier, 0);
        onStop && !isNormalizer && onStopDelayedCall.restart(true);
      }, _onMove = function _onMove2(e8) {
        if (_ignoreCheck(e8)) {
          return;
        }
        var x2 = e8.clientX, y2 = e8.clientY, dx = x2 - self.x, dy = y2 - self.y;
        self.x = x2;
        self.y = y2;
        moved = true;
        onStop && onStopDelayedCall.restart(true);
        (dx || dy) && onTouchOrPointerDelta(dx, dy);
      }, _onHover = function _onHover2(e8) {
        self.event = e8;
        onHover(self);
      }, _onHoverEnd = function _onHoverEnd2(e8) {
        self.event = e8;
        onHoverEnd(self);
      }, _onClick = function _onClick2(e8) {
        return _ignoreCheck(e8) || _getEvent(e8, preventDefault) && onClick2(self);
      };
      onStopDelayedCall = self._dc = gsap3.delayedCall(onStopDelay || 0.25, onStopFunc).pause();
      self.deltaX = self.deltaY = 0;
      self._vx = _getVelocityProp(0, 50, true);
      self._vy = _getVelocityProp(0, 50, true);
      self.scrollX = scrollFuncX;
      self.scrollY = scrollFuncY;
      self.isDragging = self.isGesturing = self.isPressed = false;
      _context2(this);
      self.enable = function(e8) {
        if (!self.isEnabled) {
          _addListener(isViewport ? ownerDoc : target, "scroll", _onScroll);
          type.indexOf("scroll") >= 0 && _addListener(isViewport ? ownerDoc : target, "scroll", onScroll2, passive, capture);
          type.indexOf("wheel") >= 0 && _addListener(target, "wheel", _onWheel, passive, capture);
          if (type.indexOf("touch") >= 0 && _isTouch || type.indexOf("pointer") >= 0) {
            _addListener(target, _eventTypes[0], _onPress, passive, capture);
            _addListener(ownerDoc, _eventTypes[2], _onRelease);
            _addListener(ownerDoc, _eventTypes[3], _onRelease);
            allowClicks && _addListener(target, "click", clickCapture, true, true);
            onClick2 && _addListener(target, "click", _onClick);
            onGestureStart && _addListener(ownerDoc, "gesturestart", _onGestureStart);
            onGestureEnd && _addListener(ownerDoc, "gestureend", _onGestureEnd);
            onHover && _addListener(target, _pointerType + "enter", _onHover);
            onHoverEnd && _addListener(target, _pointerType + "leave", _onHoverEnd);
            onMove && _addListener(target, _pointerType + "move", _onMove);
          }
          self.isEnabled = true;
          e8 && e8.type && _onPress(e8);
          onEnable && onEnable(self);
        }
        return self;
      };
      self.disable = function() {
        if (self.isEnabled) {
          _observers.filter(function(o7) {
            return o7 !== self && _isViewport(o7.target);
          }).length || _removeListener(isViewport ? ownerDoc : target, "scroll", _onScroll);
          if (self.isPressed) {
            self._vx.reset();
            self._vy.reset();
            _removeListener(isNormalizer ? target : ownerDoc, _eventTypes[1], _onDrag, true);
          }
          _removeListener(isViewport ? ownerDoc : target, "scroll", onScroll2, capture);
          _removeListener(target, "wheel", _onWheel, capture);
          _removeListener(target, _eventTypes[0], _onPress, capture);
          _removeListener(ownerDoc, _eventTypes[2], _onRelease);
          _removeListener(ownerDoc, _eventTypes[3], _onRelease);
          _removeListener(target, "click", clickCapture, true);
          _removeListener(target, "click", _onClick);
          _removeListener(ownerDoc, "gesturestart", _onGestureStart);
          _removeListener(ownerDoc, "gestureend", _onGestureEnd);
          _removeListener(target, _pointerType + "enter", _onHover);
          _removeListener(target, _pointerType + "leave", _onHoverEnd);
          _removeListener(target, _pointerType + "move", _onMove);
          self.isEnabled = self.isPressed = self.isDragging = false;
          onDisable && onDisable(self);
        }
      };
      self.kill = self.revert = function() {
        self.disable();
        var i5 = _observers.indexOf(self);
        i5 >= 0 && _observers.splice(i5, 1);
        _normalizer === self && (_normalizer = 0);
      };
      _observers.push(self);
      isNormalizer && _isViewport(target) && (_normalizer = self);
      self.enable(event2);
    };
    _createClass(Observer3, [{
      key: "velocityX",
      get: function get() {
        return this._vx.getVelocity();
      }
    }, {
      key: "velocityY",
      get: function get() {
        return this._vy.getVelocity();
      }
    }]);
    return Observer3;
  }();
  Observer.version = "3.12.5";
  Observer.create = function(vars) {
    return new Observer(vars);
  };
  Observer.register = _initCore5;
  Observer.getAll = function() {
    return _observers.slice();
  };
  Observer.getById = function(id) {
    return _observers.filter(function(o7) {
      return o7.vars.id === id;
    })[0];
  };
  _getGSAP3() && gsap3.registerPlugin(Observer);

  // node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/ScrollTrigger.js
  var gsap4;
  var _coreInitted4;
  var _win4;
  var _doc4;
  var _docEl3;
  var _body3;
  var _root2;
  var _resizeDelay;
  var _toArray2;
  var _clamp4;
  var _time2;
  var _syncInterval;
  var _refreshing;
  var _pointerIsDown;
  var _transformProp2;
  var _i;
  var _prevWidth;
  var _prevHeight;
  var _autoRefresh;
  var _sort;
  var _suppressOverwrites2;
  var _ignoreResize;
  var _normalizer2;
  var _ignoreMobileResize;
  var _baseScreenHeight;
  var _baseScreenWidth;
  var _fixIOSBug;
  var _context3;
  var _scrollRestoration;
  var _div100vh;
  var _100vh;
  var _isReverted;
  var _clampingMax;
  var _limitCallbacks;
  var _startup2 = 1;
  var _getTime2 = Date.now;
  var _time1 = _getTime2();
  var _lastScrollTime = 0;
  var _enabled = 0;
  var _parseClamp = function _parseClamp2(value, type, self) {
    var clamp5 = _isString5(value) && (value.substr(0, 6) === "clamp(" || value.indexOf("max") > -1);
    self["_" + type + "Clamp"] = clamp5;
    return clamp5 ? value.substr(6, value.length - 7) : value;
  };
  var _keepClamp = function _keepClamp2(value, clamp5) {
    return clamp5 && (!_isString5(value) || value.substr(0, 6) !== "clamp(") ? "clamp(" + value + ")" : value;
  };
  var _rafBugFix = function _rafBugFix2() {
    return _enabled && requestAnimationFrame(_rafBugFix2);
  };
  var _pointerDownHandler = function _pointerDownHandler2() {
    return _pointerIsDown = 1;
  };
  var _pointerUpHandler = function _pointerUpHandler2() {
    return _pointerIsDown = 0;
  };
  var _passThrough3 = function _passThrough4(v2) {
    return v2;
  };
  var _round3 = function _round4(value) {
    return Math.round(value * 1e5) / 1e5 || 0;
  };
  var _windowExists7 = function _windowExists8() {
    return typeof window !== "undefined";
  };
  var _getGSAP5 = function _getGSAP6() {
    return gsap4 || _windowExists7() && (gsap4 = window.gsap) && gsap4.registerPlugin && gsap4;
  };
  var _isViewport3 = function _isViewport4(e8) {
    return !!~_root2.indexOf(e8);
  };
  var _getViewportDimension = function _getViewportDimension2(dimensionProperty) {
    return (dimensionProperty === "Height" ? _100vh : _win4["inner" + dimensionProperty]) || _docEl3["client" + dimensionProperty] || _body3["client" + dimensionProperty];
  };
  var _getBoundsFunc = function _getBoundsFunc2(element) {
    return _getProxyProp(element, "getBoundingClientRect") || (_isViewport3(element) ? function() {
      _winOffsets.width = _win4.innerWidth;
      _winOffsets.height = _100vh;
      return _winOffsets;
    } : function() {
      return _getBounds(element);
    });
  };
  var _getSizeFunc = function _getSizeFunc2(scroller, isViewport, _ref) {
    var d2 = _ref.d, d22 = _ref.d2, a4 = _ref.a;
    return (a4 = _getProxyProp(scroller, "getBoundingClientRect")) ? function() {
      return a4()[d2];
    } : function() {
      return (isViewport ? _getViewportDimension(d22) : scroller["client" + d22]) || 0;
    };
  };
  var _getOffsetsFunc = function _getOffsetsFunc2(element, isViewport) {
    return !isViewport || ~_proxies.indexOf(element) ? _getBoundsFunc(element) : function() {
      return _winOffsets;
    };
  };
  var _maxScroll = function _maxScroll2(element, _ref2) {
    var s5 = _ref2.s, d2 = _ref2.d2, d3 = _ref2.d, a4 = _ref2.a;
    return Math.max(0, (s5 = "scroll" + d2) && (a4 = _getProxyProp(element, s5)) ? a4() - _getBoundsFunc(element)()[d3] : _isViewport3(element) ? (_docEl3[s5] || _body3[s5]) - _getViewportDimension(d2) : element[s5] - element["offset" + d2]);
  };
  var _iterateAutoRefresh = function _iterateAutoRefresh2(func, events2) {
    for (var i5 = 0; i5 < _autoRefresh.length; i5 += 3) {
      (!events2 || ~events2.indexOf(_autoRefresh[i5 + 1])) && func(_autoRefresh[i5], _autoRefresh[i5 + 1], _autoRefresh[i5 + 2]);
    }
  };
  var _isString5 = function _isString6(value) {
    return typeof value === "string";
  };
  var _isFunction5 = function _isFunction6(value) {
    return typeof value === "function";
  };
  var _isNumber3 = function _isNumber4(value) {
    return typeof value === "number";
  };
  var _isObject3 = function _isObject4(value) {
    return typeof value === "object";
  };
  var _endAnimation = function _endAnimation2(animation, reversed, pause) {
    return animation && animation.progress(reversed ? 0 : 1) && pause && animation.pause();
  };
  var _callback3 = function _callback4(self, func) {
    if (self.enabled) {
      var result = self._ctx ? self._ctx.add(function() {
        return func(self);
      }) : func(self);
      result && result.totalTime && (self.callbackAnimation = result);
    }
  };
  var _abs = Math.abs;
  var _left = "left";
  var _top = "top";
  var _right = "right";
  var _bottom = "bottom";
  var _width = "width";
  var _height = "height";
  var _Right = "Right";
  var _Left = "Left";
  var _Top = "Top";
  var _Bottom = "Bottom";
  var _padding = "padding";
  var _margin = "margin";
  var _Width = "Width";
  var _Height = "Height";
  var _px = "px";
  var _getComputedStyle = function _getComputedStyle2(element) {
    return _win4.getComputedStyle(element);
  };
  var _makePositionable = function _makePositionable2(element) {
    var position = _getComputedStyle(element).position;
    element.style.position = position === "absolute" || position === "fixed" ? position : "relative";
  };
  var _setDefaults3 = function _setDefaults4(obj, defaults4) {
    for (var p2 in defaults4) {
      p2 in obj || (obj[p2] = defaults4[p2]);
    }
    return obj;
  };
  var _getBounds = function _getBounds2(element, withoutTransforms) {
    var tween = withoutTransforms && _getComputedStyle(element)[_transformProp2] !== "matrix(1, 0, 0, 1, 0, 0)" && gsap4.to(element, {
      x: 0,
      y: 0,
      xPercent: 0,
      yPercent: 0,
      rotation: 0,
      rotationX: 0,
      rotationY: 0,
      scale: 1,
      skewX: 0,
      skewY: 0
    }).progress(1), bounds = element.getBoundingClientRect();
    tween && tween.progress(0).kill();
    return bounds;
  };
  var _getSize = function _getSize2(element, _ref3) {
    var d2 = _ref3.d2;
    return element["offset" + d2] || element["client" + d2] || 0;
  };
  var _getLabelRatioArray = function _getLabelRatioArray2(timeline2) {
    var a4 = [], labels = timeline2.labels, duration = timeline2.duration(), p2;
    for (p2 in labels) {
      a4.push(labels[p2] / duration);
    }
    return a4;
  };
  var _getClosestLabel = function _getClosestLabel2(animation) {
    return function(value) {
      return gsap4.utils.snap(_getLabelRatioArray(animation), value);
    };
  };
  var _snapDirectional = function _snapDirectional2(snapIncrementOrArray) {
    var snap3 = gsap4.utils.snap(snapIncrementOrArray), a4 = Array.isArray(snapIncrementOrArray) && snapIncrementOrArray.slice(0).sort(function(a5, b2) {
      return a5 - b2;
    });
    return a4 ? function(value, direction, threshold) {
      if (threshold === void 0) {
        threshold = 1e-3;
      }
      var i5;
      if (!direction) {
        return snap3(value);
      }
      if (direction > 0) {
        value -= threshold;
        for (i5 = 0; i5 < a4.length; i5++) {
          if (a4[i5] >= value) {
            return a4[i5];
          }
        }
        return a4[i5 - 1];
      } else {
        i5 = a4.length;
        value += threshold;
        while (i5--) {
          if (a4[i5] <= value) {
            return a4[i5];
          }
        }
      }
      return a4[0];
    } : function(value, direction, threshold) {
      if (threshold === void 0) {
        threshold = 1e-3;
      }
      var snapped = snap3(value);
      return !direction || Math.abs(snapped - value) < threshold || snapped - value < 0 === direction < 0 ? snapped : snap3(direction < 0 ? value - snapIncrementOrArray : value + snapIncrementOrArray);
    };
  };
  var _getLabelAtDirection = function _getLabelAtDirection2(timeline2) {
    return function(value, st) {
      return _snapDirectional(_getLabelRatioArray(timeline2))(value, st.direction);
    };
  };
  var _multiListener = function _multiListener2(func, element, types, callback) {
    return types.split(",").forEach(function(type) {
      return func(element, type, callback);
    });
  };
  var _addListener3 = function _addListener4(element, type, func, nonPassive, capture) {
    return element.addEventListener(type, func, {
      passive: !nonPassive,
      capture: !!capture
    });
  };
  var _removeListener3 = function _removeListener4(element, type, func, capture) {
    return element.removeEventListener(type, func, !!capture);
  };
  var _wheelListener = function _wheelListener2(func, el, scrollFunc) {
    scrollFunc = scrollFunc && scrollFunc.wheelHandler;
    if (scrollFunc) {
      func(el, "wheel", scrollFunc);
      func(el, "touchmove", scrollFunc);
    }
  };
  var _markerDefaults = {
    startColor: "green",
    endColor: "red",
    indent: 0,
    fontSize: "16px",
    fontWeight: "normal"
  };
  var _defaults3 = {
    toggleActions: "play",
    anticipatePin: 0
  };
  var _keywords = {
    top: 0,
    left: 0,
    center: 0.5,
    bottom: 1,
    right: 1
  };
  var _offsetToPx = function _offsetToPx2(value, size2) {
    if (_isString5(value)) {
      var eqIndex = value.indexOf("="), relative = ~eqIndex ? +(value.charAt(eqIndex - 1) + 1) * parseFloat(value.substr(eqIndex + 1)) : 0;
      if (~eqIndex) {
        value.indexOf("%") > eqIndex && (relative *= size2 / 100);
        value = value.substr(0, eqIndex - 1);
      }
      value = relative + (value in _keywords ? _keywords[value] * size2 : ~value.indexOf("%") ? parseFloat(value) * size2 / 100 : parseFloat(value) || 0);
    }
    return value;
  };
  var _createMarker = function _createMarker2(type, name, container, direction, _ref4, offset2, matchWidthEl, containerAnimation) {
    var startColor = _ref4.startColor, endColor = _ref4.endColor, fontSize = _ref4.fontSize, indent = _ref4.indent, fontWeight = _ref4.fontWeight;
    var e8 = _doc4.createElement("div"), useFixedPosition = _isViewport3(container) || _getProxyProp(container, "pinType") === "fixed", isScroller = type.indexOf("scroller") !== -1, parent = useFixedPosition ? _body3 : container, isStart = type.indexOf("start") !== -1, color = isStart ? startColor : endColor, css = "border-color:" + color + ";font-size:" + fontSize + ";color:" + color + ";font-weight:" + fontWeight + ";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;";
    css += "position:" + ((isScroller || containerAnimation) && useFixedPosition ? "fixed;" : "absolute;");
    (isScroller || containerAnimation || !useFixedPosition) && (css += (direction === _vertical ? _right : _bottom) + ":" + (offset2 + parseFloat(indent)) + "px;");
    matchWidthEl && (css += "box-sizing:border-box;text-align:left;width:" + matchWidthEl.offsetWidth + "px;");
    e8._isStart = isStart;
    e8.setAttribute("class", "gsap-marker-" + type + (name ? " marker-" + name : ""));
    e8.style.cssText = css;
    e8.innerText = name || name === 0 ? type + "-" + name : type;
    parent.children[0] ? parent.insertBefore(e8, parent.children[0]) : parent.appendChild(e8);
    e8._offset = e8["offset" + direction.op.d2];
    _positionMarker(e8, 0, direction, isStart);
    return e8;
  };
  var _positionMarker = function _positionMarker2(marker, start, direction, flipped) {
    var vars = {
      display: "block"
    }, side = direction[flipped ? "os2" : "p2"], oppositeSide = direction[flipped ? "p2" : "os2"];
    marker._isFlipped = flipped;
    vars[direction.a + "Percent"] = flipped ? -100 : 0;
    vars[direction.a] = flipped ? "1px" : 0;
    vars["border" + side + _Width] = 1;
    vars["border" + oppositeSide + _Width] = 0;
    vars[direction.p] = start + "px";
    gsap4.set(marker, vars);
  };
  var _triggers = [];
  var _ids = {};
  var _rafID;
  var _sync = function _sync2() {
    return _getTime2() - _lastScrollTime > 34 && (_rafID || (_rafID = requestAnimationFrame(_updateAll)));
  };
  var _onScroll3 = function _onScroll4() {
    if (!_normalizer2 || !_normalizer2.isPressed || _normalizer2.startX > _body3.clientWidth) {
      _scrollers.cache++;
      if (_normalizer2) {
        _rafID || (_rafID = requestAnimationFrame(_updateAll));
      } else {
        _updateAll();
      }
      _lastScrollTime || _dispatch3("scrollStart");
      _lastScrollTime = _getTime2();
    }
  };
  var _setBaseDimensions = function _setBaseDimensions2() {
    _baseScreenWidth = _win4.innerWidth;
    _baseScreenHeight = _win4.innerHeight;
  };
  var _onResize = function _onResize2() {
    _scrollers.cache++;
    !_refreshing && !_ignoreResize && !_doc4.fullscreenElement && !_doc4.webkitFullscreenElement && (!_ignoreMobileResize || _baseScreenWidth !== _win4.innerWidth || Math.abs(_win4.innerHeight - _baseScreenHeight) > _win4.innerHeight * 0.25) && _resizeDelay.restart(true);
  };
  var _listeners2 = {};
  var _emptyArray2 = [];
  var _softRefresh = function _softRefresh2() {
    return _removeListener3(ScrollTrigger3, "scrollEnd", _softRefresh2) || _refreshAll(true);
  };
  var _dispatch3 = function _dispatch4(type) {
    return _listeners2[type] && _listeners2[type].map(function(f2) {
      return f2();
    }) || _emptyArray2;
  };
  var _savedStyles = [];
  var _revertRecorded = function _revertRecorded2(media) {
    for (var i5 = 0; i5 < _savedStyles.length; i5 += 5) {
      if (!media || _savedStyles[i5 + 4] && _savedStyles[i5 + 4].query === media) {
        _savedStyles[i5].style.cssText = _savedStyles[i5 + 1];
        _savedStyles[i5].getBBox && _savedStyles[i5].setAttribute("transform", _savedStyles[i5 + 2] || "");
        _savedStyles[i5 + 3].uncache = 1;
      }
    }
  };
  var _revertAll = function _revertAll2(kill2, media) {
    var trigger;
    for (_i = 0; _i < _triggers.length; _i++) {
      trigger = _triggers[_i];
      if (trigger && (!media || trigger._ctx === media)) {
        if (kill2) {
          trigger.kill(1);
        } else {
          trigger.revert(true, true);
        }
      }
    }
    _isReverted = true;
    media && _revertRecorded(media);
    media || _dispatch3("revert");
  };
  var _clearScrollMemory = function _clearScrollMemory2(scrollRestoration, force) {
    _scrollers.cache++;
    (force || !_refreshingAll) && _scrollers.forEach(function(obj) {
      return _isFunction5(obj) && obj.cacheID++ && (obj.rec = 0);
    });
    _isString5(scrollRestoration) && (_win4.history.scrollRestoration = _scrollRestoration = scrollRestoration);
  };
  var _refreshingAll;
  var _refreshID = 0;
  var _queueRefreshID;
  var _queueRefreshAll = function _queueRefreshAll2() {
    if (_queueRefreshID !== _refreshID) {
      var id = _queueRefreshID = _refreshID;
      requestAnimationFrame(function() {
        return id === _refreshID && _refreshAll(true);
      });
    }
  };
  var _refresh100vh = function _refresh100vh2() {
    _body3.appendChild(_div100vh);
    _100vh = !_normalizer2 && _div100vh.offsetHeight || _win4.innerHeight;
    _body3.removeChild(_div100vh);
  };
  var _hideAllMarkers = function _hideAllMarkers2(hide2) {
    return _toArray2(".gsap-marker-start, .gsap-marker-end, .gsap-marker-scroller-start, .gsap-marker-scroller-end").forEach(function(el) {
      return el.style.display = hide2 ? "none" : "block";
    });
  };
  var _refreshAll = function _refreshAll2(force, skipRevert) {
    if (_lastScrollTime && !force && !_isReverted) {
      _addListener3(ScrollTrigger3, "scrollEnd", _softRefresh);
      return;
    }
    _refresh100vh();
    _refreshingAll = ScrollTrigger3.isRefreshing = true;
    _scrollers.forEach(function(obj) {
      return _isFunction5(obj) && ++obj.cacheID && (obj.rec = obj());
    });
    var refreshInits = _dispatch3("refreshInit");
    _sort && ScrollTrigger3.sort();
    skipRevert || _revertAll();
    _scrollers.forEach(function(obj) {
      if (_isFunction5(obj)) {
        obj.smooth && (obj.target.style.scrollBehavior = "auto");
        obj(0);
      }
    });
    _triggers.slice(0).forEach(function(t6) {
      return t6.refresh();
    });
    _isReverted = false;
    _triggers.forEach(function(t6) {
      if (t6._subPinOffset && t6.pin) {
        var prop2 = t6.vars.horizontal ? "offsetWidth" : "offsetHeight", original = t6.pin[prop2];
        t6.revert(true, 1);
        t6.adjustPinSpacing(t6.pin[prop2] - original);
        t6.refresh();
      }
    });
    _clampingMax = 1;
    _hideAllMarkers(true);
    _triggers.forEach(function(t6) {
      var max2 = _maxScroll(t6.scroller, t6._dir), endClamp = t6.vars.end === "max" || t6._endClamp && t6.end > max2, startClamp = t6._startClamp && t6.start >= max2;
      (endClamp || startClamp) && t6.setPositions(startClamp ? max2 - 1 : t6.start, endClamp ? Math.max(startClamp ? max2 : t6.start + 1, max2) : t6.end, true);
    });
    _hideAllMarkers(false);
    _clampingMax = 0;
    refreshInits.forEach(function(result) {
      return result && result.render && result.render(-1);
    });
    _scrollers.forEach(function(obj) {
      if (_isFunction5(obj)) {
        obj.smooth && requestAnimationFrame(function() {
          return obj.target.style.scrollBehavior = "smooth";
        });
        obj.rec && obj(obj.rec);
      }
    });
    _clearScrollMemory(_scrollRestoration, 1);
    _resizeDelay.pause();
    _refreshID++;
    _refreshingAll = 2;
    _updateAll(2);
    _triggers.forEach(function(t6) {
      return _isFunction5(t6.vars.onRefresh) && t6.vars.onRefresh(t6);
    });
    _refreshingAll = ScrollTrigger3.isRefreshing = false;
    _dispatch3("refresh");
  };
  var _lastScroll = 0;
  var _direction = 1;
  var _primary;
  var _updateAll = function _updateAll2(force) {
    if (force === 2 || !_refreshingAll && !_isReverted) {
      ScrollTrigger3.isUpdating = true;
      _primary && _primary.update(0);
      var l6 = _triggers.length, time = _getTime2(), recordVelocity = time - _time1 >= 50, scroll = l6 && _triggers[0].scroll();
      _direction = _lastScroll > scroll ? -1 : 1;
      _refreshingAll || (_lastScroll = scroll);
      if (recordVelocity) {
        if (_lastScrollTime && !_pointerIsDown && time - _lastScrollTime > 200) {
          _lastScrollTime = 0;
          _dispatch3("scrollEnd");
        }
        _time2 = _time1;
        _time1 = time;
      }
      if (_direction < 0) {
        _i = l6;
        while (_i-- > 0) {
          _triggers[_i] && _triggers[_i].update(0, recordVelocity);
        }
        _direction = 1;
      } else {
        for (_i = 0; _i < l6; _i++) {
          _triggers[_i] && _triggers[_i].update(0, recordVelocity);
        }
      }
      ScrollTrigger3.isUpdating = false;
    }
    _rafID = 0;
  };
  var _propNamesToCopy = [_left, _top, _bottom, _right, _margin + _Bottom, _margin + _Right, _margin + _Top, _margin + _Left, "display", "flexShrink", "float", "zIndex", "gridColumnStart", "gridColumnEnd", "gridRowStart", "gridRowEnd", "gridArea", "justifySelf", "alignSelf", "placeSelf", "order"];
  var _stateProps = _propNamesToCopy.concat([_width, _height, "boxSizing", "max" + _Width, "max" + _Height, "position", _margin, _padding, _padding + _Top, _padding + _Right, _padding + _Bottom, _padding + _Left]);
  var _swapPinOut = function _swapPinOut2(pin, spacer, state) {
    _setState(state);
    var cache2 = pin._gsap;
    if (cache2.spacerIsNative) {
      _setState(cache2.spacerState);
    } else if (pin._gsap.swappedIn) {
      var parent = spacer.parentNode;
      if (parent) {
        parent.insertBefore(pin, spacer);
        parent.removeChild(spacer);
      }
    }
    pin._gsap.swappedIn = false;
  };
  var _swapPinIn = function _swapPinIn2(pin, spacer, cs, spacerState) {
    if (!pin._gsap.swappedIn) {
      var i5 = _propNamesToCopy.length, spacerStyle = spacer.style, pinStyle = pin.style, p2;
      while (i5--) {
        p2 = _propNamesToCopy[i5];
        spacerStyle[p2] = cs[p2];
      }
      spacerStyle.position = cs.position === "absolute" ? "absolute" : "relative";
      cs.display === "inline" && (spacerStyle.display = "inline-block");
      pinStyle[_bottom] = pinStyle[_right] = "auto";
      spacerStyle.flexBasis = cs.flexBasis || "auto";
      spacerStyle.overflow = "visible";
      spacerStyle.boxSizing = "border-box";
      spacerStyle[_width] = _getSize(pin, _horizontal) + _px;
      spacerStyle[_height] = _getSize(pin, _vertical) + _px;
      spacerStyle[_padding] = pinStyle[_margin] = pinStyle[_top] = pinStyle[_left] = "0";
      _setState(spacerState);
      pinStyle[_width] = pinStyle["max" + _Width] = cs[_width];
      pinStyle[_height] = pinStyle["max" + _Height] = cs[_height];
      pinStyle[_padding] = cs[_padding];
      if (pin.parentNode !== spacer) {
        pin.parentNode.insertBefore(spacer, pin);
        spacer.appendChild(pin);
      }
      pin._gsap.swappedIn = true;
    }
  };
  var _capsExp2 = /([A-Z])/g;
  var _setState = function _setState2(state) {
    if (state) {
      var style = state.t.style, l6 = state.length, i5 = 0, p2, value;
      (state.t._gsap || gsap4.core.getCache(state.t)).uncache = 1;
      for (; i5 < l6; i5 += 2) {
        value = state[i5 + 1];
        p2 = state[i5];
        if (value) {
          style[p2] = value;
        } else if (style[p2]) {
          style.removeProperty(p2.replace(_capsExp2, "-$1").toLowerCase());
        }
      }
    }
  };
  var _getState = function _getState2(element) {
    var l6 = _stateProps.length, style = element.style, state = [], i5 = 0;
    for (; i5 < l6; i5++) {
      state.push(_stateProps[i5], style[_stateProps[i5]]);
    }
    state.t = element;
    return state;
  };
  var _copyState = function _copyState2(state, override, omitOffsets) {
    var result = [], l6 = state.length, i5 = omitOffsets ? 8 : 0, p2;
    for (; i5 < l6; i5 += 2) {
      p2 = state[i5];
      result.push(p2, p2 in override ? override[p2] : state[i5 + 1]);
    }
    result.t = state.t;
    return result;
  };
  var _winOffsets = {
    left: 0,
    top: 0
  };
  var _parsePosition3 = function _parsePosition4(value, trigger, scrollerSize, direction, scroll, marker, markerScroller, self, scrollerBounds, borderWidth, useFixedPosition, scrollerMax, containerAnimation, clampZeroProp) {
    _isFunction5(value) && (value = value(self));
    if (_isString5(value) && value.substr(0, 3) === "max") {
      value = scrollerMax + (value.charAt(4) === "=" ? _offsetToPx("0" + value.substr(3), scrollerSize) : 0);
    }
    var time = containerAnimation ? containerAnimation.time() : 0, p1, p2, element;
    containerAnimation && containerAnimation.seek(0);
    isNaN(value) || (value = +value);
    if (!_isNumber3(value)) {
      _isFunction5(trigger) && (trigger = trigger(self));
      var offsets = (value || "0").split(" "), bounds, localOffset, globalOffset, display;
      element = _getTarget(trigger, self) || _body3;
      bounds = _getBounds(element) || {};
      if ((!bounds || !bounds.left && !bounds.top) && _getComputedStyle(element).display === "none") {
        display = element.style.display;
        element.style.display = "block";
        bounds = _getBounds(element);
        display ? element.style.display = display : element.style.removeProperty("display");
      }
      localOffset = _offsetToPx(offsets[0], bounds[direction.d]);
      globalOffset = _offsetToPx(offsets[1] || "0", scrollerSize);
      value = bounds[direction.p] - scrollerBounds[direction.p] - borderWidth + localOffset + scroll - globalOffset;
      markerScroller && _positionMarker(markerScroller, globalOffset, direction, scrollerSize - globalOffset < 20 || markerScroller._isStart && globalOffset > 20);
      scrollerSize -= scrollerSize - globalOffset;
    } else {
      containerAnimation && (value = gsap4.utils.mapRange(containerAnimation.scrollTrigger.start, containerAnimation.scrollTrigger.end, 0, scrollerMax, value));
      markerScroller && _positionMarker(markerScroller, scrollerSize, direction, true);
    }
    if (clampZeroProp) {
      self[clampZeroProp] = value || -1e-3;
      value < 0 && (value = 0);
    }
    if (marker) {
      var position = value + scrollerSize, isStart = marker._isStart;
      p1 = "scroll" + direction.d2;
      _positionMarker(marker, position, direction, isStart && position > 20 || !isStart && (useFixedPosition ? Math.max(_body3[p1], _docEl3[p1]) : marker.parentNode[p1]) <= position + 1);
      if (useFixedPosition) {
        scrollerBounds = _getBounds(markerScroller);
        useFixedPosition && (marker.style[direction.op.p] = scrollerBounds[direction.op.p] - direction.op.m - marker._offset + _px);
      }
    }
    if (containerAnimation && element) {
      p1 = _getBounds(element);
      containerAnimation.seek(scrollerMax);
      p2 = _getBounds(element);
      containerAnimation._caScrollDist = p1[direction.p] - p2[direction.p];
      value = value / containerAnimation._caScrollDist * scrollerMax;
    }
    containerAnimation && containerAnimation.seek(time);
    return containerAnimation ? value : Math.round(value);
  };
  var _prefixExp = /(webkit|moz|length|cssText|inset)/i;
  var _reparent = function _reparent2(element, parent, top, left) {
    if (element.parentNode !== parent) {
      var style = element.style, p2, cs;
      if (parent === _body3) {
        element._stOrig = style.cssText;
        cs = _getComputedStyle(element);
        for (p2 in cs) {
          if (!+p2 && !_prefixExp.test(p2) && cs[p2] && typeof style[p2] === "string" && p2 !== "0") {
            style[p2] = cs[p2];
          }
        }
        style.top = top;
        style.left = left;
      } else {
        style.cssText = element._stOrig;
      }
      gsap4.core.getCache(element).uncache = 1;
      parent.appendChild(element);
    }
  };
  var _interruptionTracker = function _interruptionTracker2(getValueFunc, initialValue, onInterrupt) {
    var last1 = initialValue, last2 = last1;
    return function(value) {
      var current = Math.round(getValueFunc());
      if (current !== last1 && current !== last2 && Math.abs(current - last1) > 3 && Math.abs(current - last2) > 3) {
        value = current;
        onInterrupt && onInterrupt();
      }
      last2 = last1;
      last1 = value;
      return value;
    };
  };
  var _shiftMarker = function _shiftMarker2(marker, direction, value) {
    var vars = {};
    vars[direction.p] = "+=" + value;
    gsap4.set(marker, vars);
  };
  var _getTweenCreator = function _getTweenCreator2(scroller, direction) {
    var getScroll = _getScrollFunc(scroller, direction), prop2 = "_scroll" + direction.p2, getTween = function getTween2(scrollTo, vars, initialValue, change1, change2) {
      var tween = getTween2.tween, onComplete = vars.onComplete, modifiers = {};
      initialValue = initialValue || getScroll();
      var checkForInterruption = _interruptionTracker(getScroll, initialValue, function() {
        tween.kill();
        getTween2.tween = 0;
      });
      change2 = change1 && change2 || 0;
      change1 = change1 || scrollTo - initialValue;
      tween && tween.kill();
      vars[prop2] = scrollTo;
      vars.inherit = false;
      vars.modifiers = modifiers;
      modifiers[prop2] = function() {
        return checkForInterruption(initialValue + change1 * tween.ratio + change2 * tween.ratio * tween.ratio);
      };
      vars.onUpdate = function() {
        _scrollers.cache++;
        getTween2.tween && _updateAll();
      };
      vars.onComplete = function() {
        getTween2.tween = 0;
        onComplete && onComplete.call(tween);
      };
      tween = getTween2.tween = gsap4.to(scroller, vars);
      return tween;
    };
    scroller[prop2] = getScroll;
    getScroll.wheelHandler = function() {
      return getTween.tween && getTween.tween.kill() && (getTween.tween = 0);
    };
    _addListener3(scroller, "wheel", getScroll.wheelHandler);
    ScrollTrigger3.isTouch && _addListener3(scroller, "touchmove", getScroll.wheelHandler);
    return getTween;
  };
  var ScrollTrigger3 = /* @__PURE__ */ function() {
    function ScrollTrigger4(vars, animation) {
      _coreInitted4 || ScrollTrigger4.register(gsap4) || console.warn("Please gsap.registerPlugin(ScrollTrigger)");
      _context3(this);
      this.init(vars, animation);
    }
    var _proto = ScrollTrigger4.prototype;
    _proto.init = function init5(vars, animation) {
      this.progress = this.start = 0;
      this.vars && this.kill(true, true);
      if (!_enabled) {
        this.update = this.refresh = this.kill = _passThrough3;
        return;
      }
      vars = _setDefaults3(_isString5(vars) || _isNumber3(vars) || vars.nodeType ? {
        trigger: vars
      } : vars, _defaults3);
      var _vars = vars, onUpdate = _vars.onUpdate, toggleClass2 = _vars.toggleClass, id = _vars.id, onToggle = _vars.onToggle, onRefresh = _vars.onRefresh, scrub = _vars.scrub, trigger = _vars.trigger, pin = _vars.pin, pinSpacing = _vars.pinSpacing, invalidateOnRefresh = _vars.invalidateOnRefresh, anticipatePin = _vars.anticipatePin, onScrubComplete = _vars.onScrubComplete, onSnapComplete = _vars.onSnapComplete, once = _vars.once, snap3 = _vars.snap, pinReparent = _vars.pinReparent, pinSpacer = _vars.pinSpacer, containerAnimation = _vars.containerAnimation, fastScrollEnd = _vars.fastScrollEnd, preventOverlaps = _vars.preventOverlaps, direction = vars.horizontal || vars.containerAnimation && vars.horizontal !== false ? _horizontal : _vertical, isToggle = !scrub && scrub !== 0, scroller = _getTarget(vars.scroller || _win4), scrollerCache = gsap4.core.getCache(scroller), isViewport = _isViewport3(scroller), useFixedPosition = ("pinType" in vars ? vars.pinType : _getProxyProp(scroller, "pinType") || isViewport && "fixed") === "fixed", callbacks = [vars.onEnter, vars.onLeave, vars.onEnterBack, vars.onLeaveBack], toggleActions = isToggle && vars.toggleActions.split(" "), markers = "markers" in vars ? vars.markers : _defaults3.markers, borderWidth = isViewport ? 0 : parseFloat(_getComputedStyle(scroller)["border" + direction.p2 + _Width]) || 0, self = this, onRefreshInit = vars.onRefreshInit && function() {
        return vars.onRefreshInit(self);
      }, getScrollerSize = _getSizeFunc(scroller, isViewport, direction), getScrollerOffsets = _getOffsetsFunc(scroller, isViewport), lastSnap = 0, lastRefresh = 0, prevProgress = 0, scrollFunc = _getScrollFunc(scroller, direction), tweenTo, pinCache, snapFunc, scroll1, scroll2, start, end, markerStart, markerEnd, markerStartTrigger, markerEndTrigger, markerVars, executingOnRefresh, change, pinOriginalState, pinActiveState, pinState, spacer, offset2, pinGetter, pinSetter, pinStart, pinChange, spacingStart, spacerState, markerStartSetter, pinMoves, markerEndSetter, cs, snap1, snap22, scrubTween, scrubSmooth, snapDurClamp, snapDelayedCall, prevScroll, prevAnimProgress, caMarkerSetter, customRevertReturn;
      self._startClamp = self._endClamp = false;
      self._dir = direction;
      anticipatePin *= 45;
      self.scroller = scroller;
      self.scroll = containerAnimation ? containerAnimation.time.bind(containerAnimation) : scrollFunc;
      scroll1 = scrollFunc();
      self.vars = vars;
      animation = animation || vars.animation;
      if ("refreshPriority" in vars) {
        _sort = 1;
        vars.refreshPriority === -9999 && (_primary = self);
      }
      scrollerCache.tweenScroll = scrollerCache.tweenScroll || {
        top: _getTweenCreator(scroller, _vertical),
        left: _getTweenCreator(scroller, _horizontal)
      };
      self.tweenTo = tweenTo = scrollerCache.tweenScroll[direction.p];
      self.scrubDuration = function(value) {
        scrubSmooth = _isNumber3(value) && value;
        if (!scrubSmooth) {
          scrubTween && scrubTween.progress(1).kill();
          scrubTween = 0;
        } else {
          scrubTween ? scrubTween.duration(value) : scrubTween = gsap4.to(animation, {
            ease: "expo",
            totalProgress: "+=0",
            inherit: false,
            duration: scrubSmooth,
            paused: true,
            onComplete: function onComplete() {
              return onScrubComplete && onScrubComplete(self);
            }
          });
        }
      };
      if (animation) {
        animation.vars.lazy = false;
        animation._initted && !self.isReverted || animation.vars.immediateRender !== false && vars.immediateRender !== false && animation.duration() && animation.render(0, true, true);
        self.animation = animation.pause();
        animation.scrollTrigger = self;
        self.scrubDuration(scrub);
        snap1 = 0;
        id || (id = animation.vars.id);
      }
      if (snap3) {
        if (!_isObject3(snap3) || snap3.push) {
          snap3 = {
            snapTo: snap3
          };
        }
        "scrollBehavior" in _body3.style && gsap4.set(isViewport ? [_body3, _docEl3] : scroller, {
          scrollBehavior: "auto"
        });
        _scrollers.forEach(function(o7) {
          return _isFunction5(o7) && o7.target === (isViewport ? _doc4.scrollingElement || _docEl3 : scroller) && (o7.smooth = false);
        });
        snapFunc = _isFunction5(snap3.snapTo) ? snap3.snapTo : snap3.snapTo === "labels" ? _getClosestLabel(animation) : snap3.snapTo === "labelsDirectional" ? _getLabelAtDirection(animation) : snap3.directional !== false ? function(value, st) {
          return _snapDirectional(snap3.snapTo)(value, _getTime2() - lastRefresh < 500 ? 0 : st.direction);
        } : gsap4.utils.snap(snap3.snapTo);
        snapDurClamp = snap3.duration || {
          min: 0.1,
          max: 2
        };
        snapDurClamp = _isObject3(snapDurClamp) ? _clamp4(snapDurClamp.min, snapDurClamp.max) : _clamp4(snapDurClamp, snapDurClamp);
        snapDelayedCall = gsap4.delayedCall(snap3.delay || scrubSmooth / 2 || 0.1, function() {
          var scroll = scrollFunc(), refreshedRecently = _getTime2() - lastRefresh < 500, tween = tweenTo.tween;
          if ((refreshedRecently || Math.abs(self.getVelocity()) < 10) && !tween && !_pointerIsDown && lastSnap !== scroll) {
            var progress = (scroll - start) / change, totalProgress = animation && !isToggle ? animation.totalProgress() : progress, velocity = refreshedRecently ? 0 : (totalProgress - snap22) / (_getTime2() - _time2) * 1e3 || 0, change1 = gsap4.utils.clamp(-progress, 1 - progress, _abs(velocity / 2) * velocity / 0.185), naturalEnd = progress + (snap3.inertia === false ? 0 : change1), endValue, endScroll, _snap = snap3, onStart = _snap.onStart, _onInterrupt = _snap.onInterrupt, _onComplete = _snap.onComplete;
            endValue = snapFunc(naturalEnd, self);
            _isNumber3(endValue) || (endValue = naturalEnd);
            endScroll = Math.round(start + endValue * change);
            if (scroll <= end && scroll >= start && endScroll !== scroll) {
              if (tween && !tween._initted && tween.data <= _abs(endScroll - scroll)) {
                return;
              }
              if (snap3.inertia === false) {
                change1 = endValue - progress;
              }
              tweenTo(endScroll, {
                duration: snapDurClamp(_abs(Math.max(_abs(naturalEnd - totalProgress), _abs(endValue - totalProgress)) * 0.185 / velocity / 0.05 || 0)),
                ease: snap3.ease || "power3",
                data: _abs(endScroll - scroll),
                // record the distance so that if another snap tween occurs (conflict) we can prioritize the closest snap.
                onInterrupt: function onInterrupt() {
                  return snapDelayedCall.restart(true) && _onInterrupt && _onInterrupt(self);
                },
                onComplete: function onComplete() {
                  self.update();
                  lastSnap = scrollFunc();
                  if (animation) {
                    scrubTween ? scrubTween.resetTo("totalProgress", endValue, animation._tTime / animation._tDur) : animation.progress(endValue);
                  }
                  snap1 = snap22 = animation && !isToggle ? animation.totalProgress() : self.progress;
                  onSnapComplete && onSnapComplete(self);
                  _onComplete && _onComplete(self);
                }
              }, scroll, change1 * change, endScroll - scroll - change1 * change);
              onStart && onStart(self, tweenTo.tween);
            }
          } else if (self.isActive && lastSnap !== scroll) {
            snapDelayedCall.restart(true);
          }
        }).pause();
      }
      id && (_ids[id] = self);
      trigger = self.trigger = _getTarget(trigger || pin !== true && pin);
      customRevertReturn = trigger && trigger._gsap && trigger._gsap.stRevert;
      customRevertReturn && (customRevertReturn = customRevertReturn(self));
      pin = pin === true ? trigger : _getTarget(pin);
      _isString5(toggleClass2) && (toggleClass2 = {
        targets: trigger,
        className: toggleClass2
      });
      if (pin) {
        pinSpacing === false || pinSpacing === _margin || (pinSpacing = !pinSpacing && pin.parentNode && pin.parentNode.style && _getComputedStyle(pin.parentNode).display === "flex" ? false : _padding);
        self.pin = pin;
        pinCache = gsap4.core.getCache(pin);
        if (!pinCache.spacer) {
          if (pinSpacer) {
            pinSpacer = _getTarget(pinSpacer);
            pinSpacer && !pinSpacer.nodeType && (pinSpacer = pinSpacer.current || pinSpacer.nativeElement);
            pinCache.spacerIsNative = !!pinSpacer;
            pinSpacer && (pinCache.spacerState = _getState(pinSpacer));
          }
          pinCache.spacer = spacer = pinSpacer || _doc4.createElement("div");
          spacer.classList.add("pin-spacer");
          id && spacer.classList.add("pin-spacer-" + id);
          pinCache.pinState = pinOriginalState = _getState(pin);
        } else {
          pinOriginalState = pinCache.pinState;
        }
        vars.force3D !== false && gsap4.set(pin, {
          force3D: true
        });
        self.spacer = spacer = pinCache.spacer;
        cs = _getComputedStyle(pin);
        spacingStart = cs[pinSpacing + direction.os2];
        pinGetter = gsap4.getProperty(pin);
        pinSetter = gsap4.quickSetter(pin, direction.a, _px);
        _swapPinIn(pin, spacer, cs);
        pinState = _getState(pin);
      }
      if (markers) {
        markerVars = _isObject3(markers) ? _setDefaults3(markers, _markerDefaults) : _markerDefaults;
        markerStartTrigger = _createMarker("scroller-start", id, scroller, direction, markerVars, 0);
        markerEndTrigger = _createMarker("scroller-end", id, scroller, direction, markerVars, 0, markerStartTrigger);
        offset2 = markerStartTrigger["offset" + direction.op.d2];
        var content = _getTarget(_getProxyProp(scroller, "content") || scroller);
        markerStart = this.markerStart = _createMarker("start", id, content, direction, markerVars, offset2, 0, containerAnimation);
        markerEnd = this.markerEnd = _createMarker("end", id, content, direction, markerVars, offset2, 0, containerAnimation);
        containerAnimation && (caMarkerSetter = gsap4.quickSetter([markerStart, markerEnd], direction.a, _px));
        if (!useFixedPosition && !(_proxies.length && _getProxyProp(scroller, "fixedMarkers") === true)) {
          _makePositionable(isViewport ? _body3 : scroller);
          gsap4.set([markerStartTrigger, markerEndTrigger], {
            force3D: true
          });
          markerStartSetter = gsap4.quickSetter(markerStartTrigger, direction.a, _px);
          markerEndSetter = gsap4.quickSetter(markerEndTrigger, direction.a, _px);
        }
      }
      if (containerAnimation) {
        var oldOnUpdate = containerAnimation.vars.onUpdate, oldParams = containerAnimation.vars.onUpdateParams;
        containerAnimation.eventCallback("onUpdate", function() {
          self.update(0, 0, 1);
          oldOnUpdate && oldOnUpdate.apply(containerAnimation, oldParams || []);
        });
      }
      self.previous = function() {
        return _triggers[_triggers.indexOf(self) - 1];
      };
      self.next = function() {
        return _triggers[_triggers.indexOf(self) + 1];
      };
      self.revert = function(revert, temp) {
        if (!temp) {
          return self.kill(true);
        }
        var r5 = revert !== false || !self.enabled, prevRefreshing = _refreshing;
        if (r5 !== self.isReverted) {
          if (r5) {
            prevScroll = Math.max(scrollFunc(), self.scroll.rec || 0);
            prevProgress = self.progress;
            prevAnimProgress = animation && animation.progress();
          }
          markerStart && [markerStart, markerEnd, markerStartTrigger, markerEndTrigger].forEach(function(m2) {
            return m2.style.display = r5 ? "none" : "block";
          });
          if (r5) {
            _refreshing = self;
            self.update(r5);
          }
          if (pin && (!pinReparent || !self.isActive)) {
            if (r5) {
              _swapPinOut(pin, spacer, pinOriginalState);
            } else {
              _swapPinIn(pin, spacer, _getComputedStyle(pin), spacerState);
            }
          }
          r5 || self.update(r5);
          _refreshing = prevRefreshing;
          self.isReverted = r5;
        }
      };
      self.refresh = function(soft, force, position, pinOffset) {
        if ((_refreshing || !self.enabled) && !force) {
          return;
        }
        if (pin && soft && _lastScrollTime) {
          _addListener3(ScrollTrigger4, "scrollEnd", _softRefresh);
          return;
        }
        !_refreshingAll && onRefreshInit && onRefreshInit(self);
        _refreshing = self;
        if (tweenTo.tween && !position) {
          tweenTo.tween.kill();
          tweenTo.tween = 0;
        }
        scrubTween && scrubTween.pause();
        invalidateOnRefresh && animation && animation.revert({
          kill: false
        }).invalidate();
        self.isReverted || self.revert(true, true);
        self._subPinOffset = false;
        var size2 = getScrollerSize(), scrollerBounds = getScrollerOffsets(), max2 = containerAnimation ? containerAnimation.duration() : _maxScroll(scroller, direction), isFirstRefresh = change <= 0.01, offset3 = 0, otherPinOffset = pinOffset || 0, parsedEnd = _isObject3(position) ? position.end : vars.end, parsedEndTrigger = vars.endTrigger || trigger, parsedStart = _isObject3(position) ? position.start : vars.start || (vars.start === 0 || !trigger ? 0 : pin ? "0 0" : "0 100%"), pinnedContainer = self.pinnedContainer = vars.pinnedContainer && _getTarget(vars.pinnedContainer, self), triggerIndex = trigger && Math.max(0, _triggers.indexOf(self)) || 0, i5 = triggerIndex, cs2, bounds, scroll, isVertical, override, curTrigger, curPin, oppositeScroll, initted, revertedPins, forcedOverflow, markerStartOffset, markerEndOffset;
        if (markers && _isObject3(position)) {
          markerStartOffset = gsap4.getProperty(markerStartTrigger, direction.p);
          markerEndOffset = gsap4.getProperty(markerEndTrigger, direction.p);
        }
        while (i5--) {
          curTrigger = _triggers[i5];
          curTrigger.end || curTrigger.refresh(0, 1) || (_refreshing = self);
          curPin = curTrigger.pin;
          if (curPin && (curPin === trigger || curPin === pin || curPin === pinnedContainer) && !curTrigger.isReverted) {
            revertedPins || (revertedPins = []);
            revertedPins.unshift(curTrigger);
            curTrigger.revert(true, true);
          }
          if (curTrigger !== _triggers[i5]) {
            triggerIndex--;
            i5--;
          }
        }
        _isFunction5(parsedStart) && (parsedStart = parsedStart(self));
        parsedStart = _parseClamp(parsedStart, "start", self);
        start = _parsePosition3(parsedStart, trigger, size2, direction, scrollFunc(), markerStart, markerStartTrigger, self, scrollerBounds, borderWidth, useFixedPosition, max2, containerAnimation, self._startClamp && "_startClamp") || (pin ? -1e-3 : 0);
        _isFunction5(parsedEnd) && (parsedEnd = parsedEnd(self));
        if (_isString5(parsedEnd) && !parsedEnd.indexOf("+=")) {
          if (~parsedEnd.indexOf(" ")) {
            parsedEnd = (_isString5(parsedStart) ? parsedStart.split(" ")[0] : "") + parsedEnd;
          } else {
            offset3 = _offsetToPx(parsedEnd.substr(2), size2);
            parsedEnd = _isString5(parsedStart) ? parsedStart : (containerAnimation ? gsap4.utils.mapRange(0, containerAnimation.duration(), containerAnimation.scrollTrigger.start, containerAnimation.scrollTrigger.end, start) : start) + offset3;
            parsedEndTrigger = trigger;
          }
        }
        parsedEnd = _parseClamp(parsedEnd, "end", self);
        end = Math.max(start, _parsePosition3(parsedEnd || (parsedEndTrigger ? "100% 0" : max2), parsedEndTrigger, size2, direction, scrollFunc() + offset3, markerEnd, markerEndTrigger, self, scrollerBounds, borderWidth, useFixedPosition, max2, containerAnimation, self._endClamp && "_endClamp")) || -1e-3;
        offset3 = 0;
        i5 = triggerIndex;
        while (i5--) {
          curTrigger = _triggers[i5];
          curPin = curTrigger.pin;
          if (curPin && curTrigger.start - curTrigger._pinPush <= start && !containerAnimation && curTrigger.end > 0) {
            cs2 = curTrigger.end - (self._startClamp ? Math.max(0, curTrigger.start) : curTrigger.start);
            if ((curPin === trigger && curTrigger.start - curTrigger._pinPush < start || curPin === pinnedContainer) && isNaN(parsedStart)) {
              offset3 += cs2 * (1 - curTrigger.progress);
            }
            curPin === pin && (otherPinOffset += cs2);
          }
        }
        start += offset3;
        end += offset3;
        self._startClamp && (self._startClamp += offset3);
        if (self._endClamp && !_refreshingAll) {
          self._endClamp = end || -1e-3;
          end = Math.min(end, _maxScroll(scroller, direction));
        }
        change = end - start || (start -= 0.01) && 1e-3;
        if (isFirstRefresh) {
          prevProgress = gsap4.utils.clamp(0, 1, gsap4.utils.normalize(start, end, prevScroll));
        }
        self._pinPush = otherPinOffset;
        if (markerStart && offset3) {
          cs2 = {};
          cs2[direction.a] = "+=" + offset3;
          pinnedContainer && (cs2[direction.p] = "-=" + scrollFunc());
          gsap4.set([markerStart, markerEnd], cs2);
        }
        if (pin && !(_clampingMax && self.end >= _maxScroll(scroller, direction))) {
          cs2 = _getComputedStyle(pin);
          isVertical = direction === _vertical;
          scroll = scrollFunc();
          pinStart = parseFloat(pinGetter(direction.a)) + otherPinOffset;
          if (!max2 && end > 1) {
            forcedOverflow = (isViewport ? _doc4.scrollingElement || _docEl3 : scroller).style;
            forcedOverflow = {
              style: forcedOverflow,
              value: forcedOverflow["overflow" + direction.a.toUpperCase()]
            };
            if (isViewport && _getComputedStyle(_body3)["overflow" + direction.a.toUpperCase()] !== "scroll") {
              forcedOverflow.style["overflow" + direction.a.toUpperCase()] = "scroll";
            }
          }
          _swapPinIn(pin, spacer, cs2);
          pinState = _getState(pin);
          bounds = _getBounds(pin, true);
          oppositeScroll = useFixedPosition && _getScrollFunc(scroller, isVertical ? _horizontal : _vertical)();
          if (pinSpacing) {
            spacerState = [pinSpacing + direction.os2, change + otherPinOffset + _px];
            spacerState.t = spacer;
            i5 = pinSpacing === _padding ? _getSize(pin, direction) + change + otherPinOffset : 0;
            if (i5) {
              spacerState.push(direction.d, i5 + _px);
              spacer.style.flexBasis !== "auto" && (spacer.style.flexBasis = i5 + _px);
            }
            _setState(spacerState);
            if (pinnedContainer) {
              _triggers.forEach(function(t6) {
                if (t6.pin === pinnedContainer && t6.vars.pinSpacing !== false) {
                  t6._subPinOffset = true;
                }
              });
            }
            useFixedPosition && scrollFunc(prevScroll);
          } else {
            i5 = _getSize(pin, direction);
            i5 && spacer.style.flexBasis !== "auto" && (spacer.style.flexBasis = i5 + _px);
          }
          if (useFixedPosition) {
            override = {
              top: bounds.top + (isVertical ? scroll - start : oppositeScroll) + _px,
              left: bounds.left + (isVertical ? oppositeScroll : scroll - start) + _px,
              boxSizing: "border-box",
              position: "fixed"
            };
            override[_width] = override["max" + _Width] = Math.ceil(bounds.width) + _px;
            override[_height] = override["max" + _Height] = Math.ceil(bounds.height) + _px;
            override[_margin] = override[_margin + _Top] = override[_margin + _Right] = override[_margin + _Bottom] = override[_margin + _Left] = "0";
            override[_padding] = cs2[_padding];
            override[_padding + _Top] = cs2[_padding + _Top];
            override[_padding + _Right] = cs2[_padding + _Right];
            override[_padding + _Bottom] = cs2[_padding + _Bottom];
            override[_padding + _Left] = cs2[_padding + _Left];
            pinActiveState = _copyState(pinOriginalState, override, pinReparent);
            _refreshingAll && scrollFunc(0);
          }
          if (animation) {
            initted = animation._initted;
            _suppressOverwrites2(1);
            animation.render(animation.duration(), true, true);
            pinChange = pinGetter(direction.a) - pinStart + change + otherPinOffset;
            pinMoves = Math.abs(change - pinChange) > 1;
            useFixedPosition && pinMoves && pinActiveState.splice(pinActiveState.length - 2, 2);
            animation.render(0, true, true);
            initted || animation.invalidate(true);
            animation.parent || animation.totalTime(animation.totalTime());
            _suppressOverwrites2(0);
          } else {
            pinChange = change;
          }
          forcedOverflow && (forcedOverflow.value ? forcedOverflow.style["overflow" + direction.a.toUpperCase()] = forcedOverflow.value : forcedOverflow.style.removeProperty("overflow-" + direction.a));
        } else if (trigger && scrollFunc() && !containerAnimation) {
          bounds = trigger.parentNode;
          while (bounds && bounds !== _body3) {
            if (bounds._pinOffset) {
              start -= bounds._pinOffset;
              end -= bounds._pinOffset;
            }
            bounds = bounds.parentNode;
          }
        }
        revertedPins && revertedPins.forEach(function(t6) {
          return t6.revert(false, true);
        });
        self.start = start;
        self.end = end;
        scroll1 = scroll2 = _refreshingAll ? prevScroll : scrollFunc();
        if (!containerAnimation && !_refreshingAll) {
          scroll1 < prevScroll && scrollFunc(prevScroll);
          self.scroll.rec = 0;
        }
        self.revert(false, true);
        lastRefresh = _getTime2();
        if (snapDelayedCall) {
          lastSnap = -1;
          snapDelayedCall.restart(true);
        }
        _refreshing = 0;
        animation && isToggle && (animation._initted || prevAnimProgress) && animation.progress() !== prevAnimProgress && animation.progress(prevAnimProgress || 0, true).render(animation.time(), true, true);
        if (isFirstRefresh || prevProgress !== self.progress || containerAnimation || invalidateOnRefresh) {
          animation && !isToggle && animation.totalProgress(containerAnimation && start < -1e-3 && !prevProgress ? gsap4.utils.normalize(start, end, 0) : prevProgress, true);
          self.progress = isFirstRefresh || (scroll1 - start) / change === prevProgress ? 0 : prevProgress;
        }
        pin && pinSpacing && (spacer._pinOffset = Math.round(self.progress * pinChange));
        scrubTween && scrubTween.invalidate();
        if (!isNaN(markerStartOffset)) {
          markerStartOffset -= gsap4.getProperty(markerStartTrigger, direction.p);
          markerEndOffset -= gsap4.getProperty(markerEndTrigger, direction.p);
          _shiftMarker(markerStartTrigger, direction, markerStartOffset);
          _shiftMarker(markerStart, direction, markerStartOffset - (pinOffset || 0));
          _shiftMarker(markerEndTrigger, direction, markerEndOffset);
          _shiftMarker(markerEnd, direction, markerEndOffset - (pinOffset || 0));
        }
        isFirstRefresh && !_refreshingAll && self.update();
        if (onRefresh && !_refreshingAll && !executingOnRefresh) {
          executingOnRefresh = true;
          onRefresh(self);
          executingOnRefresh = false;
        }
      };
      self.getVelocity = function() {
        return (scrollFunc() - scroll2) / (_getTime2() - _time2) * 1e3 || 0;
      };
      self.endAnimation = function() {
        _endAnimation(self.callbackAnimation);
        if (animation) {
          scrubTween ? scrubTween.progress(1) : !animation.paused() ? _endAnimation(animation, animation.reversed()) : isToggle || _endAnimation(animation, self.direction < 0, 1);
        }
      };
      self.labelToScroll = function(label) {
        return animation && animation.labels && (start || self.refresh() || start) + animation.labels[label] / animation.duration() * change || 0;
      };
      self.getTrailing = function(name) {
        var i5 = _triggers.indexOf(self), a4 = self.direction > 0 ? _triggers.slice(0, i5).reverse() : _triggers.slice(i5 + 1);
        return (_isString5(name) ? a4.filter(function(t6) {
          return t6.vars.preventOverlaps === name;
        }) : a4).filter(function(t6) {
          return self.direction > 0 ? t6.end <= start : t6.start >= end;
        });
      };
      self.update = function(reset, recordVelocity, forceFake) {
        if (containerAnimation && !forceFake && !reset) {
          return;
        }
        var scroll = _refreshingAll === true ? prevScroll : self.scroll(), p2 = reset ? 0 : (scroll - start) / change, clipped = p2 < 0 ? 0 : p2 > 1 ? 1 : p2 || 0, prevProgress2 = self.progress, isActive, wasActive, toggleState, action, stateChanged, toggled, isAtMax, isTakingAction;
        if (recordVelocity) {
          scroll2 = scroll1;
          scroll1 = containerAnimation ? scrollFunc() : scroll;
          if (snap3) {
            snap22 = snap1;
            snap1 = animation && !isToggle ? animation.totalProgress() : clipped;
          }
        }
        if (anticipatePin && pin && !_refreshing && !_startup2 && _lastScrollTime) {
          if (!clipped && start < scroll + (scroll - scroll2) / (_getTime2() - _time2) * anticipatePin) {
            clipped = 1e-4;
          } else if (clipped === 1 && end > scroll + (scroll - scroll2) / (_getTime2() - _time2) * anticipatePin) {
            clipped = 0.9999;
          }
        }
        if (clipped !== prevProgress2 && self.enabled) {
          isActive = self.isActive = !!clipped && clipped < 1;
          wasActive = !!prevProgress2 && prevProgress2 < 1;
          toggled = isActive !== wasActive;
          stateChanged = toggled || !!clipped !== !!prevProgress2;
          self.direction = clipped > prevProgress2 ? 1 : -1;
          self.progress = clipped;
          if (stateChanged && !_refreshing) {
            toggleState = clipped && !prevProgress2 ? 0 : clipped === 1 ? 1 : prevProgress2 === 1 ? 2 : 3;
            if (isToggle) {
              action = !toggled && toggleActions[toggleState + 1] !== "none" && toggleActions[toggleState + 1] || toggleActions[toggleState];
              isTakingAction = animation && (action === "complete" || action === "reset" || action in animation);
            }
          }
          preventOverlaps && (toggled || isTakingAction) && (isTakingAction || scrub || !animation) && (_isFunction5(preventOverlaps) ? preventOverlaps(self) : self.getTrailing(preventOverlaps).forEach(function(t6) {
            return t6.endAnimation();
          }));
          if (!isToggle) {
            if (scrubTween && !_refreshing && !_startup2) {
              scrubTween._dp._time - scrubTween._start !== scrubTween._time && scrubTween.render(scrubTween._dp._time - scrubTween._start);
              if (scrubTween.resetTo) {
                scrubTween.resetTo("totalProgress", clipped, animation._tTime / animation._tDur);
              } else {
                scrubTween.vars.totalProgress = clipped;
                scrubTween.invalidate().restart();
              }
            } else if (animation) {
              animation.totalProgress(clipped, !!(_refreshing && (lastRefresh || reset)));
            }
          }
          if (pin) {
            reset && pinSpacing && (spacer.style[pinSpacing + direction.os2] = spacingStart);
            if (!useFixedPosition) {
              pinSetter(_round3(pinStart + pinChange * clipped));
            } else if (stateChanged) {
              isAtMax = !reset && clipped > prevProgress2 && end + 1 > scroll && scroll + 1 >= _maxScroll(scroller, direction);
              if (pinReparent) {
                if (!reset && (isActive || isAtMax)) {
                  var bounds = _getBounds(pin, true), _offset = scroll - start;
                  _reparent(pin, _body3, bounds.top + (direction === _vertical ? _offset : 0) + _px, bounds.left + (direction === _vertical ? 0 : _offset) + _px);
                } else {
                  _reparent(pin, spacer);
                }
              }
              _setState(isActive || isAtMax ? pinActiveState : pinState);
              pinMoves && clipped < 1 && isActive || pinSetter(pinStart + (clipped === 1 && !isAtMax ? pinChange : 0));
            }
          }
          snap3 && !tweenTo.tween && !_refreshing && !_startup2 && snapDelayedCall.restart(true);
          toggleClass2 && (toggled || once && clipped && (clipped < 1 || !_limitCallbacks)) && _toArray2(toggleClass2.targets).forEach(function(el) {
            return el.classList[isActive || once ? "add" : "remove"](toggleClass2.className);
          });
          onUpdate && !isToggle && !reset && onUpdate(self);
          if (stateChanged && !_refreshing) {
            if (isToggle) {
              if (isTakingAction) {
                if (action === "complete") {
                  animation.pause().totalProgress(1);
                } else if (action === "reset") {
                  animation.restart(true).pause();
                } else if (action === "restart") {
                  animation.restart(true);
                } else {
                  animation[action]();
                }
              }
              onUpdate && onUpdate(self);
            }
            if (toggled || !_limitCallbacks) {
              onToggle && toggled && _callback3(self, onToggle);
              callbacks[toggleState] && _callback3(self, callbacks[toggleState]);
              once && (clipped === 1 ? self.kill(false, 1) : callbacks[toggleState] = 0);
              if (!toggled) {
                toggleState = clipped === 1 ? 1 : 3;
                callbacks[toggleState] && _callback3(self, callbacks[toggleState]);
              }
            }
            if (fastScrollEnd && !isActive && Math.abs(self.getVelocity()) > (_isNumber3(fastScrollEnd) ? fastScrollEnd : 2500)) {
              _endAnimation(self.callbackAnimation);
              scrubTween ? scrubTween.progress(1) : _endAnimation(animation, action === "reverse" ? 1 : !clipped, 1);
            }
          } else if (isToggle && onUpdate && !_refreshing) {
            onUpdate(self);
          }
        }
        if (markerEndSetter) {
          var n6 = containerAnimation ? scroll / containerAnimation.duration() * (containerAnimation._caScrollDist || 0) : scroll;
          markerStartSetter(n6 + (markerStartTrigger._isFlipped ? 1 : 0));
          markerEndSetter(n6);
        }
        caMarkerSetter && caMarkerSetter(-scroll / containerAnimation.duration() * (containerAnimation._caScrollDist || 0));
      };
      self.enable = function(reset, refresh) {
        if (!self.enabled) {
          self.enabled = true;
          _addListener3(scroller, "resize", _onResize);
          isViewport || _addListener3(scroller, "scroll", _onScroll3);
          onRefreshInit && _addListener3(ScrollTrigger4, "refreshInit", onRefreshInit);
          if (reset !== false) {
            self.progress = prevProgress = 0;
            scroll1 = scroll2 = lastSnap = scrollFunc();
          }
          refresh !== false && self.refresh();
        }
      };
      self.getTween = function(snap4) {
        return snap4 && tweenTo ? tweenTo.tween : scrubTween;
      };
      self.setPositions = function(newStart, newEnd, keepClamp, pinOffset) {
        if (containerAnimation) {
          var st = containerAnimation.scrollTrigger, duration = containerAnimation.duration(), _change = st.end - st.start;
          newStart = st.start + _change * newStart / duration;
          newEnd = st.start + _change * newEnd / duration;
        }
        self.refresh(false, false, {
          start: _keepClamp(newStart, keepClamp && !!self._startClamp),
          end: _keepClamp(newEnd, keepClamp && !!self._endClamp)
        }, pinOffset);
        self.update();
      };
      self.adjustPinSpacing = function(amount) {
        if (spacerState && amount) {
          var i5 = spacerState.indexOf(direction.d) + 1;
          spacerState[i5] = parseFloat(spacerState[i5]) + amount + _px;
          spacerState[1] = parseFloat(spacerState[1]) + amount + _px;
          _setState(spacerState);
        }
      };
      self.disable = function(reset, allowAnimation) {
        if (self.enabled) {
          reset !== false && self.revert(true, true);
          self.enabled = self.isActive = false;
          allowAnimation || scrubTween && scrubTween.pause();
          prevScroll = 0;
          pinCache && (pinCache.uncache = 1);
          onRefreshInit && _removeListener3(ScrollTrigger4, "refreshInit", onRefreshInit);
          if (snapDelayedCall) {
            snapDelayedCall.pause();
            tweenTo.tween && tweenTo.tween.kill() && (tweenTo.tween = 0);
          }
          if (!isViewport) {
            var i5 = _triggers.length;
            while (i5--) {
              if (_triggers[i5].scroller === scroller && _triggers[i5] !== self) {
                return;
              }
            }
            _removeListener3(scroller, "resize", _onResize);
            isViewport || _removeListener3(scroller, "scroll", _onScroll3);
          }
        }
      };
      self.kill = function(revert, allowAnimation) {
        self.disable(revert, allowAnimation);
        scrubTween && !allowAnimation && scrubTween.kill();
        id && delete _ids[id];
        var i5 = _triggers.indexOf(self);
        i5 >= 0 && _triggers.splice(i5, 1);
        i5 === _i && _direction > 0 && _i--;
        i5 = 0;
        _triggers.forEach(function(t6) {
          return t6.scroller === self.scroller && (i5 = 1);
        });
        i5 || _refreshingAll || (self.scroll.rec = 0);
        if (animation) {
          animation.scrollTrigger = null;
          revert && animation.revert({
            kill: false
          });
          allowAnimation || animation.kill();
        }
        markerStart && [markerStart, markerEnd, markerStartTrigger, markerEndTrigger].forEach(function(m2) {
          return m2.parentNode && m2.parentNode.removeChild(m2);
        });
        _primary === self && (_primary = 0);
        if (pin) {
          pinCache && (pinCache.uncache = 1);
          i5 = 0;
          _triggers.forEach(function(t6) {
            return t6.pin === pin && i5++;
          });
          i5 || (pinCache.spacer = 0);
        }
        vars.onKill && vars.onKill(self);
      };
      _triggers.push(self);
      self.enable(false, false);
      customRevertReturn && customRevertReturn(self);
      if (animation && animation.add && !change) {
        var updateFunc = self.update;
        self.update = function() {
          self.update = updateFunc;
          start || end || self.refresh();
        };
        gsap4.delayedCall(0.01, self.update);
        change = 0.01;
        start = end = 0;
      } else {
        self.refresh();
      }
      pin && _queueRefreshAll();
    };
    ScrollTrigger4.register = function register2(core) {
      if (!_coreInitted4) {
        gsap4 = core || _getGSAP5();
        _windowExists7() && window.document && ScrollTrigger4.enable();
        _coreInitted4 = _enabled;
      }
      return _coreInitted4;
    };
    ScrollTrigger4.defaults = function defaults4(config3) {
      if (config3) {
        for (var p2 in config3) {
          _defaults3[p2] = config3[p2];
        }
      }
      return _defaults3;
    };
    ScrollTrigger4.disable = function disable(reset, kill2) {
      _enabled = 0;
      _triggers.forEach(function(trigger) {
        return trigger[kill2 ? "kill" : "disable"](reset);
      });
      _removeListener3(_win4, "wheel", _onScroll3);
      _removeListener3(_doc4, "scroll", _onScroll3);
      clearInterval(_syncInterval);
      _removeListener3(_doc4, "touchcancel", _passThrough3);
      _removeListener3(_body3, "touchstart", _passThrough3);
      _multiListener(_removeListener3, _doc4, "pointerdown,touchstart,mousedown", _pointerDownHandler);
      _multiListener(_removeListener3, _doc4, "pointerup,touchend,mouseup", _pointerUpHandler);
      _resizeDelay.kill();
      _iterateAutoRefresh(_removeListener3);
      for (var i5 = 0; i5 < _scrollers.length; i5 += 3) {
        _wheelListener(_removeListener3, _scrollers[i5], _scrollers[i5 + 1]);
        _wheelListener(_removeListener3, _scrollers[i5], _scrollers[i5 + 2]);
      }
    };
    ScrollTrigger4.enable = function enable() {
      _win4 = window;
      _doc4 = document;
      _docEl3 = _doc4.documentElement;
      _body3 = _doc4.body;
      if (gsap4) {
        _toArray2 = gsap4.utils.toArray;
        _clamp4 = gsap4.utils.clamp;
        _context3 = gsap4.core.context || _passThrough3;
        _suppressOverwrites2 = gsap4.core.suppressOverwrites || _passThrough3;
        _scrollRestoration = _win4.history.scrollRestoration || "auto";
        _lastScroll = _win4.pageYOffset;
        gsap4.core.globals("ScrollTrigger", ScrollTrigger4);
        if (_body3) {
          _enabled = 1;
          _div100vh = document.createElement("div");
          _div100vh.style.height = "100vh";
          _div100vh.style.position = "absolute";
          _refresh100vh();
          _rafBugFix();
          Observer.register(gsap4);
          ScrollTrigger4.isTouch = Observer.isTouch;
          _fixIOSBug = Observer.isTouch && /(iPad|iPhone|iPod|Mac)/g.test(navigator.userAgent);
          _ignoreMobileResize = Observer.isTouch === 1;
          _addListener3(_win4, "wheel", _onScroll3);
          _root2 = [_win4, _doc4, _docEl3, _body3];
          if (gsap4.matchMedia) {
            ScrollTrigger4.matchMedia = function(vars) {
              var mm = gsap4.matchMedia(), p2;
              for (p2 in vars) {
                mm.add(p2, vars[p2]);
              }
              return mm;
            };
            gsap4.addEventListener("matchMediaInit", function() {
              return _revertAll();
            });
            gsap4.addEventListener("matchMediaRevert", function() {
              return _revertRecorded();
            });
            gsap4.addEventListener("matchMedia", function() {
              _refreshAll(0, 1);
              _dispatch3("matchMedia");
            });
            gsap4.matchMedia("(orientation: portrait)", function() {
              _setBaseDimensions();
              return _setBaseDimensions;
            });
          } else {
            console.warn("Requires GSAP 3.11.0 or later");
          }
          _setBaseDimensions();
          _addListener3(_doc4, "scroll", _onScroll3);
          var bodyStyle = _body3.style, border = bodyStyle.borderTopStyle, AnimationProto = gsap4.core.Animation.prototype, bounds, i5;
          AnimationProto.revert || Object.defineProperty(AnimationProto, "revert", {
            value: function value() {
              return this.time(-0.01, true);
            }
          });
          bodyStyle.borderTopStyle = "solid";
          bounds = _getBounds(_body3);
          _vertical.m = Math.round(bounds.top + _vertical.sc()) || 0;
          _horizontal.m = Math.round(bounds.left + _horizontal.sc()) || 0;
          border ? bodyStyle.borderTopStyle = border : bodyStyle.removeProperty("border-top-style");
          _syncInterval = setInterval(_sync, 250);
          gsap4.delayedCall(0.5, function() {
            return _startup2 = 0;
          });
          _addListener3(_doc4, "touchcancel", _passThrough3);
          _addListener3(_body3, "touchstart", _passThrough3);
          _multiListener(_addListener3, _doc4, "pointerdown,touchstart,mousedown", _pointerDownHandler);
          _multiListener(_addListener3, _doc4, "pointerup,touchend,mouseup", _pointerUpHandler);
          _transformProp2 = gsap4.utils.checkPrefix("transform");
          _stateProps.push(_transformProp2);
          _coreInitted4 = _getTime2();
          _resizeDelay = gsap4.delayedCall(0.2, _refreshAll).pause();
          _autoRefresh = [_doc4, "visibilitychange", function() {
            var w2 = _win4.innerWidth, h5 = _win4.innerHeight;
            if (_doc4.hidden) {
              _prevWidth = w2;
              _prevHeight = h5;
            } else if (_prevWidth !== w2 || _prevHeight !== h5) {
              _onResize();
            }
          }, _doc4, "DOMContentLoaded", _refreshAll, _win4, "load", _refreshAll, _win4, "resize", _onResize];
          _iterateAutoRefresh(_addListener3);
          _triggers.forEach(function(trigger) {
            return trigger.enable(0, 1);
          });
          for (i5 = 0; i5 < _scrollers.length; i5 += 3) {
            _wheelListener(_removeListener3, _scrollers[i5], _scrollers[i5 + 1]);
            _wheelListener(_removeListener3, _scrollers[i5], _scrollers[i5 + 2]);
          }
        }
      }
    };
    ScrollTrigger4.config = function config3(vars) {
      "limitCallbacks" in vars && (_limitCallbacks = !!vars.limitCallbacks);
      var ms2 = vars.syncInterval;
      ms2 && clearInterval(_syncInterval) || (_syncInterval = ms2) && setInterval(_sync, ms2);
      "ignoreMobileResize" in vars && (_ignoreMobileResize = ScrollTrigger4.isTouch === 1 && vars.ignoreMobileResize);
      if ("autoRefreshEvents" in vars) {
        _iterateAutoRefresh(_removeListener3) || _iterateAutoRefresh(_addListener3, vars.autoRefreshEvents || "none");
        _ignoreResize = (vars.autoRefreshEvents + "").indexOf("resize") === -1;
      }
    };
    ScrollTrigger4.scrollerProxy = function scrollerProxy(target, vars) {
      var t6 = _getTarget(target), i5 = _scrollers.indexOf(t6), isViewport = _isViewport3(t6);
      if (~i5) {
        _scrollers.splice(i5, isViewport ? 6 : 2);
      }
      if (vars) {
        isViewport ? _proxies.unshift(_win4, vars, _body3, vars, _docEl3, vars) : _proxies.unshift(t6, vars);
      }
    };
    ScrollTrigger4.clearMatchMedia = function clearMatchMedia(query) {
      _triggers.forEach(function(t6) {
        return t6._ctx && t6._ctx.query === query && t6._ctx.kill(true, true);
      });
    };
    ScrollTrigger4.isInViewport = function isInViewport(element, ratio, horizontal) {
      var bounds = (_isString5(element) ? _getTarget(element) : element).getBoundingClientRect(), offset2 = bounds[horizontal ? _width : _height] * ratio || 0;
      return horizontal ? bounds.right - offset2 > 0 && bounds.left + offset2 < _win4.innerWidth : bounds.bottom - offset2 > 0 && bounds.top + offset2 < _win4.innerHeight;
    };
    ScrollTrigger4.positionInViewport = function positionInViewport(element, referencePoint, horizontal) {
      _isString5(element) && (element = _getTarget(element));
      var bounds = element.getBoundingClientRect(), size2 = bounds[horizontal ? _width : _height], offset2 = referencePoint == null ? size2 / 2 : referencePoint in _keywords ? _keywords[referencePoint] * size2 : ~referencePoint.indexOf("%") ? parseFloat(referencePoint) * size2 / 100 : parseFloat(referencePoint) || 0;
      return horizontal ? (bounds.left + offset2) / _win4.innerWidth : (bounds.top + offset2) / _win4.innerHeight;
    };
    ScrollTrigger4.killAll = function killAll(allowListeners) {
      _triggers.slice(0).forEach(function(t6) {
        return t6.vars.id !== "ScrollSmoother" && t6.kill();
      });
      if (allowListeners !== true) {
        var listeners = _listeners2.killAll || [];
        _listeners2 = {};
        listeners.forEach(function(f2) {
          return f2();
        });
      }
    };
    return ScrollTrigger4;
  }();
  ScrollTrigger3.version = "3.12.5";
  ScrollTrigger3.saveStyles = function(targets) {
    return targets ? _toArray2(targets).forEach(function(target) {
      if (target && target.style) {
        var i5 = _savedStyles.indexOf(target);
        i5 >= 0 && _savedStyles.splice(i5, 5);
        _savedStyles.push(target, target.style.cssText, target.getBBox && target.getAttribute("transform"), gsap4.core.getCache(target), _context3());
      }
    }) : _savedStyles;
  };
  ScrollTrigger3.revert = function(soft, media) {
    return _revertAll(!soft, media);
  };
  ScrollTrigger3.create = function(vars, animation) {
    return new ScrollTrigger3(vars, animation);
  };
  ScrollTrigger3.refresh = function(safe) {
    return safe ? _onResize() : (_coreInitted4 || ScrollTrigger3.register()) && _refreshAll(true);
  };
  ScrollTrigger3.update = function(force) {
    return ++_scrollers.cache && _updateAll(force === true ? 2 : 0);
  };
  ScrollTrigger3.clearScrollMemory = _clearScrollMemory;
  ScrollTrigger3.maxScroll = function(element, horizontal) {
    return _maxScroll(element, horizontal ? _horizontal : _vertical);
  };
  ScrollTrigger3.getScrollFunc = function(element, horizontal) {
    return _getScrollFunc(_getTarget(element), horizontal ? _horizontal : _vertical);
  };
  ScrollTrigger3.getById = function(id) {
    return _ids[id];
  };
  ScrollTrigger3.getAll = function() {
    return _triggers.filter(function(t6) {
      return t6.vars.id !== "ScrollSmoother";
    });
  };
  ScrollTrigger3.isScrolling = function() {
    return !!_lastScrollTime;
  };
  ScrollTrigger3.snapDirectional = _snapDirectional;
  ScrollTrigger3.addEventListener = function(type, callback) {
    var a4 = _listeners2[type] || (_listeners2[type] = []);
    ~a4.indexOf(callback) || a4.push(callback);
  };
  ScrollTrigger3.removeEventListener = function(type, callback) {
    var a4 = _listeners2[type], i5 = a4 && a4.indexOf(callback);
    i5 >= 0 && a4.splice(i5, 1);
  };
  ScrollTrigger3.batch = function(targets, vars) {
    var result = [], varsCopy = {}, interval = vars.interval || 0.016, batchMax = vars.batchMax || 1e9, proxyCallback = function proxyCallback2(type, callback) {
      var elements = [], triggers = [], delay = gsap4.delayedCall(interval, function() {
        callback(elements, triggers);
        elements = [];
        triggers = [];
      }).pause();
      return function(self) {
        elements.length || delay.restart(true);
        elements.push(self.trigger);
        triggers.push(self);
        batchMax <= elements.length && delay.progress(1);
      };
    }, p2;
    for (p2 in vars) {
      varsCopy[p2] = p2.substr(0, 2) === "on" && _isFunction5(vars[p2]) && p2 !== "onRefreshInit" ? proxyCallback(p2, vars[p2]) : vars[p2];
    }
    if (_isFunction5(batchMax)) {
      batchMax = batchMax();
      _addListener3(ScrollTrigger3, "refresh", function() {
        return batchMax = vars.batchMax();
      });
    }
    _toArray2(targets).forEach(function(target) {
      var config3 = {};
      for (p2 in varsCopy) {
        config3[p2] = varsCopy[p2];
      }
      config3.trigger = target;
      result.push(ScrollTrigger3.create(config3));
    });
    return result;
  };
  var _clampScrollAndGetDurationMultiplier = function _clampScrollAndGetDurationMultiplier2(scrollFunc, current, end, max2) {
    current > max2 ? scrollFunc(max2) : current < 0 && scrollFunc(0);
    return end > max2 ? (max2 - current) / (end - current) : end < 0 ? current / (current - end) : 1;
  };
  var _allowNativePanning = function _allowNativePanning2(target, direction) {
    if (direction === true) {
      target.style.removeProperty("touch-action");
    } else {
      target.style.touchAction = direction === true ? "auto" : direction ? "pan-" + direction + (Observer.isTouch ? " pinch-zoom" : "") : "none";
    }
    target === _docEl3 && _allowNativePanning2(_body3, direction);
  };
  var _overflow = {
    auto: 1,
    scroll: 1
  };
  var _nestedScroll = function _nestedScroll2(_ref5) {
    var event2 = _ref5.event, target = _ref5.target, axis = _ref5.axis;
    var node = (event2.changedTouches ? event2.changedTouches[0] : event2).target, cache2 = node._gsap || gsap4.core.getCache(node), time = _getTime2(), cs;
    if (!cache2._isScrollT || time - cache2._isScrollT > 2e3) {
      while (node && node !== _body3 && (node.scrollHeight <= node.clientHeight && node.scrollWidth <= node.clientWidth || !(_overflow[(cs = _getComputedStyle(node)).overflowY] || _overflow[cs.overflowX]))) {
        node = node.parentNode;
      }
      cache2._isScroll = node && node !== target && !_isViewport3(node) && (_overflow[(cs = _getComputedStyle(node)).overflowY] || _overflow[cs.overflowX]);
      cache2._isScrollT = time;
    }
    if (cache2._isScroll || axis === "x") {
      event2.stopPropagation();
      event2._gsapAllow = true;
    }
  };
  var _inputObserver = function _inputObserver2(target, type, inputs, nested) {
    return Observer.create({
      target,
      capture: true,
      debounce: false,
      lockAxis: true,
      type,
      onWheel: nested = nested && _nestedScroll,
      onPress: nested,
      onDrag: nested,
      onScroll: nested,
      onEnable: function onEnable() {
        return inputs && _addListener3(_doc4, Observer.eventTypes[0], _captureInputs, false, true);
      },
      onDisable: function onDisable() {
        return _removeListener3(_doc4, Observer.eventTypes[0], _captureInputs, true);
      }
    });
  };
  var _inputExp = /(input|label|select|textarea)/i;
  var _inputIsFocused;
  var _captureInputs = function _captureInputs2(e8) {
    var isInput = _inputExp.test(e8.target.tagName);
    if (isInput || _inputIsFocused) {
      e8._gsapAllow = true;
      _inputIsFocused = isInput;
    }
  };
  var _getScrollNormalizer = function _getScrollNormalizer2(vars) {
    _isObject3(vars) || (vars = {});
    vars.preventDefault = vars.isNormalizer = vars.allowClicks = true;
    vars.type || (vars.type = "wheel,touch");
    vars.debounce = !!vars.debounce;
    vars.id = vars.id || "normalizer";
    var _vars2 = vars, normalizeScrollX = _vars2.normalizeScrollX, momentum = _vars2.momentum, allowNestedScroll = _vars2.allowNestedScroll, onRelease = _vars2.onRelease, self, maxY, target = _getTarget(vars.target) || _docEl3, smoother = gsap4.core.globals().ScrollSmoother, smootherInstance = smoother && smoother.get(), content = _fixIOSBug && (vars.content && _getTarget(vars.content) || smootherInstance && vars.content !== false && !smootherInstance.smooth() && smootherInstance.content()), scrollFuncY = _getScrollFunc(target, _vertical), scrollFuncX = _getScrollFunc(target, _horizontal), scale = 1, initialScale = (Observer.isTouch && _win4.visualViewport ? _win4.visualViewport.scale * _win4.visualViewport.width : _win4.outerWidth) / _win4.innerWidth, wheelRefresh = 0, resolveMomentumDuration = _isFunction5(momentum) ? function() {
      return momentum(self);
    } : function() {
      return momentum || 2.8;
    }, lastRefreshID, skipTouchMove, inputObserver = _inputObserver(target, vars.type, true, allowNestedScroll), resumeTouchMove = function resumeTouchMove2() {
      return skipTouchMove = false;
    }, scrollClampX = _passThrough3, scrollClampY = _passThrough3, updateClamps = function updateClamps2() {
      maxY = _maxScroll(target, _vertical);
      scrollClampY = _clamp4(_fixIOSBug ? 1 : 0, maxY);
      normalizeScrollX && (scrollClampX = _clamp4(0, _maxScroll(target, _horizontal)));
      lastRefreshID = _refreshID;
    }, removeContentOffset = function removeContentOffset2() {
      content._gsap.y = _round3(parseFloat(content._gsap.y) + scrollFuncY.offset) + "px";
      content.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + parseFloat(content._gsap.y) + ", 0, 1)";
      scrollFuncY.offset = scrollFuncY.cacheID = 0;
    }, ignoreDrag = function ignoreDrag2() {
      if (skipTouchMove) {
        requestAnimationFrame(resumeTouchMove);
        var offset2 = _round3(self.deltaY / 2), scroll = scrollClampY(scrollFuncY.v - offset2);
        if (content && scroll !== scrollFuncY.v + scrollFuncY.offset) {
          scrollFuncY.offset = scroll - scrollFuncY.v;
          var y2 = _round3((parseFloat(content && content._gsap.y) || 0) - scrollFuncY.offset);
          content.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + y2 + ", 0, 1)";
          content._gsap.y = y2 + "px";
          scrollFuncY.cacheID = _scrollers.cache;
          _updateAll();
        }
        return true;
      }
      scrollFuncY.offset && removeContentOffset();
      skipTouchMove = true;
    }, tween, startScrollX, startScrollY, onStopDelayedCall, onResize2 = function onResize3() {
      updateClamps();
      if (tween.isActive() && tween.vars.scrollY > maxY) {
        scrollFuncY() > maxY ? tween.progress(1) && scrollFuncY(maxY) : tween.resetTo("scrollY", maxY);
      }
    };
    content && gsap4.set(content, {
      y: "+=0"
    });
    vars.ignoreCheck = function(e8) {
      return _fixIOSBug && e8.type === "touchmove" && ignoreDrag(e8) || scale > 1.05 && e8.type !== "touchstart" || self.isGesturing || e8.touches && e8.touches.length > 1;
    };
    vars.onPress = function() {
      skipTouchMove = false;
      var prevScale = scale;
      scale = _round3((_win4.visualViewport && _win4.visualViewport.scale || 1) / initialScale);
      tween.pause();
      prevScale !== scale && _allowNativePanning(target, scale > 1.01 ? true : normalizeScrollX ? false : "x");
      startScrollX = scrollFuncX();
      startScrollY = scrollFuncY();
      updateClamps();
      lastRefreshID = _refreshID;
    };
    vars.onRelease = vars.onGestureStart = function(self2, wasDragging) {
      scrollFuncY.offset && removeContentOffset();
      if (!wasDragging) {
        onStopDelayedCall.restart(true);
      } else {
        _scrollers.cache++;
        var dur = resolveMomentumDuration(), currentScroll, endScroll;
        if (normalizeScrollX) {
          currentScroll = scrollFuncX();
          endScroll = currentScroll + dur * 0.05 * -self2.velocityX / 0.227;
          dur *= _clampScrollAndGetDurationMultiplier(scrollFuncX, currentScroll, endScroll, _maxScroll(target, _horizontal));
          tween.vars.scrollX = scrollClampX(endScroll);
        }
        currentScroll = scrollFuncY();
        endScroll = currentScroll + dur * 0.05 * -self2.velocityY / 0.227;
        dur *= _clampScrollAndGetDurationMultiplier(scrollFuncY, currentScroll, endScroll, _maxScroll(target, _vertical));
        tween.vars.scrollY = scrollClampY(endScroll);
        tween.invalidate().duration(dur).play(0.01);
        if (_fixIOSBug && tween.vars.scrollY >= maxY || currentScroll >= maxY - 1) {
          gsap4.to({}, {
            onUpdate: onResize2,
            duration: dur
          });
        }
      }
      onRelease && onRelease(self2);
    };
    vars.onWheel = function() {
      tween._ts && tween.pause();
      if (_getTime2() - wheelRefresh > 1e3) {
        lastRefreshID = 0;
        wheelRefresh = _getTime2();
      }
    };
    vars.onChange = function(self2, dx, dy, xArray, yArray) {
      _refreshID !== lastRefreshID && updateClamps();
      dx && normalizeScrollX && scrollFuncX(scrollClampX(xArray[2] === dx ? startScrollX + (self2.startX - self2.x) : scrollFuncX() + dx - xArray[1]));
      if (dy) {
        scrollFuncY.offset && removeContentOffset();
        var isTouch = yArray[2] === dy, y2 = isTouch ? startScrollY + self2.startY - self2.y : scrollFuncY() + dy - yArray[1], yClamped = scrollClampY(y2);
        isTouch && y2 !== yClamped && (startScrollY += yClamped - y2);
        scrollFuncY(yClamped);
      }
      (dy || dx) && _updateAll();
    };
    vars.onEnable = function() {
      _allowNativePanning(target, normalizeScrollX ? false : "x");
      ScrollTrigger3.addEventListener("refresh", onResize2);
      _addListener3(_win4, "resize", onResize2);
      if (scrollFuncY.smooth) {
        scrollFuncY.target.style.scrollBehavior = "auto";
        scrollFuncY.smooth = scrollFuncX.smooth = false;
      }
      inputObserver.enable();
    };
    vars.onDisable = function() {
      _allowNativePanning(target, true);
      _removeListener3(_win4, "resize", onResize2);
      ScrollTrigger3.removeEventListener("refresh", onResize2);
      inputObserver.kill();
    };
    vars.lockAxis = vars.lockAxis !== false;
    self = new Observer(vars);
    self.iOS = _fixIOSBug;
    _fixIOSBug && !scrollFuncY() && scrollFuncY(1);
    _fixIOSBug && gsap4.ticker.add(_passThrough3);
    onStopDelayedCall = self._dc;
    tween = gsap4.to(self, {
      ease: "power4",
      paused: true,
      inherit: false,
      scrollX: normalizeScrollX ? "+=0.1" : "+=0",
      scrollY: "+=0.1",
      modifiers: {
        scrollY: _interruptionTracker(scrollFuncY, scrollFuncY(), function() {
          return tween.pause();
        })
      },
      onUpdate: _updateAll,
      onComplete: onStopDelayedCall.vars.onComplete
    });
    return self;
  };
  ScrollTrigger3.sort = function(func) {
    return _triggers.sort(func || function(a4, b2) {
      return (a4.vars.refreshPriority || 0) * -1e6 + a4.start - (b2.start + (b2.vars.refreshPriority || 0) * -1e6);
    });
  };
  ScrollTrigger3.observe = function(vars) {
    return new Observer(vars);
  };
  ScrollTrigger3.normalizeScroll = function(vars) {
    if (typeof vars === "undefined") {
      return _normalizer2;
    }
    if (vars === true && _normalizer2) {
      return _normalizer2.enable();
    }
    if (vars === false) {
      _normalizer2 && _normalizer2.kill();
      _normalizer2 = vars;
      return;
    }
    var normalizer = vars instanceof Observer ? vars : _getScrollNormalizer(vars);
    _normalizer2 && _normalizer2.target === normalizer.target && _normalizer2.kill();
    _isViewport3(normalizer.target) && (_normalizer2 = normalizer);
    return normalizer;
  };
  ScrollTrigger3.core = {
    // smaller file size way to leverage in ScrollSmoother and Observer
    _getVelocityProp,
    _inputObserver,
    _scrollers,
    _proxies,
    bridge: {
      // when normalizeScroll sets the scroll position (ss = setScroll)
      ss: function ss() {
        _lastScrollTime || _dispatch3("scrollStart");
        _lastScrollTime = _getTime2();
      },
      // a way to get the _refreshing value in Observer
      ref: function ref() {
        return _refreshing;
      }
    }
  };
  _getGSAP5() && gsap4.registerPlugin(ScrollTrigger3);

  // src/missaoAnimation.ts
  var import_sticksy = __toESM(require_sticksy2(), 1);
  gsapWithCSS.registerPlugin(ScrollTrigger3, ScrollToPlugin);
  function initializeScrollEffect() {
    function isMobile() {
      return window.innerWidth < 768;
    }
    if (!isMobile()) {
      let updateState2 = function(textItem, linkItem, textElementItem, isActive) {
        if (isActive) {
          textItem.classList.add("active");
          linkItem.classList.add("current");
          if (textElementItem) {
            textElementItem.classList.add("active");
          }
        } else {
          textItem.classList.remove("active");
          linkItem.classList.remove("current");
          if (textElementItem) {
            textElementItem.classList.remove("active");
          }
        }
      };
      var updateState = updateState2;
      const stickyConfig = {
        topSpacing: 40,
        listen: true
      };
      const stickyEl = new Sticksy(".visual_text_left_elements", stickyConfig);
      stickyEl.onStateChanged = function(state) {
        if (state === "fixed") {
          stickyEl.nodeRef.classList.add("widget--sticky");
        } else {
          stickyEl.nodeRef.classList.remove("widget--sticky");
        }
      };
      const textItems = document.querySelectorAll(".text_item");
      const textElementsItems = document.querySelectorAll(".text_elements_item");
      textItems.forEach((textItem, index) => {
        const linkItem = document.querySelector(`.link_ref_item[href="#${textItem.id}"]`);
        const textElementItem = textElementsItems[index];
        ScrollTrigger3.create({
          trigger: textItem,
          start: "top center",
          end: "bottom center",
          onEnter: () => updateState2(textItem, linkItem, textElementItem, true),
          onEnterBack: () => updateState2(textItem, linkItem, textElementItem, true),
          onLeave: () => updateState2(textItem, linkItem, textElementItem, false),
          onLeaveBack: () => updateState2(textItem, linkItem, textElementItem, false)
        });
      });
      $(".marquee_about").each(function() {
        const track = $(this).find(".marquee_track_about");
        const items = $(this).find(".marquee_item_about");
        const tl = gsapWithCSS.timeline({
          paused: true,
          defaults: { ease: "expo.inOut", duration: 0.7 }
        });
        items.each((index, item) => {
          if (index < items.length - 1) {
            tl.to(track, { yPercent: (index + 1) * -100 }, index);
          }
        });
        textItems.forEach((textItem, index) => {
          ScrollTrigger3.create({
            trigger: textItem,
            start: "top center",
            end: "bottom center",
            onEnter: () => {
              tl.tweenTo(index);
            },
            onEnterBack: () => {
              tl.tweenTo(index);
            }
          });
        });
      });
      document.querySelectorAll(".link_ref_item").forEach((link) => {
        link.addEventListener("click", function(event2) {
          event2.preventDefault();
          const targetId = this.getAttribute("href").substring(1);
          const targetElement = document.getElementById(targetId);
          if (targetElement) {
            gsapWithCSS.to(window, { duration: 1, scrollTo: targetElement, ease: "power2.inOut" });
          }
        });
      });
    }
  }

  // src/priceAnimation.ts
  init_live_reload();
  var { Dragdealer } = require_dragdealer();
  function initializedragEffect() {
    if (window.innerWidth > 1024) {
      let changeColor2 = function(item) {
        const myColor = item.find(".color").css("background-color");
        $(".handle_fill").css("border-color", myColor);
        $(".handle_back").css("background-color", myColor);
      }, updateActiveState2 = function(activeItem) {
        cmsItem.removeClass("active").find(".link_contato").removeClass("active");
        activeItem.addClass("active");
        activeItem.find(".link_contato").addClass("active");
        changeColor2(activeItem);
      }, smoothInterpolation2 = function(target, current, factor = 0.1) {
        return current + (target - current) * factor;
      }, formatValue2 = function(value) {
        const fixedValue = value.toFixed(1);
        if (fixedValue.endsWith(".0")) {
          return "+" + fixedValue.slice(0, -2);
        }
        return fixedValue;
      }, animate2 = function() {
        lastValue = smoothInterpolation2(targetValue, lastValue);
        $(".handle_count").text(formatValue2(lastValue));
        if (Math.abs(targetValue - lastValue) > 0.1) {
          animationFrameId = requestAnimationFrame(animate2);
        } else {
          lastValue = targetValue;
          $(".handle_count").text(formatValue2(targetValue));
          animationFrameId = null;
        }
      };
      var changeColor = changeColor2, updateActiveState = updateActiveState2, smoothInterpolation = smoothInterpolation2, formatValue = formatValue2, animate = animate2;
      const cmsItem = $(".position_item");
      const cmsItemLength = cmsItem.length;
      let dragdealer;
      changeColor2(cmsItem.eq(0));
      updateActiveState2(cmsItem.eq(0));
      let lastValue = parseFloat(cmsItem.eq(0).find(".position_salary").text());
      let targetValue = lastValue;
      let animationFrameId = null;
      dragdealer = new Dragdealer("drag-steps", {
        steps: cmsItemLength,
        speed: 0.2,
        loose: false,
        slide: true,
        animationCallback: function(x2, y2) {
          const exactIndex = x2 * (cmsItemLength - 1);
          const lowerIndex = Math.floor(exactIndex);
          const upperIndex = Math.ceil(exactIndex);
          if (lowerIndex === upperIndex) {
            targetValue = parseFloat(cmsItem.eq(lowerIndex).find(".position_salary").text());
          } else {
            const lowerValue = parseFloat(cmsItem.eq(lowerIndex).find(".position_salary").text());
            const upperValue = parseFloat(cmsItem.eq(upperIndex).find(".position_salary").text());
            const progress = exactIndex - lowerIndex;
            targetValue = lowerValue + (upperValue - lowerValue) * progress;
          }
          if (!animationFrameId) {
            animate2();
          }
          const activeItemIndex = Math.round(exactIndex);
          updateActiveState2(cmsItem.eq(activeItemIndex));
        },
        callback: function(x2, y2) {
          cmsItem.each(function(index) {
            const currentDecimal = $(this).index() / (cmsItemLength - 1);
            if (x2 == currentDecimal) {
              updateActiveState2($(this));
              const fixedValue = parseFloat($(this).find(".position_salary").text());
              targetValue = fixedValue;
              lastValue = fixedValue;
              $(".handle_count").text(formatValue2(fixedValue));
            }
          });
        },
        dragStopCallback(x2, y2) {
          $(".handle_fill").addClass("release");
        }
      });
      $(".handle").on("mousedown touchstart", function() {
        $(".handle_fill").removeClass("release");
      });
      $(".handle").on("mouseup touchend", function() {
        $(".handle_fill").addClass("release");
      });
      cmsItem.on("mouseenter", function() {
        const index = $(this).index();
        const position = index / (cmsItemLength - 1);
        dragdealer.setValue(position);
      });
      cmsItem.on("mouseleave", function() {
      });
    }
  }

  // src/videoSettings.ts
  init_live_reload();

  // node_modules/.pnpm/swiper@11.1.9/node_modules/swiper/swiper.mjs
  init_live_reload();

  // node_modules/.pnpm/swiper@11.1.9/node_modules/swiper/shared/swiper-core.mjs
  init_live_reload();

  // node_modules/.pnpm/swiper@11.1.9/node_modules/swiper/shared/ssr-window.esm.mjs
  init_live_reload();
  function isObject(obj) {
    return obj !== null && typeof obj === "object" && "constructor" in obj && obj.constructor === Object;
  }
  function extend2(target, src) {
    if (target === void 0) {
      target = {};
    }
    if (src === void 0) {
      src = {};
    }
    Object.keys(src).forEach((key2) => {
      if (typeof target[key2] === "undefined")
        target[key2] = src[key2];
      else if (isObject(src[key2]) && isObject(target[key2]) && Object.keys(src[key2]).length > 0) {
        extend2(target[key2], src[key2]);
      }
    });
  }
  var ssrDocument = {
    body: {},
    addEventListener() {
    },
    removeEventListener() {
    },
    activeElement: {
      blur() {
      },
      nodeName: ""
    },
    querySelector() {
      return null;
    },
    querySelectorAll() {
      return [];
    },
    getElementById() {
      return null;
    },
    createEvent() {
      return {
        initEvent() {
        }
      };
    },
    createElement() {
      return {
        children: [],
        childNodes: [],
        style: {},
        setAttribute() {
        },
        getElementsByTagName() {
          return [];
        }
      };
    },
    createElementNS() {
      return {};
    },
    importNode() {
      return null;
    },
    location: {
      hash: "",
      host: "",
      hostname: "",
      href: "",
      origin: "",
      pathname: "",
      protocol: "",
      search: ""
    }
  };
  function getDocument() {
    const doc = typeof document !== "undefined" ? document : {};
    extend2(doc, ssrDocument);
    return doc;
  }
  var ssrWindow = {
    document: ssrDocument,
    navigator: {
      userAgent: ""
    },
    location: {
      hash: "",
      host: "",
      hostname: "",
      href: "",
      origin: "",
      pathname: "",
      protocol: "",
      search: ""
    },
    history: {
      replaceState() {
      },
      pushState() {
      },
      go() {
      },
      back() {
      }
    },
    CustomEvent: function CustomEvent2() {
      return this;
    },
    addEventListener() {
    },
    removeEventListener() {
    },
    getComputedStyle() {
      return {
        getPropertyValue() {
          return "";
        }
      };
    },
    Image() {
    },
    Date() {
    },
    screen: {},
    setTimeout() {
    },
    clearTimeout() {
    },
    matchMedia() {
      return {};
    },
    requestAnimationFrame(callback) {
      if (typeof setTimeout === "undefined") {
        callback();
        return null;
      }
      return setTimeout(callback, 0);
    },
    cancelAnimationFrame(id) {
      if (typeof setTimeout === "undefined") {
        return;
      }
      clearTimeout(id);
    }
  };
  function getWindow() {
    const win = typeof window !== "undefined" ? window : {};
    extend2(win, ssrWindow);
    return win;
  }

  // node_modules/.pnpm/swiper@11.1.9/node_modules/swiper/shared/utils.mjs
  init_live_reload();
  function classesToTokens(classes2) {
    if (classes2 === void 0) {
      classes2 = "";
    }
    return classes2.trim().split(" ").filter((c4) => !!c4.trim());
  }
  function deleteProps(obj) {
    const object = obj;
    Object.keys(object).forEach((key2) => {
      try {
        object[key2] = null;
      } catch (e8) {
      }
      try {
        delete object[key2];
      } catch (e8) {
      }
    });
  }
  function nextTick(callback, delay) {
    if (delay === void 0) {
      delay = 0;
    }
    return setTimeout(callback, delay);
  }
  function now() {
    return Date.now();
  }
  function getComputedStyle2(el) {
    const window2 = getWindow();
    let style;
    if (window2.getComputedStyle) {
      style = window2.getComputedStyle(el, null);
    }
    if (!style && el.currentStyle) {
      style = el.currentStyle;
    }
    if (!style) {
      style = el.style;
    }
    return style;
  }
  function getTranslate(el, axis) {
    if (axis === void 0) {
      axis = "x";
    }
    const window2 = getWindow();
    let matrix;
    let curTransform;
    let transformMatrix;
    const curStyle = getComputedStyle2(el);
    if (window2.WebKitCSSMatrix) {
      curTransform = curStyle.transform || curStyle.webkitTransform;
      if (curTransform.split(",").length > 6) {
        curTransform = curTransform.split(", ").map((a4) => a4.replace(",", ".")).join(", ");
      }
      transformMatrix = new window2.WebKitCSSMatrix(curTransform === "none" ? "" : curTransform);
    } else {
      transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,");
      matrix = transformMatrix.toString().split(",");
    }
    if (axis === "x") {
      if (window2.WebKitCSSMatrix)
        curTransform = transformMatrix.m41;
      else if (matrix.length === 16)
        curTransform = parseFloat(matrix[12]);
      else
        curTransform = parseFloat(matrix[4]);
    }
    if (axis === "y") {
      if (window2.WebKitCSSMatrix)
        curTransform = transformMatrix.m42;
      else if (matrix.length === 16)
        curTransform = parseFloat(matrix[13]);
      else
        curTransform = parseFloat(matrix[5]);
    }
    return curTransform || 0;
  }
  function isObject2(o7) {
    return typeof o7 === "object" && o7 !== null && o7.constructor && Object.prototype.toString.call(o7).slice(8, -1) === "Object";
  }
  function isNode(node) {
    if (typeof window !== "undefined" && typeof window.HTMLElement !== "undefined") {
      return node instanceof HTMLElement;
    }
    return node && (node.nodeType === 1 || node.nodeType === 11);
  }
  function extend3() {
    const to = Object(arguments.length <= 0 ? void 0 : arguments[0]);
    const noExtend = ["__proto__", "constructor", "prototype"];
    for (let i5 = 1; i5 < arguments.length; i5 += 1) {
      const nextSource = i5 < 0 || arguments.length <= i5 ? void 0 : arguments[i5];
      if (nextSource !== void 0 && nextSource !== null && !isNode(nextSource)) {
        const keysArray = Object.keys(Object(nextSource)).filter((key2) => noExtend.indexOf(key2) < 0);
        for (let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
          const nextKey = keysArray[nextIndex];
          const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
          if (desc !== void 0 && desc.enumerable) {
            if (isObject2(to[nextKey]) && isObject2(nextSource[nextKey])) {
              if (nextSource[nextKey].__swiper__) {
                to[nextKey] = nextSource[nextKey];
              } else {
                extend3(to[nextKey], nextSource[nextKey]);
              }
            } else if (!isObject2(to[nextKey]) && isObject2(nextSource[nextKey])) {
              to[nextKey] = {};
              if (nextSource[nextKey].__swiper__) {
                to[nextKey] = nextSource[nextKey];
              } else {
                extend3(to[nextKey], nextSource[nextKey]);
              }
            } else {
              to[nextKey] = nextSource[nextKey];
            }
          }
        }
      }
    }
    return to;
  }
  function setCSSProperty(el, varName, varValue) {
    el.style.setProperty(varName, varValue);
  }
  function animateCSSModeScroll(_ref) {
    let {
      swiper,
      targetPosition,
      side
    } = _ref;
    const window2 = getWindow();
    const startPosition = -swiper.translate;
    let startTime = null;
    let time;
    const duration = swiper.params.speed;
    swiper.wrapperEl.style.scrollSnapType = "none";
    window2.cancelAnimationFrame(swiper.cssModeFrameID);
    const dir = targetPosition > startPosition ? "next" : "prev";
    const isOutOfBound = (current, target) => {
      return dir === "next" && current >= target || dir === "prev" && current <= target;
    };
    const animate = () => {
      time = (/* @__PURE__ */ new Date()).getTime();
      if (startTime === null) {
        startTime = time;
      }
      const progress = Math.max(Math.min((time - startTime) / duration, 1), 0);
      const easeProgress = 0.5 - Math.cos(progress * Math.PI) / 2;
      let currentPosition = startPosition + easeProgress * (targetPosition - startPosition);
      if (isOutOfBound(currentPosition, targetPosition)) {
        currentPosition = targetPosition;
      }
      swiper.wrapperEl.scrollTo({
        [side]: currentPosition
      });
      if (isOutOfBound(currentPosition, targetPosition)) {
        swiper.wrapperEl.style.overflow = "hidden";
        swiper.wrapperEl.style.scrollSnapType = "";
        setTimeout(() => {
          swiper.wrapperEl.style.overflow = "";
          swiper.wrapperEl.scrollTo({
            [side]: currentPosition
          });
        });
        window2.cancelAnimationFrame(swiper.cssModeFrameID);
        return;
      }
      swiper.cssModeFrameID = window2.requestAnimationFrame(animate);
    };
    animate();
  }
  function elementChildren(element, selector3) {
    if (selector3 === void 0) {
      selector3 = "";
    }
    const children = [...element.children];
    if (element instanceof HTMLSlotElement) {
      children.push(...element.assignedElements());
    }
    if (!selector3) {
      return children;
    }
    return children.filter((el) => el.matches(selector3));
  }
  function elementIsChildOf(el, parent) {
    const isChild = parent.contains(el);
    if (!isChild && parent instanceof HTMLSlotElement) {
      const children = [...parent.assignedElements()];
      return children.includes(el);
    }
    return isChild;
  }
  function showWarning(text) {
    try {
      console.warn(text);
      return;
    } catch (err) {
    }
  }
  function createElement(tag, classes2) {
    if (classes2 === void 0) {
      classes2 = [];
    }
    const el = document.createElement(tag);
    el.classList.add(...Array.isArray(classes2) ? classes2 : classesToTokens(classes2));
    return el;
  }
  function elementPrevAll(el, selector3) {
    const prevEls = [];
    while (el.previousElementSibling) {
      const prev = el.previousElementSibling;
      if (selector3) {
        if (prev.matches(selector3))
          prevEls.push(prev);
      } else
        prevEls.push(prev);
      el = prev;
    }
    return prevEls;
  }
  function elementNextAll(el, selector3) {
    const nextEls = [];
    while (el.nextElementSibling) {
      const next = el.nextElementSibling;
      if (selector3) {
        if (next.matches(selector3))
          nextEls.push(next);
      } else
        nextEls.push(next);
      el = next;
    }
    return nextEls;
  }
  function elementStyle(el, prop2) {
    const window2 = getWindow();
    return window2.getComputedStyle(el, null).getPropertyValue(prop2);
  }
  function elementIndex(el) {
    let child = el;
    let i5;
    if (child) {
      i5 = 0;
      while ((child = child.previousSibling) !== null) {
        if (child.nodeType === 1)
          i5 += 1;
      }
      return i5;
    }
    return void 0;
  }
  function elementParents(el, selector3) {
    const parents = [];
    let parent = el.parentElement;
    while (parent) {
      if (selector3) {
        if (parent.matches(selector3))
          parents.push(parent);
      } else {
        parents.push(parent);
      }
      parent = parent.parentElement;
    }
    return parents;
  }
  function elementOuterSize(el, size2, includeMargins) {
    const window2 = getWindow();
    if (includeMargins) {
      return el[size2 === "width" ? "offsetWidth" : "offsetHeight"] + parseFloat(window2.getComputedStyle(el, null).getPropertyValue(size2 === "width" ? "margin-right" : "margin-top")) + parseFloat(window2.getComputedStyle(el, null).getPropertyValue(size2 === "width" ? "margin-left" : "margin-bottom"));
    }
    return el.offsetWidth;
  }
  function makeElementsArray(el) {
    return (Array.isArray(el) ? el : [el]).filter((e8) => !!e8);
  }

  // node_modules/.pnpm/swiper@11.1.9/node_modules/swiper/shared/swiper-core.mjs
  var support;
  function calcSupport() {
    const window2 = getWindow();
    const document2 = getDocument();
    return {
      smoothScroll: document2.documentElement && document2.documentElement.style && "scrollBehavior" in document2.documentElement.style,
      touch: !!("ontouchstart" in window2 || window2.DocumentTouch && document2 instanceof window2.DocumentTouch)
    };
  }
  function getSupport() {
    if (!support) {
      support = calcSupport();
    }
    return support;
  }
  var deviceCached;
  function calcDevice(_temp) {
    let {
      userAgent
    } = _temp === void 0 ? {} : _temp;
    const support2 = getSupport();
    const window2 = getWindow();
    const platform2 = window2.navigator.platform;
    const ua = userAgent || window2.navigator.userAgent;
    const device = {
      ios: false,
      android: false
    };
    const screenWidth = window2.screen.width;
    const screenHeight = window2.screen.height;
    const android = ua.match(/(Android);?[\s\/]+([\d.]+)?/);
    let ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
    const ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
    const iphone = !ipad && ua.match(/(iPhone\sOS|iOS)\s([\d_]+)/);
    const windows = platform2 === "Win32";
    let macos = platform2 === "MacIntel";
    const iPadScreens = ["1024x1366", "1366x1024", "834x1194", "1194x834", "834x1112", "1112x834", "768x1024", "1024x768", "820x1180", "1180x820", "810x1080", "1080x810"];
    if (!ipad && macos && support2.touch && iPadScreens.indexOf(`${screenWidth}x${screenHeight}`) >= 0) {
      ipad = ua.match(/(Version)\/([\d.]+)/);
      if (!ipad)
        ipad = [0, 1, "13_0_0"];
      macos = false;
    }
    if (android && !windows) {
      device.os = "android";
      device.android = true;
    }
    if (ipad || iphone || ipod) {
      device.os = "ios";
      device.ios = true;
    }
    return device;
  }
  function getDevice(overrides) {
    if (overrides === void 0) {
      overrides = {};
    }
    if (!deviceCached) {
      deviceCached = calcDevice(overrides);
    }
    return deviceCached;
  }
  var browser;
  function calcBrowser() {
    const window2 = getWindow();
    const device = getDevice();
    let needPerspectiveFix = false;
    function isSafari() {
      const ua = window2.navigator.userAgent.toLowerCase();
      return ua.indexOf("safari") >= 0 && ua.indexOf("chrome") < 0 && ua.indexOf("android") < 0;
    }
    if (isSafari()) {
      const ua = String(window2.navigator.userAgent);
      if (ua.includes("Version/")) {
        const [major, minor] = ua.split("Version/")[1].split(" ")[0].split(".").map((num) => Number(num));
        needPerspectiveFix = major < 16 || major === 16 && minor < 2;
      }
    }
    const isWebView = /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window2.navigator.userAgent);
    const isSafariBrowser = isSafari();
    const need3dFix = isSafariBrowser || isWebView && device.ios;
    return {
      isSafari: needPerspectiveFix || isSafariBrowser,
      needPerspectiveFix,
      need3dFix,
      isWebView
    };
  }
  function getBrowser() {
    if (!browser) {
      browser = calcBrowser();
    }
    return browser;
  }
  function Resize(_ref) {
    let {
      swiper,
      on,
      emit
    } = _ref;
    const window2 = getWindow();
    let observer = null;
    let animationFrame = null;
    const resizeHandler = () => {
      if (!swiper || swiper.destroyed || !swiper.initialized)
        return;
      emit("beforeResize");
      emit("resize");
    };
    const createObserver = () => {
      if (!swiper || swiper.destroyed || !swiper.initialized)
        return;
      observer = new ResizeObserver((entries) => {
        animationFrame = window2.requestAnimationFrame(() => {
          const {
            width,
            height
          } = swiper;
          let newWidth = width;
          let newHeight = height;
          entries.forEach((_ref2) => {
            let {
              contentBoxSize,
              contentRect,
              target
            } = _ref2;
            if (target && target !== swiper.el)
              return;
            newWidth = contentRect ? contentRect.width : (contentBoxSize[0] || contentBoxSize).inlineSize;
            newHeight = contentRect ? contentRect.height : (contentBoxSize[0] || contentBoxSize).blockSize;
          });
          if (newWidth !== width || newHeight !== height) {
            resizeHandler();
          }
        });
      });
      observer.observe(swiper.el);
    };
    const removeObserver = () => {
      if (animationFrame) {
        window2.cancelAnimationFrame(animationFrame);
      }
      if (observer && observer.unobserve && swiper.el) {
        observer.unobserve(swiper.el);
        observer = null;
      }
    };
    const orientationChangeHandler = () => {
      if (!swiper || swiper.destroyed || !swiper.initialized)
        return;
      emit("orientationchange");
    };
    on("init", () => {
      if (swiper.params.resizeObserver && typeof window2.ResizeObserver !== "undefined") {
        createObserver();
        return;
      }
      window2.addEventListener("resize", resizeHandler);
      window2.addEventListener("orientationchange", orientationChangeHandler);
    });
    on("destroy", () => {
      removeObserver();
      window2.removeEventListener("resize", resizeHandler);
      window2.removeEventListener("orientationchange", orientationChangeHandler);
    });
  }
  function Observer2(_ref) {
    let {
      swiper,
      extendParams,
      on,
      emit
    } = _ref;
    const observers = [];
    const window2 = getWindow();
    const attach2 = function(target, options) {
      if (options === void 0) {
        options = {};
      }
      const ObserverFunc = window2.MutationObserver || window2.WebkitMutationObserver;
      const observer = new ObserverFunc((mutations) => {
        if (swiper.__preventObserver__)
          return;
        if (mutations.length === 1) {
          emit("observerUpdate", mutations[0]);
          return;
        }
        const observerUpdate = function observerUpdate2() {
          emit("observerUpdate", mutations[0]);
        };
        if (window2.requestAnimationFrame) {
          window2.requestAnimationFrame(observerUpdate);
        } else {
          window2.setTimeout(observerUpdate, 0);
        }
      });
      observer.observe(target, {
        attributes: typeof options.attributes === "undefined" ? true : options.attributes,
        childList: swiper.isElement || (typeof options.childList === "undefined" ? true : options).childList,
        characterData: typeof options.characterData === "undefined" ? true : options.characterData
      });
      observers.push(observer);
    };
    const init5 = () => {
      if (!swiper.params.observer)
        return;
      if (swiper.params.observeParents) {
        const containerParents = elementParents(swiper.hostEl);
        for (let i5 = 0; i5 < containerParents.length; i5 += 1) {
          attach2(containerParents[i5]);
        }
      }
      attach2(swiper.hostEl, {
        childList: swiper.params.observeSlideChildren
      });
      attach2(swiper.wrapperEl, {
        attributes: false
      });
    };
    const destroy = () => {
      observers.forEach((observer) => {
        observer.disconnect();
      });
      observers.splice(0, observers.length);
    };
    extendParams({
      observer: false,
      observeParents: false,
      observeSlideChildren: false
    });
    on("init", init5);
    on("destroy", destroy);
  }
  var eventsEmitter = {
    on(events2, handler, priority) {
      const self = this;
      if (!self.eventsListeners || self.destroyed)
        return self;
      if (typeof handler !== "function")
        return self;
      const method2 = priority ? "unshift" : "push";
      events2.split(" ").forEach((event2) => {
        if (!self.eventsListeners[event2])
          self.eventsListeners[event2] = [];
        self.eventsListeners[event2][method2](handler);
      });
      return self;
    },
    once(events2, handler, priority) {
      const self = this;
      if (!self.eventsListeners || self.destroyed)
        return self;
      if (typeof handler !== "function")
        return self;
      function onceHandler() {
        self.off(events2, onceHandler);
        if (onceHandler.__emitterProxy) {
          delete onceHandler.__emitterProxy;
        }
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        handler.apply(self, args);
      }
      onceHandler.__emitterProxy = handler;
      return self.on(events2, onceHandler, priority);
    },
    onAny(handler, priority) {
      const self = this;
      if (!self.eventsListeners || self.destroyed)
        return self;
      if (typeof handler !== "function")
        return self;
      const method2 = priority ? "unshift" : "push";
      if (self.eventsAnyListeners.indexOf(handler) < 0) {
        self.eventsAnyListeners[method2](handler);
      }
      return self;
    },
    offAny(handler) {
      const self = this;
      if (!self.eventsListeners || self.destroyed)
        return self;
      if (!self.eventsAnyListeners)
        return self;
      const index = self.eventsAnyListeners.indexOf(handler);
      if (index >= 0) {
        self.eventsAnyListeners.splice(index, 1);
      }
      return self;
    },
    off(events2, handler) {
      const self = this;
      if (!self.eventsListeners || self.destroyed)
        return self;
      if (!self.eventsListeners)
        return self;
      events2.split(" ").forEach((event2) => {
        if (typeof handler === "undefined") {
          self.eventsListeners[event2] = [];
        } else if (self.eventsListeners[event2]) {
          self.eventsListeners[event2].forEach((eventHandler, index) => {
            if (eventHandler === handler || eventHandler.__emitterProxy && eventHandler.__emitterProxy === handler) {
              self.eventsListeners[event2].splice(index, 1);
            }
          });
        }
      });
      return self;
    },
    emit() {
      const self = this;
      if (!self.eventsListeners || self.destroyed)
        return self;
      if (!self.eventsListeners)
        return self;
      let events2;
      let data;
      let context3;
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      if (typeof args[0] === "string" || Array.isArray(args[0])) {
        events2 = args[0];
        data = args.slice(1, args.length);
        context3 = self;
      } else {
        events2 = args[0].events;
        data = args[0].data;
        context3 = args[0].context || self;
      }
      data.unshift(context3);
      const eventsArray = Array.isArray(events2) ? events2 : events2.split(" ");
      eventsArray.forEach((event2) => {
        if (self.eventsAnyListeners && self.eventsAnyListeners.length) {
          self.eventsAnyListeners.forEach((eventHandler) => {
            eventHandler.apply(context3, [event2, ...data]);
          });
        }
        if (self.eventsListeners && self.eventsListeners[event2]) {
          self.eventsListeners[event2].forEach((eventHandler) => {
            eventHandler.apply(context3, data);
          });
        }
      });
      return self;
    }
  };
  function updateSize() {
    const swiper = this;
    let width;
    let height;
    const el = swiper.el;
    if (typeof swiper.params.width !== "undefined" && swiper.params.width !== null) {
      width = swiper.params.width;
    } else {
      width = el.clientWidth;
    }
    if (typeof swiper.params.height !== "undefined" && swiper.params.height !== null) {
      height = swiper.params.height;
    } else {
      height = el.clientHeight;
    }
    if (width === 0 && swiper.isHorizontal() || height === 0 && swiper.isVertical()) {
      return;
    }
    width = width - parseInt(elementStyle(el, "padding-left") || 0, 10) - parseInt(elementStyle(el, "padding-right") || 0, 10);
    height = height - parseInt(elementStyle(el, "padding-top") || 0, 10) - parseInt(elementStyle(el, "padding-bottom") || 0, 10);
    if (Number.isNaN(width))
      width = 0;
    if (Number.isNaN(height))
      height = 0;
    Object.assign(swiper, {
      width,
      height,
      size: swiper.isHorizontal() ? width : height
    });
  }
  function updateSlides() {
    const swiper = this;
    function getDirectionPropertyValue(node, label) {
      return parseFloat(node.getPropertyValue(swiper.getDirectionLabel(label)) || 0);
    }
    const params = swiper.params;
    const {
      wrapperEl,
      slidesEl,
      size: swiperSize,
      rtlTranslate: rtl,
      wrongRTL
    } = swiper;
    const isVirtual = swiper.virtual && params.virtual.enabled;
    const previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;
    const slides = elementChildren(slidesEl, `.${swiper.params.slideClass}, swiper-slide`);
    const slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;
    let snapGrid = [];
    const slidesGrid = [];
    const slidesSizesGrid = [];
    let offsetBefore = params.slidesOffsetBefore;
    if (typeof offsetBefore === "function") {
      offsetBefore = params.slidesOffsetBefore.call(swiper);
    }
    let offsetAfter = params.slidesOffsetAfter;
    if (typeof offsetAfter === "function") {
      offsetAfter = params.slidesOffsetAfter.call(swiper);
    }
    const previousSnapGridLength = swiper.snapGrid.length;
    const previousSlidesGridLength = swiper.slidesGrid.length;
    let spaceBetween = params.spaceBetween;
    let slidePosition = -offsetBefore;
    let prevSlideSize = 0;
    let index = 0;
    if (typeof swiperSize === "undefined") {
      return;
    }
    if (typeof spaceBetween === "string" && spaceBetween.indexOf("%") >= 0) {
      spaceBetween = parseFloat(spaceBetween.replace("%", "")) / 100 * swiperSize;
    } else if (typeof spaceBetween === "string") {
      spaceBetween = parseFloat(spaceBetween);
    }
    swiper.virtualSize = -spaceBetween;
    slides.forEach((slideEl) => {
      if (rtl) {
        slideEl.style.marginLeft = "";
      } else {
        slideEl.style.marginRight = "";
      }
      slideEl.style.marginBottom = "";
      slideEl.style.marginTop = "";
    });
    if (params.centeredSlides && params.cssMode) {
      setCSSProperty(wrapperEl, "--swiper-centered-offset-before", "");
      setCSSProperty(wrapperEl, "--swiper-centered-offset-after", "");
    }
    const gridEnabled = params.grid && params.grid.rows > 1 && swiper.grid;
    if (gridEnabled) {
      swiper.grid.initSlides(slides);
    } else if (swiper.grid) {
      swiper.grid.unsetSlides();
    }
    let slideSize;
    const shouldResetSlideSize = params.slidesPerView === "auto" && params.breakpoints && Object.keys(params.breakpoints).filter((key2) => {
      return typeof params.breakpoints[key2].slidesPerView !== "undefined";
    }).length > 0;
    for (let i5 = 0; i5 < slidesLength; i5 += 1) {
      slideSize = 0;
      let slide2;
      if (slides[i5])
        slide2 = slides[i5];
      if (gridEnabled) {
        swiper.grid.updateSlide(i5, slide2, slides);
      }
      if (slides[i5] && elementStyle(slide2, "display") === "none")
        continue;
      if (params.slidesPerView === "auto") {
        if (shouldResetSlideSize) {
          slides[i5].style[swiper.getDirectionLabel("width")] = ``;
        }
        const slideStyles = getComputedStyle(slide2);
        const currentTransform = slide2.style.transform;
        const currentWebKitTransform = slide2.style.webkitTransform;
        if (currentTransform) {
          slide2.style.transform = "none";
        }
        if (currentWebKitTransform) {
          slide2.style.webkitTransform = "none";
        }
        if (params.roundLengths) {
          slideSize = swiper.isHorizontal() ? elementOuterSize(slide2, "width", true) : elementOuterSize(slide2, "height", true);
        } else {
          const width = getDirectionPropertyValue(slideStyles, "width");
          const paddingLeft = getDirectionPropertyValue(slideStyles, "padding-left");
          const paddingRight = getDirectionPropertyValue(slideStyles, "padding-right");
          const marginLeft = getDirectionPropertyValue(slideStyles, "margin-left");
          const marginRight = getDirectionPropertyValue(slideStyles, "margin-right");
          const boxSizing = slideStyles.getPropertyValue("box-sizing");
          if (boxSizing && boxSizing === "border-box") {
            slideSize = width + marginLeft + marginRight;
          } else {
            const {
              clientWidth,
              offsetWidth
            } = slide2;
            slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight + (offsetWidth - clientWidth);
          }
        }
        if (currentTransform) {
          slide2.style.transform = currentTransform;
        }
        if (currentWebKitTransform) {
          slide2.style.webkitTransform = currentWebKitTransform;
        }
        if (params.roundLengths)
          slideSize = Math.floor(slideSize);
      } else {
        slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;
        if (params.roundLengths)
          slideSize = Math.floor(slideSize);
        if (slides[i5]) {
          slides[i5].style[swiper.getDirectionLabel("width")] = `${slideSize}px`;
        }
      }
      if (slides[i5]) {
        slides[i5].swiperSlideSize = slideSize;
      }
      slidesSizesGrid.push(slideSize);
      if (params.centeredSlides) {
        slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;
        if (prevSlideSize === 0 && i5 !== 0)
          slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
        if (i5 === 0)
          slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
        if (Math.abs(slidePosition) < 1 / 1e3)
          slidePosition = 0;
        if (params.roundLengths)
          slidePosition = Math.floor(slidePosition);
        if (index % params.slidesPerGroup === 0)
          snapGrid.push(slidePosition);
        slidesGrid.push(slidePosition);
      } else {
        if (params.roundLengths)
          slidePosition = Math.floor(slidePosition);
        if ((index - Math.min(swiper.params.slidesPerGroupSkip, index)) % swiper.params.slidesPerGroup === 0)
          snapGrid.push(slidePosition);
        slidesGrid.push(slidePosition);
        slidePosition = slidePosition + slideSize + spaceBetween;
      }
      swiper.virtualSize += slideSize + spaceBetween;
      prevSlideSize = slideSize;
      index += 1;
    }
    swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;
    if (rtl && wrongRTL && (params.effect === "slide" || params.effect === "coverflow")) {
      wrapperEl.style.width = `${swiper.virtualSize + spaceBetween}px`;
    }
    if (params.setWrapperSize) {
      wrapperEl.style[swiper.getDirectionLabel("width")] = `${swiper.virtualSize + spaceBetween}px`;
    }
    if (gridEnabled) {
      swiper.grid.updateWrapperSize(slideSize, snapGrid);
    }
    if (!params.centeredSlides) {
      const newSlidesGrid = [];
      for (let i5 = 0; i5 < snapGrid.length; i5 += 1) {
        let slidesGridItem = snapGrid[i5];
        if (params.roundLengths)
          slidesGridItem = Math.floor(slidesGridItem);
        if (snapGrid[i5] <= swiper.virtualSize - swiperSize) {
          newSlidesGrid.push(slidesGridItem);
        }
      }
      snapGrid = newSlidesGrid;
      if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {
        snapGrid.push(swiper.virtualSize - swiperSize);
      }
    }
    if (isVirtual && params.loop) {
      const size2 = slidesSizesGrid[0] + spaceBetween;
      if (params.slidesPerGroup > 1) {
        const groups = Math.ceil((swiper.virtual.slidesBefore + swiper.virtual.slidesAfter) / params.slidesPerGroup);
        const groupSize = size2 * params.slidesPerGroup;
        for (let i5 = 0; i5 < groups; i5 += 1) {
          snapGrid.push(snapGrid[snapGrid.length - 1] + groupSize);
        }
      }
      for (let i5 = 0; i5 < swiper.virtual.slidesBefore + swiper.virtual.slidesAfter; i5 += 1) {
        if (params.slidesPerGroup === 1) {
          snapGrid.push(snapGrid[snapGrid.length - 1] + size2);
        }
        slidesGrid.push(slidesGrid[slidesGrid.length - 1] + size2);
        swiper.virtualSize += size2;
      }
    }
    if (snapGrid.length === 0)
      snapGrid = [0];
    if (spaceBetween !== 0) {
      const key2 = swiper.isHorizontal() && rtl ? "marginLeft" : swiper.getDirectionLabel("marginRight");
      slides.filter((_2, slideIndex) => {
        if (!params.cssMode || params.loop)
          return true;
        if (slideIndex === slides.length - 1) {
          return false;
        }
        return true;
      }).forEach((slideEl) => {
        slideEl.style[key2] = `${spaceBetween}px`;
      });
    }
    if (params.centeredSlides && params.centeredSlidesBounds) {
      let allSlidesSize = 0;
      slidesSizesGrid.forEach((slideSizeValue) => {
        allSlidesSize += slideSizeValue + (spaceBetween || 0);
      });
      allSlidesSize -= spaceBetween;
      const maxSnap = allSlidesSize - swiperSize;
      snapGrid = snapGrid.map((snap3) => {
        if (snap3 <= 0)
          return -offsetBefore;
        if (snap3 > maxSnap)
          return maxSnap + offsetAfter;
        return snap3;
      });
    }
    if (params.centerInsufficientSlides) {
      let allSlidesSize = 0;
      slidesSizesGrid.forEach((slideSizeValue) => {
        allSlidesSize += slideSizeValue + (spaceBetween || 0);
      });
      allSlidesSize -= spaceBetween;
      const offsetSize = (params.slidesOffsetBefore || 0) + (params.slidesOffsetAfter || 0);
      if (allSlidesSize + offsetSize < swiperSize) {
        const allSlidesOffset = (swiperSize - allSlidesSize - offsetSize) / 2;
        snapGrid.forEach((snap3, snapIndex) => {
          snapGrid[snapIndex] = snap3 - allSlidesOffset;
        });
        slidesGrid.forEach((snap3, snapIndex) => {
          slidesGrid[snapIndex] = snap3 + allSlidesOffset;
        });
      }
    }
    Object.assign(swiper, {
      slides,
      snapGrid,
      slidesGrid,
      slidesSizesGrid
    });
    if (params.centeredSlides && params.cssMode && !params.centeredSlidesBounds) {
      setCSSProperty(wrapperEl, "--swiper-centered-offset-before", `${-snapGrid[0]}px`);
      setCSSProperty(wrapperEl, "--swiper-centered-offset-after", `${swiper.size / 2 - slidesSizesGrid[slidesSizesGrid.length - 1] / 2}px`);
      const addToSnapGrid = -swiper.snapGrid[0];
      const addToSlidesGrid = -swiper.slidesGrid[0];
      swiper.snapGrid = swiper.snapGrid.map((v2) => v2 + addToSnapGrid);
      swiper.slidesGrid = swiper.slidesGrid.map((v2) => v2 + addToSlidesGrid);
    }
    if (slidesLength !== previousSlidesLength) {
      swiper.emit("slidesLengthChange");
    }
    if (snapGrid.length !== previousSnapGridLength) {
      if (swiper.params.watchOverflow)
        swiper.checkOverflow();
      swiper.emit("snapGridLengthChange");
    }
    if (slidesGrid.length !== previousSlidesGridLength) {
      swiper.emit("slidesGridLengthChange");
    }
    if (params.watchSlidesProgress) {
      swiper.updateSlidesOffset();
    }
    swiper.emit("slidesUpdated");
    if (!isVirtual && !params.cssMode && (params.effect === "slide" || params.effect === "fade")) {
      const backFaceHiddenClass = `${params.containerModifierClass}backface-hidden`;
      const hasClassBackfaceClassAdded = swiper.el.classList.contains(backFaceHiddenClass);
      if (slidesLength <= params.maxBackfaceHiddenSlides) {
        if (!hasClassBackfaceClassAdded)
          swiper.el.classList.add(backFaceHiddenClass);
      } else if (hasClassBackfaceClassAdded) {
        swiper.el.classList.remove(backFaceHiddenClass);
      }
    }
  }
  function updateAutoHeight(speed) {
    const swiper = this;
    const activeSlides = [];
    const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
    let newHeight = 0;
    let i5;
    if (typeof speed === "number") {
      swiper.setTransition(speed);
    } else if (speed === true) {
      swiper.setTransition(swiper.params.speed);
    }
    const getSlideByIndex = (index) => {
      if (isVirtual) {
        return swiper.slides[swiper.getSlideIndexByData(index)];
      }
      return swiper.slides[index];
    };
    if (swiper.params.slidesPerView !== "auto" && swiper.params.slidesPerView > 1) {
      if (swiper.params.centeredSlides) {
        (swiper.visibleSlides || []).forEach((slide2) => {
          activeSlides.push(slide2);
        });
      } else {
        for (i5 = 0; i5 < Math.ceil(swiper.params.slidesPerView); i5 += 1) {
          const index = swiper.activeIndex + i5;
          if (index > swiper.slides.length && !isVirtual)
            break;
          activeSlides.push(getSlideByIndex(index));
        }
      }
    } else {
      activeSlides.push(getSlideByIndex(swiper.activeIndex));
    }
    for (i5 = 0; i5 < activeSlides.length; i5 += 1) {
      if (typeof activeSlides[i5] !== "undefined") {
        const height = activeSlides[i5].offsetHeight;
        newHeight = height > newHeight ? height : newHeight;
      }
    }
    if (newHeight || newHeight === 0)
      swiper.wrapperEl.style.height = `${newHeight}px`;
  }
  function updateSlidesOffset() {
    const swiper = this;
    const slides = swiper.slides;
    const minusOffset = swiper.isElement ? swiper.isHorizontal() ? swiper.wrapperEl.offsetLeft : swiper.wrapperEl.offsetTop : 0;
    for (let i5 = 0; i5 < slides.length; i5 += 1) {
      slides[i5].swiperSlideOffset = (swiper.isHorizontal() ? slides[i5].offsetLeft : slides[i5].offsetTop) - minusOffset - swiper.cssOverflowAdjustment();
    }
  }
  var toggleSlideClasses$1 = (slideEl, condition, className) => {
    if (condition && !slideEl.classList.contains(className)) {
      slideEl.classList.add(className);
    } else if (!condition && slideEl.classList.contains(className)) {
      slideEl.classList.remove(className);
    }
  };
  function updateSlidesProgress(translate2) {
    if (translate2 === void 0) {
      translate2 = this && this.translate || 0;
    }
    const swiper = this;
    const params = swiper.params;
    const {
      slides,
      rtlTranslate: rtl,
      snapGrid
    } = swiper;
    if (slides.length === 0)
      return;
    if (typeof slides[0].swiperSlideOffset === "undefined")
      swiper.updateSlidesOffset();
    let offsetCenter = -translate2;
    if (rtl)
      offsetCenter = translate2;
    swiper.visibleSlidesIndexes = [];
    swiper.visibleSlides = [];
    let spaceBetween = params.spaceBetween;
    if (typeof spaceBetween === "string" && spaceBetween.indexOf("%") >= 0) {
      spaceBetween = parseFloat(spaceBetween.replace("%", "")) / 100 * swiper.size;
    } else if (typeof spaceBetween === "string") {
      spaceBetween = parseFloat(spaceBetween);
    }
    for (let i5 = 0; i5 < slides.length; i5 += 1) {
      const slide2 = slides[i5];
      let slideOffset = slide2.swiperSlideOffset;
      if (params.cssMode && params.centeredSlides) {
        slideOffset -= slides[0].swiperSlideOffset;
      }
      const slideProgress = (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide2.swiperSlideSize + spaceBetween);
      const originalSlideProgress = (offsetCenter - snapGrid[0] + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide2.swiperSlideSize + spaceBetween);
      const slideBefore = -(offsetCenter - slideOffset);
      const slideAfter = slideBefore + swiper.slidesSizesGrid[i5];
      const isFullyVisible = slideBefore >= 0 && slideBefore <= swiper.size - swiper.slidesSizesGrid[i5];
      const isVisible = slideBefore >= 0 && slideBefore < swiper.size - 1 || slideAfter > 1 && slideAfter <= swiper.size || slideBefore <= 0 && slideAfter >= swiper.size;
      if (isVisible) {
        swiper.visibleSlides.push(slide2);
        swiper.visibleSlidesIndexes.push(i5);
      }
      toggleSlideClasses$1(slide2, isVisible, params.slideVisibleClass);
      toggleSlideClasses$1(slide2, isFullyVisible, params.slideFullyVisibleClass);
      slide2.progress = rtl ? -slideProgress : slideProgress;
      slide2.originalProgress = rtl ? -originalSlideProgress : originalSlideProgress;
    }
  }
  function updateProgress(translate2) {
    const swiper = this;
    if (typeof translate2 === "undefined") {
      const multiplier = swiper.rtlTranslate ? -1 : 1;
      translate2 = swiper && swiper.translate && swiper.translate * multiplier || 0;
    }
    const params = swiper.params;
    const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
    let {
      progress,
      isBeginning,
      isEnd,
      progressLoop
    } = swiper;
    const wasBeginning = isBeginning;
    const wasEnd = isEnd;
    if (translatesDiff === 0) {
      progress = 0;
      isBeginning = true;
      isEnd = true;
    } else {
      progress = (translate2 - swiper.minTranslate()) / translatesDiff;
      const isBeginningRounded = Math.abs(translate2 - swiper.minTranslate()) < 1;
      const isEndRounded = Math.abs(translate2 - swiper.maxTranslate()) < 1;
      isBeginning = isBeginningRounded || progress <= 0;
      isEnd = isEndRounded || progress >= 1;
      if (isBeginningRounded)
        progress = 0;
      if (isEndRounded)
        progress = 1;
    }
    if (params.loop) {
      const firstSlideIndex = swiper.getSlideIndexByData(0);
      const lastSlideIndex = swiper.getSlideIndexByData(swiper.slides.length - 1);
      const firstSlideTranslate = swiper.slidesGrid[firstSlideIndex];
      const lastSlideTranslate = swiper.slidesGrid[lastSlideIndex];
      const translateMax = swiper.slidesGrid[swiper.slidesGrid.length - 1];
      const translateAbs = Math.abs(translate2);
      if (translateAbs >= firstSlideTranslate) {
        progressLoop = (translateAbs - firstSlideTranslate) / translateMax;
      } else {
        progressLoop = (translateAbs + translateMax - lastSlideTranslate) / translateMax;
      }
      if (progressLoop > 1)
        progressLoop -= 1;
    }
    Object.assign(swiper, {
      progress,
      progressLoop,
      isBeginning,
      isEnd
    });
    if (params.watchSlidesProgress || params.centeredSlides && params.autoHeight)
      swiper.updateSlidesProgress(translate2);
    if (isBeginning && !wasBeginning) {
      swiper.emit("reachBeginning toEdge");
    }
    if (isEnd && !wasEnd) {
      swiper.emit("reachEnd toEdge");
    }
    if (wasBeginning && !isBeginning || wasEnd && !isEnd) {
      swiper.emit("fromEdge");
    }
    swiper.emit("progress", progress);
  }
  var toggleSlideClasses = (slideEl, condition, className) => {
    if (condition && !slideEl.classList.contains(className)) {
      slideEl.classList.add(className);
    } else if (!condition && slideEl.classList.contains(className)) {
      slideEl.classList.remove(className);
    }
  };
  function updateSlidesClasses() {
    const swiper = this;
    const {
      slides,
      params,
      slidesEl,
      activeIndex
    } = swiper;
    const isVirtual = swiper.virtual && params.virtual.enabled;
    const gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;
    const getFilteredSlide = (selector3) => {
      return elementChildren(slidesEl, `.${params.slideClass}${selector3}, swiper-slide${selector3}`)[0];
    };
    let activeSlide;
    let prevSlide;
    let nextSlide;
    if (isVirtual) {
      if (params.loop) {
        let slideIndex = activeIndex - swiper.virtual.slidesBefore;
        if (slideIndex < 0)
          slideIndex = swiper.virtual.slides.length + slideIndex;
        if (slideIndex >= swiper.virtual.slides.length)
          slideIndex -= swiper.virtual.slides.length;
        activeSlide = getFilteredSlide(`[data-swiper-slide-index="${slideIndex}"]`);
      } else {
        activeSlide = getFilteredSlide(`[data-swiper-slide-index="${activeIndex}"]`);
      }
    } else {
      if (gridEnabled) {
        activeSlide = slides.filter((slideEl) => slideEl.column === activeIndex)[0];
        nextSlide = slides.filter((slideEl) => slideEl.column === activeIndex + 1)[0];
        prevSlide = slides.filter((slideEl) => slideEl.column === activeIndex - 1)[0];
      } else {
        activeSlide = slides[activeIndex];
      }
    }
    if (activeSlide) {
      if (!gridEnabled) {
        nextSlide = elementNextAll(activeSlide, `.${params.slideClass}, swiper-slide`)[0];
        if (params.loop && !nextSlide) {
          nextSlide = slides[0];
        }
        prevSlide = elementPrevAll(activeSlide, `.${params.slideClass}, swiper-slide`)[0];
        if (params.loop && !prevSlide === 0) {
          prevSlide = slides[slides.length - 1];
        }
      }
    }
    slides.forEach((slideEl) => {
      toggleSlideClasses(slideEl, slideEl === activeSlide, params.slideActiveClass);
      toggleSlideClasses(slideEl, slideEl === nextSlide, params.slideNextClass);
      toggleSlideClasses(slideEl, slideEl === prevSlide, params.slidePrevClass);
    });
    swiper.emitSlidesClasses();
  }
  var processLazyPreloader = (swiper, imageEl) => {
    if (!swiper || swiper.destroyed || !swiper.params)
      return;
    const slideSelector = () => swiper.isElement ? `swiper-slide` : `.${swiper.params.slideClass}`;
    const slideEl = imageEl.closest(slideSelector());
    if (slideEl) {
      let lazyEl = slideEl.querySelector(`.${swiper.params.lazyPreloaderClass}`);
      if (!lazyEl && swiper.isElement) {
        if (slideEl.shadowRoot) {
          lazyEl = slideEl.shadowRoot.querySelector(`.${swiper.params.lazyPreloaderClass}`);
        } else {
          requestAnimationFrame(() => {
            if (slideEl.shadowRoot) {
              lazyEl = slideEl.shadowRoot.querySelector(`.${swiper.params.lazyPreloaderClass}`);
              if (lazyEl)
                lazyEl.remove();
            }
          });
        }
      }
      if (lazyEl)
        lazyEl.remove();
    }
  };
  var unlazy = (swiper, index) => {
    if (!swiper.slides[index])
      return;
    const imageEl = swiper.slides[index].querySelector('[loading="lazy"]');
    if (imageEl)
      imageEl.removeAttribute("loading");
  };
  var preload = (swiper) => {
    if (!swiper || swiper.destroyed || !swiper.params)
      return;
    let amount = swiper.params.lazyPreloadPrevNext;
    const len = swiper.slides.length;
    if (!len || !amount || amount < 0)
      return;
    amount = Math.min(amount, len);
    const slidesPerView = swiper.params.slidesPerView === "auto" ? swiper.slidesPerViewDynamic() : Math.ceil(swiper.params.slidesPerView);
    const activeIndex = swiper.activeIndex;
    if (swiper.params.grid && swiper.params.grid.rows > 1) {
      const activeColumn = activeIndex;
      const preloadColumns = [activeColumn - amount];
      preloadColumns.push(...Array.from({
        length: amount
      }).map((_2, i5) => {
        return activeColumn + slidesPerView + i5;
      }));
      swiper.slides.forEach((slideEl, i5) => {
        if (preloadColumns.includes(slideEl.column))
          unlazy(swiper, i5);
      });
      return;
    }
    const slideIndexLastInView = activeIndex + slidesPerView - 1;
    if (swiper.params.rewind || swiper.params.loop) {
      for (let i5 = activeIndex - amount; i5 <= slideIndexLastInView + amount; i5 += 1) {
        const realIndex = (i5 % len + len) % len;
        if (realIndex < activeIndex || realIndex > slideIndexLastInView)
          unlazy(swiper, realIndex);
      }
    } else {
      for (let i5 = Math.max(activeIndex - amount, 0); i5 <= Math.min(slideIndexLastInView + amount, len - 1); i5 += 1) {
        if (i5 !== activeIndex && (i5 > slideIndexLastInView || i5 < activeIndex)) {
          unlazy(swiper, i5);
        }
      }
    }
  };
  function getActiveIndexByTranslate(swiper) {
    const {
      slidesGrid,
      params
    } = swiper;
    const translate2 = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
    let activeIndex;
    for (let i5 = 0; i5 < slidesGrid.length; i5 += 1) {
      if (typeof slidesGrid[i5 + 1] !== "undefined") {
        if (translate2 >= slidesGrid[i5] && translate2 < slidesGrid[i5 + 1] - (slidesGrid[i5 + 1] - slidesGrid[i5]) / 2) {
          activeIndex = i5;
        } else if (translate2 >= slidesGrid[i5] && translate2 < slidesGrid[i5 + 1]) {
          activeIndex = i5 + 1;
        }
      } else if (translate2 >= slidesGrid[i5]) {
        activeIndex = i5;
      }
    }
    if (params.normalizeSlideIndex) {
      if (activeIndex < 0 || typeof activeIndex === "undefined")
        activeIndex = 0;
    }
    return activeIndex;
  }
  function updateActiveIndex(newActiveIndex) {
    const swiper = this;
    const translate2 = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
    const {
      snapGrid,
      params,
      activeIndex: previousIndex,
      realIndex: previousRealIndex,
      snapIndex: previousSnapIndex
    } = swiper;
    let activeIndex = newActiveIndex;
    let snapIndex;
    const getVirtualRealIndex = (aIndex) => {
      let realIndex2 = aIndex - swiper.virtual.slidesBefore;
      if (realIndex2 < 0) {
        realIndex2 = swiper.virtual.slides.length + realIndex2;
      }
      if (realIndex2 >= swiper.virtual.slides.length) {
        realIndex2 -= swiper.virtual.slides.length;
      }
      return realIndex2;
    };
    if (typeof activeIndex === "undefined") {
      activeIndex = getActiveIndexByTranslate(swiper);
    }
    if (snapGrid.indexOf(translate2) >= 0) {
      snapIndex = snapGrid.indexOf(translate2);
    } else {
      const skip = Math.min(params.slidesPerGroupSkip, activeIndex);
      snapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);
    }
    if (snapIndex >= snapGrid.length)
      snapIndex = snapGrid.length - 1;
    if (activeIndex === previousIndex && !swiper.params.loop) {
      if (snapIndex !== previousSnapIndex) {
        swiper.snapIndex = snapIndex;
        swiper.emit("snapIndexChange");
      }
      return;
    }
    if (activeIndex === previousIndex && swiper.params.loop && swiper.virtual && swiper.params.virtual.enabled) {
      swiper.realIndex = getVirtualRealIndex(activeIndex);
      return;
    }
    const gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;
    let realIndex;
    if (swiper.virtual && params.virtual.enabled && params.loop) {
      realIndex = getVirtualRealIndex(activeIndex);
    } else if (gridEnabled) {
      const firstSlideInColumn = swiper.slides.filter((slideEl) => slideEl.column === activeIndex)[0];
      let activeSlideIndex = parseInt(firstSlideInColumn.getAttribute("data-swiper-slide-index"), 10);
      if (Number.isNaN(activeSlideIndex)) {
        activeSlideIndex = Math.max(swiper.slides.indexOf(firstSlideInColumn), 0);
      }
      realIndex = Math.floor(activeSlideIndex / params.grid.rows);
    } else if (swiper.slides[activeIndex]) {
      const slideIndex = swiper.slides[activeIndex].getAttribute("data-swiper-slide-index");
      if (slideIndex) {
        realIndex = parseInt(slideIndex, 10);
      } else {
        realIndex = activeIndex;
      }
    } else {
      realIndex = activeIndex;
    }
    Object.assign(swiper, {
      previousSnapIndex,
      snapIndex,
      previousRealIndex,
      realIndex,
      previousIndex,
      activeIndex
    });
    if (swiper.initialized) {
      preload(swiper);
    }
    swiper.emit("activeIndexChange");
    swiper.emit("snapIndexChange");
    if (swiper.initialized || swiper.params.runCallbacksOnInit) {
      if (previousRealIndex !== realIndex) {
        swiper.emit("realIndexChange");
      }
      swiper.emit("slideChange");
    }
  }
  function updateClickedSlide(el, path) {
    const swiper = this;
    const params = swiper.params;
    let slide2 = el.closest(`.${params.slideClass}, swiper-slide`);
    if (!slide2 && swiper.isElement && path && path.length > 1 && path.includes(el)) {
      [...path.slice(path.indexOf(el) + 1, path.length)].forEach((pathEl) => {
        if (!slide2 && pathEl.matches && pathEl.matches(`.${params.slideClass}, swiper-slide`)) {
          slide2 = pathEl;
        }
      });
    }
    let slideFound = false;
    let slideIndex;
    if (slide2) {
      for (let i5 = 0; i5 < swiper.slides.length; i5 += 1) {
        if (swiper.slides[i5] === slide2) {
          slideFound = true;
          slideIndex = i5;
          break;
        }
      }
    }
    if (slide2 && slideFound) {
      swiper.clickedSlide = slide2;
      if (swiper.virtual && swiper.params.virtual.enabled) {
        swiper.clickedIndex = parseInt(slide2.getAttribute("data-swiper-slide-index"), 10);
      } else {
        swiper.clickedIndex = slideIndex;
      }
    } else {
      swiper.clickedSlide = void 0;
      swiper.clickedIndex = void 0;
      return;
    }
    if (params.slideToClickedSlide && swiper.clickedIndex !== void 0 && swiper.clickedIndex !== swiper.activeIndex) {
      swiper.slideToClickedSlide();
    }
  }
  var update = {
    updateSize,
    updateSlides,
    updateAutoHeight,
    updateSlidesOffset,
    updateSlidesProgress,
    updateProgress,
    updateSlidesClasses,
    updateActiveIndex,
    updateClickedSlide
  };
  function getSwiperTranslate(axis) {
    if (axis === void 0) {
      axis = this.isHorizontal() ? "x" : "y";
    }
    const swiper = this;
    const {
      params,
      rtlTranslate: rtl,
      translate: translate2,
      wrapperEl
    } = swiper;
    if (params.virtualTranslate) {
      return rtl ? -translate2 : translate2;
    }
    if (params.cssMode) {
      return translate2;
    }
    let currentTranslate = getTranslate(wrapperEl, axis);
    currentTranslate += swiper.cssOverflowAdjustment();
    if (rtl)
      currentTranslate = -currentTranslate;
    return currentTranslate || 0;
  }
  function setTranslate(translate2, byController) {
    const swiper = this;
    const {
      rtlTranslate: rtl,
      params,
      wrapperEl,
      progress
    } = swiper;
    let x2 = 0;
    let y2 = 0;
    const z2 = 0;
    if (swiper.isHorizontal()) {
      x2 = rtl ? -translate2 : translate2;
    } else {
      y2 = translate2;
    }
    if (params.roundLengths) {
      x2 = Math.floor(x2);
      y2 = Math.floor(y2);
    }
    swiper.previousTranslate = swiper.translate;
    swiper.translate = swiper.isHorizontal() ? x2 : y2;
    if (params.cssMode) {
      wrapperEl[swiper.isHorizontal() ? "scrollLeft" : "scrollTop"] = swiper.isHorizontal() ? -x2 : -y2;
    } else if (!params.virtualTranslate) {
      if (swiper.isHorizontal()) {
        x2 -= swiper.cssOverflowAdjustment();
      } else {
        y2 -= swiper.cssOverflowAdjustment();
      }
      wrapperEl.style.transform = `translate3d(${x2}px, ${y2}px, ${z2}px)`;
    }
    let newProgress;
    const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
    if (translatesDiff === 0) {
      newProgress = 0;
    } else {
      newProgress = (translate2 - swiper.minTranslate()) / translatesDiff;
    }
    if (newProgress !== progress) {
      swiper.updateProgress(translate2);
    }
    swiper.emit("setTranslate", swiper.translate, byController);
  }
  function minTranslate() {
    return -this.snapGrid[0];
  }
  function maxTranslate() {
    return -this.snapGrid[this.snapGrid.length - 1];
  }
  function translateTo(translate2, speed, runCallbacks, translateBounds, internal) {
    if (translate2 === void 0) {
      translate2 = 0;
    }
    if (speed === void 0) {
      speed = this.params.speed;
    }
    if (runCallbacks === void 0) {
      runCallbacks = true;
    }
    if (translateBounds === void 0) {
      translateBounds = true;
    }
    const swiper = this;
    const {
      params,
      wrapperEl
    } = swiper;
    if (swiper.animating && params.preventInteractionOnTransition) {
      return false;
    }
    const minTranslate2 = swiper.minTranslate();
    const maxTranslate2 = swiper.maxTranslate();
    let newTranslate;
    if (translateBounds && translate2 > minTranslate2)
      newTranslate = minTranslate2;
    else if (translateBounds && translate2 < maxTranslate2)
      newTranslate = maxTranslate2;
    else
      newTranslate = translate2;
    swiper.updateProgress(newTranslate);
    if (params.cssMode) {
      const isH = swiper.isHorizontal();
      if (speed === 0) {
        wrapperEl[isH ? "scrollLeft" : "scrollTop"] = -newTranslate;
      } else {
        if (!swiper.support.smoothScroll) {
          animateCSSModeScroll({
            swiper,
            targetPosition: -newTranslate,
            side: isH ? "left" : "top"
          });
          return true;
        }
        wrapperEl.scrollTo({
          [isH ? "left" : "top"]: -newTranslate,
          behavior: "smooth"
        });
      }
      return true;
    }
    if (speed === 0) {
      swiper.setTransition(0);
      swiper.setTranslate(newTranslate);
      if (runCallbacks) {
        swiper.emit("beforeTransitionStart", speed, internal);
        swiper.emit("transitionEnd");
      }
    } else {
      swiper.setTransition(speed);
      swiper.setTranslate(newTranslate);
      if (runCallbacks) {
        swiper.emit("beforeTransitionStart", speed, internal);
        swiper.emit("transitionStart");
      }
      if (!swiper.animating) {
        swiper.animating = true;
        if (!swiper.onTranslateToWrapperTransitionEnd) {
          swiper.onTranslateToWrapperTransitionEnd = function transitionEnd2(e8) {
            if (!swiper || swiper.destroyed)
              return;
            if (e8.target !== this)
              return;
            swiper.wrapperEl.removeEventListener("transitionend", swiper.onTranslateToWrapperTransitionEnd);
            swiper.onTranslateToWrapperTransitionEnd = null;
            delete swiper.onTranslateToWrapperTransitionEnd;
            swiper.animating = false;
            if (runCallbacks) {
              swiper.emit("transitionEnd");
            }
          };
        }
        swiper.wrapperEl.addEventListener("transitionend", swiper.onTranslateToWrapperTransitionEnd);
      }
    }
    return true;
  }
  var translate = {
    getTranslate: getSwiperTranslate,
    setTranslate,
    minTranslate,
    maxTranslate,
    translateTo
  };
  function setTransition(duration, byController) {
    const swiper = this;
    if (!swiper.params.cssMode) {
      swiper.wrapperEl.style.transitionDuration = `${duration}ms`;
      swiper.wrapperEl.style.transitionDelay = duration === 0 ? `0ms` : "";
    }
    swiper.emit("setTransition", duration, byController);
  }
  function transitionEmit(_ref) {
    let {
      swiper,
      runCallbacks,
      direction,
      step
    } = _ref;
    const {
      activeIndex,
      previousIndex
    } = swiper;
    let dir = direction;
    if (!dir) {
      if (activeIndex > previousIndex)
        dir = "next";
      else if (activeIndex < previousIndex)
        dir = "prev";
      else
        dir = "reset";
    }
    swiper.emit(`transition${step}`);
    if (runCallbacks && activeIndex !== previousIndex) {
      if (dir === "reset") {
        swiper.emit(`slideResetTransition${step}`);
        return;
      }
      swiper.emit(`slideChangeTransition${step}`);
      if (dir === "next") {
        swiper.emit(`slideNextTransition${step}`);
      } else {
        swiper.emit(`slidePrevTransition${step}`);
      }
    }
  }
  function transitionStart(runCallbacks, direction) {
    if (runCallbacks === void 0) {
      runCallbacks = true;
    }
    const swiper = this;
    const {
      params
    } = swiper;
    if (params.cssMode)
      return;
    if (params.autoHeight) {
      swiper.updateAutoHeight();
    }
    transitionEmit({
      swiper,
      runCallbacks,
      direction,
      step: "Start"
    });
  }
  function transitionEnd(runCallbacks, direction) {
    if (runCallbacks === void 0) {
      runCallbacks = true;
    }
    const swiper = this;
    const {
      params
    } = swiper;
    swiper.animating = false;
    if (params.cssMode)
      return;
    swiper.setTransition(0);
    transitionEmit({
      swiper,
      runCallbacks,
      direction,
      step: "End"
    });
  }
  var transition = {
    setTransition,
    transitionStart,
    transitionEnd
  };
  function slideTo(index, speed, runCallbacks, internal, initial) {
    if (index === void 0) {
      index = 0;
    }
    if (runCallbacks === void 0) {
      runCallbacks = true;
    }
    if (typeof index === "string") {
      index = parseInt(index, 10);
    }
    const swiper = this;
    let slideIndex = index;
    if (slideIndex < 0)
      slideIndex = 0;
    const {
      params,
      snapGrid,
      slidesGrid,
      previousIndex,
      activeIndex,
      rtlTranslate: rtl,
      wrapperEl,
      enabled
    } = swiper;
    if (!enabled && !internal && !initial || swiper.destroyed || swiper.animating && params.preventInteractionOnTransition) {
      return false;
    }
    if (typeof speed === "undefined") {
      speed = swiper.params.speed;
    }
    const skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);
    let snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);
    if (snapIndex >= snapGrid.length)
      snapIndex = snapGrid.length - 1;
    const translate2 = -snapGrid[snapIndex];
    if (params.normalizeSlideIndex) {
      for (let i5 = 0; i5 < slidesGrid.length; i5 += 1) {
        const normalizedTranslate = -Math.floor(translate2 * 100);
        const normalizedGrid = Math.floor(slidesGrid[i5] * 100);
        const normalizedGridNext = Math.floor(slidesGrid[i5 + 1] * 100);
        if (typeof slidesGrid[i5 + 1] !== "undefined") {
          if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext - (normalizedGridNext - normalizedGrid) / 2) {
            slideIndex = i5;
          } else if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext) {
            slideIndex = i5 + 1;
          }
        } else if (normalizedTranslate >= normalizedGrid) {
          slideIndex = i5;
        }
      }
    }
    if (swiper.initialized && slideIndex !== activeIndex) {
      if (!swiper.allowSlideNext && (rtl ? translate2 > swiper.translate && translate2 > swiper.minTranslate() : translate2 < swiper.translate && translate2 < swiper.minTranslate())) {
        return false;
      }
      if (!swiper.allowSlidePrev && translate2 > swiper.translate && translate2 > swiper.maxTranslate()) {
        if ((activeIndex || 0) !== slideIndex) {
          return false;
        }
      }
    }
    if (slideIndex !== (previousIndex || 0) && runCallbacks) {
      swiper.emit("beforeSlideChangeStart");
    }
    swiper.updateProgress(translate2);
    let direction;
    if (slideIndex > activeIndex)
      direction = "next";
    else if (slideIndex < activeIndex)
      direction = "prev";
    else
      direction = "reset";
    if (rtl && -translate2 === swiper.translate || !rtl && translate2 === swiper.translate) {
      swiper.updateActiveIndex(slideIndex);
      if (params.autoHeight) {
        swiper.updateAutoHeight();
      }
      swiper.updateSlidesClasses();
      if (params.effect !== "slide") {
        swiper.setTranslate(translate2);
      }
      if (direction !== "reset") {
        swiper.transitionStart(runCallbacks, direction);
        swiper.transitionEnd(runCallbacks, direction);
      }
      return false;
    }
    if (params.cssMode) {
      const isH = swiper.isHorizontal();
      const t6 = rtl ? translate2 : -translate2;
      if (speed === 0) {
        const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
        if (isVirtual) {
          swiper.wrapperEl.style.scrollSnapType = "none";
          swiper._immediateVirtual = true;
        }
        if (isVirtual && !swiper._cssModeVirtualInitialSet && swiper.params.initialSlide > 0) {
          swiper._cssModeVirtualInitialSet = true;
          requestAnimationFrame(() => {
            wrapperEl[isH ? "scrollLeft" : "scrollTop"] = t6;
          });
        } else {
          wrapperEl[isH ? "scrollLeft" : "scrollTop"] = t6;
        }
        if (isVirtual) {
          requestAnimationFrame(() => {
            swiper.wrapperEl.style.scrollSnapType = "";
            swiper._immediateVirtual = false;
          });
        }
      } else {
        if (!swiper.support.smoothScroll) {
          animateCSSModeScroll({
            swiper,
            targetPosition: t6,
            side: isH ? "left" : "top"
          });
          return true;
        }
        wrapperEl.scrollTo({
          [isH ? "left" : "top"]: t6,
          behavior: "smooth"
        });
      }
      return true;
    }
    swiper.setTransition(speed);
    swiper.setTranslate(translate2);
    swiper.updateActiveIndex(slideIndex);
    swiper.updateSlidesClasses();
    swiper.emit("beforeTransitionStart", speed, internal);
    swiper.transitionStart(runCallbacks, direction);
    if (speed === 0) {
      swiper.transitionEnd(runCallbacks, direction);
    } else if (!swiper.animating) {
      swiper.animating = true;
      if (!swiper.onSlideToWrapperTransitionEnd) {
        swiper.onSlideToWrapperTransitionEnd = function transitionEnd2(e8) {
          if (!swiper || swiper.destroyed)
            return;
          if (e8.target !== this)
            return;
          swiper.wrapperEl.removeEventListener("transitionend", swiper.onSlideToWrapperTransitionEnd);
          swiper.onSlideToWrapperTransitionEnd = null;
          delete swiper.onSlideToWrapperTransitionEnd;
          swiper.transitionEnd(runCallbacks, direction);
        };
      }
      swiper.wrapperEl.addEventListener("transitionend", swiper.onSlideToWrapperTransitionEnd);
    }
    return true;
  }
  function slideToLoop(index, speed, runCallbacks, internal) {
    if (index === void 0) {
      index = 0;
    }
    if (runCallbacks === void 0) {
      runCallbacks = true;
    }
    if (typeof index === "string") {
      const indexAsNumber = parseInt(index, 10);
      index = indexAsNumber;
    }
    const swiper = this;
    if (swiper.destroyed)
      return;
    if (typeof speed === "undefined") {
      speed = swiper.params.speed;
    }
    const gridEnabled = swiper.grid && swiper.params.grid && swiper.params.grid.rows > 1;
    let newIndex = index;
    if (swiper.params.loop) {
      if (swiper.virtual && swiper.params.virtual.enabled) {
        newIndex = newIndex + swiper.virtual.slidesBefore;
      } else {
        let targetSlideIndex;
        if (gridEnabled) {
          const slideIndex = newIndex * swiper.params.grid.rows;
          targetSlideIndex = swiper.slides.filter((slideEl) => slideEl.getAttribute("data-swiper-slide-index") * 1 === slideIndex)[0].column;
        } else {
          targetSlideIndex = swiper.getSlideIndexByData(newIndex);
        }
        const cols = gridEnabled ? Math.ceil(swiper.slides.length / swiper.params.grid.rows) : swiper.slides.length;
        const {
          centeredSlides
        } = swiper.params;
        let slidesPerView = swiper.params.slidesPerView;
        if (slidesPerView === "auto") {
          slidesPerView = swiper.slidesPerViewDynamic();
        } else {
          slidesPerView = Math.ceil(parseFloat(swiper.params.slidesPerView, 10));
          if (centeredSlides && slidesPerView % 2 === 0) {
            slidesPerView = slidesPerView + 1;
          }
        }
        let needLoopFix = cols - targetSlideIndex < slidesPerView;
        if (centeredSlides) {
          needLoopFix = needLoopFix || targetSlideIndex < Math.ceil(slidesPerView / 2);
        }
        if (internal && centeredSlides && swiper.params.slidesPerView !== "auto" && !gridEnabled) {
          needLoopFix = false;
        }
        if (needLoopFix) {
          const direction = centeredSlides ? targetSlideIndex < swiper.activeIndex ? "prev" : "next" : targetSlideIndex - swiper.activeIndex - 1 < swiper.params.slidesPerView ? "next" : "prev";
          swiper.loopFix({
            direction,
            slideTo: true,
            activeSlideIndex: direction === "next" ? targetSlideIndex + 1 : targetSlideIndex - cols + 1,
            slideRealIndex: direction === "next" ? swiper.realIndex : void 0
          });
        }
        if (gridEnabled) {
          const slideIndex = newIndex * swiper.params.grid.rows;
          newIndex = swiper.slides.filter((slideEl) => slideEl.getAttribute("data-swiper-slide-index") * 1 === slideIndex)[0].column;
        } else {
          newIndex = swiper.getSlideIndexByData(newIndex);
        }
      }
    }
    requestAnimationFrame(() => {
      swiper.slideTo(newIndex, speed, runCallbacks, internal);
    });
    return swiper;
  }
  function slideNext(speed, runCallbacks, internal) {
    if (runCallbacks === void 0) {
      runCallbacks = true;
    }
    const swiper = this;
    const {
      enabled,
      params,
      animating
    } = swiper;
    if (!enabled || swiper.destroyed)
      return swiper;
    if (typeof speed === "undefined") {
      speed = swiper.params.speed;
    }
    let perGroup = params.slidesPerGroup;
    if (params.slidesPerView === "auto" && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {
      perGroup = Math.max(swiper.slidesPerViewDynamic("current", true), 1);
    }
    const increment = swiper.activeIndex < params.slidesPerGroupSkip ? 1 : perGroup;
    const isVirtual = swiper.virtual && params.virtual.enabled;
    if (params.loop) {
      if (animating && !isVirtual && params.loopPreventsSliding)
        return false;
      swiper.loopFix({
        direction: "next"
      });
      swiper._clientLeft = swiper.wrapperEl.clientLeft;
      if (swiper.activeIndex === swiper.slides.length - 1 && params.cssMode) {
        requestAnimationFrame(() => {
          swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);
        });
        return true;
      }
    }
    if (params.rewind && swiper.isEnd) {
      return swiper.slideTo(0, speed, runCallbacks, internal);
    }
    return swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);
  }
  function slidePrev(speed, runCallbacks, internal) {
    if (runCallbacks === void 0) {
      runCallbacks = true;
    }
    const swiper = this;
    const {
      params,
      snapGrid,
      slidesGrid,
      rtlTranslate,
      enabled,
      animating
    } = swiper;
    if (!enabled || swiper.destroyed)
      return swiper;
    if (typeof speed === "undefined") {
      speed = swiper.params.speed;
    }
    const isVirtual = swiper.virtual && params.virtual.enabled;
    if (params.loop) {
      if (animating && !isVirtual && params.loopPreventsSliding)
        return false;
      swiper.loopFix({
        direction: "prev"
      });
      swiper._clientLeft = swiper.wrapperEl.clientLeft;
    }
    const translate2 = rtlTranslate ? swiper.translate : -swiper.translate;
    function normalize3(val) {
      if (val < 0)
        return -Math.floor(Math.abs(val));
      return Math.floor(val);
    }
    const normalizedTranslate = normalize3(translate2);
    const normalizedSnapGrid = snapGrid.map((val) => normalize3(val));
    let prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];
    if (typeof prevSnap === "undefined" && params.cssMode) {
      let prevSnapIndex;
      snapGrid.forEach((snap3, snapIndex) => {
        if (normalizedTranslate >= snap3) {
          prevSnapIndex = snapIndex;
        }
      });
      if (typeof prevSnapIndex !== "undefined") {
        prevSnap = snapGrid[prevSnapIndex > 0 ? prevSnapIndex - 1 : prevSnapIndex];
      }
    }
    let prevIndex = 0;
    if (typeof prevSnap !== "undefined") {
      prevIndex = slidesGrid.indexOf(prevSnap);
      if (prevIndex < 0)
        prevIndex = swiper.activeIndex - 1;
      if (params.slidesPerView === "auto" && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {
        prevIndex = prevIndex - swiper.slidesPerViewDynamic("previous", true) + 1;
        prevIndex = Math.max(prevIndex, 0);
      }
    }
    if (params.rewind && swiper.isBeginning) {
      const lastIndex = swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;
      return swiper.slideTo(lastIndex, speed, runCallbacks, internal);
    } else if (params.loop && swiper.activeIndex === 0 && params.cssMode) {
      requestAnimationFrame(() => {
        swiper.slideTo(prevIndex, speed, runCallbacks, internal);
      });
      return true;
    }
    return swiper.slideTo(prevIndex, speed, runCallbacks, internal);
  }
  function slideReset(speed, runCallbacks, internal) {
    if (runCallbacks === void 0) {
      runCallbacks = true;
    }
    const swiper = this;
    if (swiper.destroyed)
      return;
    if (typeof speed === "undefined") {
      speed = swiper.params.speed;
    }
    return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);
  }
  function slideToClosest(speed, runCallbacks, internal, threshold) {
    if (runCallbacks === void 0) {
      runCallbacks = true;
    }
    if (threshold === void 0) {
      threshold = 0.5;
    }
    const swiper = this;
    if (swiper.destroyed)
      return;
    if (typeof speed === "undefined") {
      speed = swiper.params.speed;
    }
    let index = swiper.activeIndex;
    const skip = Math.min(swiper.params.slidesPerGroupSkip, index);
    const snapIndex = skip + Math.floor((index - skip) / swiper.params.slidesPerGroup);
    const translate2 = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
    if (translate2 >= swiper.snapGrid[snapIndex]) {
      const currentSnap = swiper.snapGrid[snapIndex];
      const nextSnap = swiper.snapGrid[snapIndex + 1];
      if (translate2 - currentSnap > (nextSnap - currentSnap) * threshold) {
        index += swiper.params.slidesPerGroup;
      }
    } else {
      const prevSnap = swiper.snapGrid[snapIndex - 1];
      const currentSnap = swiper.snapGrid[snapIndex];
      if (translate2 - prevSnap <= (currentSnap - prevSnap) * threshold) {
        index -= swiper.params.slidesPerGroup;
      }
    }
    index = Math.max(index, 0);
    index = Math.min(index, swiper.slidesGrid.length - 1);
    return swiper.slideTo(index, speed, runCallbacks, internal);
  }
  function slideToClickedSlide() {
    const swiper = this;
    if (swiper.destroyed)
      return;
    const {
      params,
      slidesEl
    } = swiper;
    const slidesPerView = params.slidesPerView === "auto" ? swiper.slidesPerViewDynamic() : params.slidesPerView;
    let slideToIndex = swiper.clickedIndex;
    let realIndex;
    const slideSelector = swiper.isElement ? `swiper-slide` : `.${params.slideClass}`;
    if (params.loop) {
      if (swiper.animating)
        return;
      realIndex = parseInt(swiper.clickedSlide.getAttribute("data-swiper-slide-index"), 10);
      if (params.centeredSlides) {
        if (slideToIndex < swiper.loopedSlides - slidesPerView / 2 || slideToIndex > swiper.slides.length - swiper.loopedSlides + slidesPerView / 2) {
          swiper.loopFix();
          slideToIndex = swiper.getSlideIndex(elementChildren(slidesEl, `${slideSelector}[data-swiper-slide-index="${realIndex}"]`)[0]);
          nextTick(() => {
            swiper.slideTo(slideToIndex);
          });
        } else {
          swiper.slideTo(slideToIndex);
        }
      } else if (slideToIndex > swiper.slides.length - slidesPerView) {
        swiper.loopFix();
        slideToIndex = swiper.getSlideIndex(elementChildren(slidesEl, `${slideSelector}[data-swiper-slide-index="${realIndex}"]`)[0]);
        nextTick(() => {
          swiper.slideTo(slideToIndex);
        });
      } else {
        swiper.slideTo(slideToIndex);
      }
    } else {
      swiper.slideTo(slideToIndex);
    }
  }
  var slide = {
    slideTo,
    slideToLoop,
    slideNext,
    slidePrev,
    slideReset,
    slideToClosest,
    slideToClickedSlide
  };
  function loopCreate(slideRealIndex) {
    const swiper = this;
    const {
      params,
      slidesEl
    } = swiper;
    if (!params.loop || swiper.virtual && swiper.params.virtual.enabled)
      return;
    const initSlides = () => {
      const slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);
      slides.forEach((el, index) => {
        el.setAttribute("data-swiper-slide-index", index);
      });
    };
    const gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;
    const slidesPerGroup = params.slidesPerGroup * (gridEnabled ? params.grid.rows : 1);
    const shouldFillGroup = swiper.slides.length % slidesPerGroup !== 0;
    const shouldFillGrid = gridEnabled && swiper.slides.length % params.grid.rows !== 0;
    const addBlankSlides = (amountOfSlides) => {
      for (let i5 = 0; i5 < amountOfSlides; i5 += 1) {
        const slideEl = swiper.isElement ? createElement("swiper-slide", [params.slideBlankClass]) : createElement("div", [params.slideClass, params.slideBlankClass]);
        swiper.slidesEl.append(slideEl);
      }
    };
    if (shouldFillGroup) {
      if (params.loopAddBlankSlides) {
        const slidesToAdd = slidesPerGroup - swiper.slides.length % slidesPerGroup;
        addBlankSlides(slidesToAdd);
        swiper.recalcSlides();
        swiper.updateSlides();
      } else {
        showWarning("Swiper Loop Warning: The number of slides is not even to slidesPerGroup, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)");
      }
      initSlides();
    } else if (shouldFillGrid) {
      if (params.loopAddBlankSlides) {
        const slidesToAdd = params.grid.rows - swiper.slides.length % params.grid.rows;
        addBlankSlides(slidesToAdd);
        swiper.recalcSlides();
        swiper.updateSlides();
      } else {
        showWarning("Swiper Loop Warning: The number of slides is not even to grid.rows, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)");
      }
      initSlides();
    } else {
      initSlides();
    }
    swiper.loopFix({
      slideRealIndex,
      direction: params.centeredSlides ? void 0 : "next"
    });
  }
  function loopFix(_temp) {
    let {
      slideRealIndex,
      slideTo: slideTo2 = true,
      direction,
      setTranslate: setTranslate2,
      activeSlideIndex,
      byController,
      byMousewheel
    } = _temp === void 0 ? {} : _temp;
    const swiper = this;
    if (!swiper.params.loop)
      return;
    swiper.emit("beforeLoopFix");
    const {
      slides,
      allowSlidePrev,
      allowSlideNext,
      slidesEl,
      params
    } = swiper;
    const {
      centeredSlides
    } = params;
    swiper.allowSlidePrev = true;
    swiper.allowSlideNext = true;
    if (swiper.virtual && params.virtual.enabled) {
      if (slideTo2) {
        if (!params.centeredSlides && swiper.snapIndex === 0) {
          swiper.slideTo(swiper.virtual.slides.length, 0, false, true);
        } else if (params.centeredSlides && swiper.snapIndex < params.slidesPerView) {
          swiper.slideTo(swiper.virtual.slides.length + swiper.snapIndex, 0, false, true);
        } else if (swiper.snapIndex === swiper.snapGrid.length - 1) {
          swiper.slideTo(swiper.virtual.slidesBefore, 0, false, true);
        }
      }
      swiper.allowSlidePrev = allowSlidePrev;
      swiper.allowSlideNext = allowSlideNext;
      swiper.emit("loopFix");
      return;
    }
    let slidesPerView = params.slidesPerView;
    if (slidesPerView === "auto") {
      slidesPerView = swiper.slidesPerViewDynamic();
    } else {
      slidesPerView = Math.ceil(parseFloat(params.slidesPerView, 10));
      if (centeredSlides && slidesPerView % 2 === 0) {
        slidesPerView = slidesPerView + 1;
      }
    }
    const slidesPerGroup = params.slidesPerGroupAuto ? slidesPerView : params.slidesPerGroup;
    let loopedSlides = slidesPerGroup;
    if (loopedSlides % slidesPerGroup !== 0) {
      loopedSlides += slidesPerGroup - loopedSlides % slidesPerGroup;
    }
    loopedSlides += params.loopAdditionalSlides;
    swiper.loopedSlides = loopedSlides;
    const gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;
    if (slides.length < slidesPerView + loopedSlides) {
      showWarning("Swiper Loop Warning: The number of slides is not enough for loop mode, it will be disabled and not function properly. You need to add more slides (or make duplicates) or lower the values of slidesPerView and slidesPerGroup parameters");
    } else if (gridEnabled && params.grid.fill === "row") {
      showWarning("Swiper Loop Warning: Loop mode is not compatible with grid.fill = `row`");
    }
    const prependSlidesIndexes = [];
    const appendSlidesIndexes = [];
    let activeIndex = swiper.activeIndex;
    if (typeof activeSlideIndex === "undefined") {
      activeSlideIndex = swiper.getSlideIndex(slides.filter((el) => el.classList.contains(params.slideActiveClass))[0]);
    } else {
      activeIndex = activeSlideIndex;
    }
    const isNext = direction === "next" || !direction;
    const isPrev = direction === "prev" || !direction;
    let slidesPrepended = 0;
    let slidesAppended = 0;
    const cols = gridEnabled ? Math.ceil(slides.length / params.grid.rows) : slides.length;
    const activeColIndex = gridEnabled ? slides[activeSlideIndex].column : activeSlideIndex;
    const activeColIndexWithShift = activeColIndex + (centeredSlides && typeof setTranslate2 === "undefined" ? -slidesPerView / 2 + 0.5 : 0);
    if (activeColIndexWithShift < loopedSlides) {
      slidesPrepended = Math.max(loopedSlides - activeColIndexWithShift, slidesPerGroup);
      for (let i5 = 0; i5 < loopedSlides - activeColIndexWithShift; i5 += 1) {
        const index = i5 - Math.floor(i5 / cols) * cols;
        if (gridEnabled) {
          const colIndexToPrepend = cols - index - 1;
          for (let i6 = slides.length - 1; i6 >= 0; i6 -= 1) {
            if (slides[i6].column === colIndexToPrepend)
              prependSlidesIndexes.push(i6);
          }
        } else {
          prependSlidesIndexes.push(cols - index - 1);
        }
      }
    } else if (activeColIndexWithShift + slidesPerView > cols - loopedSlides) {
      slidesAppended = Math.max(activeColIndexWithShift - (cols - loopedSlides * 2), slidesPerGroup);
      for (let i5 = 0; i5 < slidesAppended; i5 += 1) {
        const index = i5 - Math.floor(i5 / cols) * cols;
        if (gridEnabled) {
          slides.forEach((slide2, slideIndex) => {
            if (slide2.column === index)
              appendSlidesIndexes.push(slideIndex);
          });
        } else {
          appendSlidesIndexes.push(index);
        }
      }
    }
    swiper.__preventObserver__ = true;
    requestAnimationFrame(() => {
      swiper.__preventObserver__ = false;
    });
    if (isPrev) {
      prependSlidesIndexes.forEach((index) => {
        slides[index].swiperLoopMoveDOM = true;
        slidesEl.prepend(slides[index]);
        slides[index].swiperLoopMoveDOM = false;
      });
    }
    if (isNext) {
      appendSlidesIndexes.forEach((index) => {
        slides[index].swiperLoopMoveDOM = true;
        slidesEl.append(slides[index]);
        slides[index].swiperLoopMoveDOM = false;
      });
    }
    swiper.recalcSlides();
    if (params.slidesPerView === "auto") {
      swiper.updateSlides();
    } else if (gridEnabled && (prependSlidesIndexes.length > 0 && isPrev || appendSlidesIndexes.length > 0 && isNext)) {
      swiper.slides.forEach((slide2, slideIndex) => {
        swiper.grid.updateSlide(slideIndex, slide2, swiper.slides);
      });
    }
    if (params.watchSlidesProgress) {
      swiper.updateSlidesOffset();
    }
    if (slideTo2) {
      if (prependSlidesIndexes.length > 0 && isPrev) {
        if (typeof slideRealIndex === "undefined") {
          const currentSlideTranslate = swiper.slidesGrid[activeIndex];
          const newSlideTranslate = swiper.slidesGrid[activeIndex + slidesPrepended];
          const diff = newSlideTranslate - currentSlideTranslate;
          if (byMousewheel) {
            swiper.setTranslate(swiper.translate - diff);
          } else {
            swiper.slideTo(activeIndex + Math.ceil(slidesPrepended), 0, false, true);
            if (setTranslate2) {
              swiper.touchEventsData.startTranslate = swiper.touchEventsData.startTranslate - diff;
              swiper.touchEventsData.currentTranslate = swiper.touchEventsData.currentTranslate - diff;
            }
          }
        } else {
          if (setTranslate2) {
            const shift3 = gridEnabled ? prependSlidesIndexes.length / params.grid.rows : prependSlidesIndexes.length;
            swiper.slideTo(swiper.activeIndex + shift3, 0, false, true);
            swiper.touchEventsData.currentTranslate = swiper.translate;
          }
        }
      } else if (appendSlidesIndexes.length > 0 && isNext) {
        if (typeof slideRealIndex === "undefined") {
          const currentSlideTranslate = swiper.slidesGrid[activeIndex];
          const newSlideTranslate = swiper.slidesGrid[activeIndex - slidesAppended];
          const diff = newSlideTranslate - currentSlideTranslate;
          if (byMousewheel) {
            swiper.setTranslate(swiper.translate - diff);
          } else {
            swiper.slideTo(activeIndex - slidesAppended, 0, false, true);
            if (setTranslate2) {
              swiper.touchEventsData.startTranslate = swiper.touchEventsData.startTranslate - diff;
              swiper.touchEventsData.currentTranslate = swiper.touchEventsData.currentTranslate - diff;
            }
          }
        } else {
          const shift3 = gridEnabled ? appendSlidesIndexes.length / params.grid.rows : appendSlidesIndexes.length;
          swiper.slideTo(swiper.activeIndex - shift3, 0, false, true);
        }
      }
    }
    swiper.allowSlidePrev = allowSlidePrev;
    swiper.allowSlideNext = allowSlideNext;
    if (swiper.controller && swiper.controller.control && !byController) {
      const loopParams = {
        slideRealIndex,
        direction,
        setTranslate: setTranslate2,
        activeSlideIndex,
        byController: true
      };
      if (Array.isArray(swiper.controller.control)) {
        swiper.controller.control.forEach((c4) => {
          if (!c4.destroyed && c4.params.loop)
            c4.loopFix({
              ...loopParams,
              slideTo: c4.params.slidesPerView === params.slidesPerView ? slideTo2 : false
            });
        });
      } else if (swiper.controller.control instanceof swiper.constructor && swiper.controller.control.params.loop) {
        swiper.controller.control.loopFix({
          ...loopParams,
          slideTo: swiper.controller.control.params.slidesPerView === params.slidesPerView ? slideTo2 : false
        });
      }
    }
    swiper.emit("loopFix");
  }
  function loopDestroy() {
    const swiper = this;
    const {
      params,
      slidesEl
    } = swiper;
    if (!params.loop || swiper.virtual && swiper.params.virtual.enabled)
      return;
    swiper.recalcSlides();
    const newSlidesOrder = [];
    swiper.slides.forEach((slideEl) => {
      const index = typeof slideEl.swiperSlideIndex === "undefined" ? slideEl.getAttribute("data-swiper-slide-index") * 1 : slideEl.swiperSlideIndex;
      newSlidesOrder[index] = slideEl;
    });
    swiper.slides.forEach((slideEl) => {
      slideEl.removeAttribute("data-swiper-slide-index");
    });
    newSlidesOrder.forEach((slideEl) => {
      slidesEl.append(slideEl);
    });
    swiper.recalcSlides();
    swiper.slideTo(swiper.realIndex, 0);
  }
  var loop = {
    loopCreate,
    loopFix,
    loopDestroy
  };
  function setGrabCursor(moving) {
    const swiper = this;
    if (!swiper.params.simulateTouch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode)
      return;
    const el = swiper.params.touchEventsTarget === "container" ? swiper.el : swiper.wrapperEl;
    if (swiper.isElement) {
      swiper.__preventObserver__ = true;
    }
    el.style.cursor = "move";
    el.style.cursor = moving ? "grabbing" : "grab";
    if (swiper.isElement) {
      requestAnimationFrame(() => {
        swiper.__preventObserver__ = false;
      });
    }
  }
  function unsetGrabCursor() {
    const swiper = this;
    if (swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) {
      return;
    }
    if (swiper.isElement) {
      swiper.__preventObserver__ = true;
    }
    swiper[swiper.params.touchEventsTarget === "container" ? "el" : "wrapperEl"].style.cursor = "";
    if (swiper.isElement) {
      requestAnimationFrame(() => {
        swiper.__preventObserver__ = false;
      });
    }
  }
  var grabCursor = {
    setGrabCursor,
    unsetGrabCursor
  };
  function closestElement(selector3, base) {
    if (base === void 0) {
      base = this;
    }
    function __closestFrom(el) {
      if (!el || el === getDocument() || el === getWindow())
        return null;
      if (el.assignedSlot)
        el = el.assignedSlot;
      const found = el.closest(selector3);
      if (!found && !el.getRootNode) {
        return null;
      }
      return found || __closestFrom(el.getRootNode().host);
    }
    return __closestFrom(base);
  }
  function preventEdgeSwipe(swiper, event2, startX) {
    const window2 = getWindow();
    const {
      params
    } = swiper;
    const edgeSwipeDetection = params.edgeSwipeDetection;
    const edgeSwipeThreshold = params.edgeSwipeThreshold;
    if (edgeSwipeDetection && (startX <= edgeSwipeThreshold || startX >= window2.innerWidth - edgeSwipeThreshold)) {
      if (edgeSwipeDetection === "prevent") {
        event2.preventDefault();
        return true;
      }
      return false;
    }
    return true;
  }
  function onTouchStart(event2) {
    const swiper = this;
    const document2 = getDocument();
    let e8 = event2;
    if (e8.originalEvent)
      e8 = e8.originalEvent;
    const data = swiper.touchEventsData;
    if (e8.type === "pointerdown") {
      if (data.pointerId !== null && data.pointerId !== e8.pointerId) {
        return;
      }
      data.pointerId = e8.pointerId;
    } else if (e8.type === "touchstart" && e8.targetTouches.length === 1) {
      data.touchId = e8.targetTouches[0].identifier;
    }
    if (e8.type === "touchstart") {
      preventEdgeSwipe(swiper, e8, e8.targetTouches[0].pageX);
      return;
    }
    const {
      params,
      touches,
      enabled
    } = swiper;
    if (!enabled)
      return;
    if (!params.simulateTouch && e8.pointerType === "mouse")
      return;
    if (swiper.animating && params.preventInteractionOnTransition) {
      return;
    }
    if (!swiper.animating && params.cssMode && params.loop) {
      swiper.loopFix();
    }
    let targetEl = e8.target;
    if (params.touchEventsTarget === "wrapper") {
      if (!elementIsChildOf(targetEl, swiper.wrapperEl))
        return;
    }
    if ("which" in e8 && e8.which === 3)
      return;
    if ("button" in e8 && e8.button > 0)
      return;
    if (data.isTouched && data.isMoved)
      return;
    const swipingClassHasValue = !!params.noSwipingClass && params.noSwipingClass !== "";
    const eventPath = e8.composedPath ? e8.composedPath() : e8.path;
    if (swipingClassHasValue && e8.target && e8.target.shadowRoot && eventPath) {
      targetEl = eventPath[0];
    }
    const noSwipingSelector = params.noSwipingSelector ? params.noSwipingSelector : `.${params.noSwipingClass}`;
    const isTargetShadow = !!(e8.target && e8.target.shadowRoot);
    if (params.noSwiping && (isTargetShadow ? closestElement(noSwipingSelector, targetEl) : targetEl.closest(noSwipingSelector))) {
      swiper.allowClick = true;
      return;
    }
    if (params.swipeHandler) {
      if (!targetEl.closest(params.swipeHandler))
        return;
    }
    touches.currentX = e8.pageX;
    touches.currentY = e8.pageY;
    const startX = touches.currentX;
    const startY = touches.currentY;
    if (!preventEdgeSwipe(swiper, e8, startX)) {
      return;
    }
    Object.assign(data, {
      isTouched: true,
      isMoved: false,
      allowTouchCallbacks: true,
      isScrolling: void 0,
      startMoving: void 0
    });
    touches.startX = startX;
    touches.startY = startY;
    data.touchStartTime = now();
    swiper.allowClick = true;
    swiper.updateSize();
    swiper.swipeDirection = void 0;
    if (params.threshold > 0)
      data.allowThresholdMove = false;
    let preventDefault = true;
    if (targetEl.matches(data.focusableElements)) {
      preventDefault = false;
      if (targetEl.nodeName === "SELECT") {
        data.isTouched = false;
      }
    }
    if (document2.activeElement && document2.activeElement.matches(data.focusableElements) && document2.activeElement !== targetEl) {
      document2.activeElement.blur();
    }
    const shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;
    if ((params.touchStartForcePreventDefault || shouldPreventDefault) && !targetEl.isContentEditable) {
      e8.preventDefault();
    }
    if (params.freeMode && params.freeMode.enabled && swiper.freeMode && swiper.animating && !params.cssMode) {
      swiper.freeMode.onTouchStart();
    }
    swiper.emit("touchStart", e8);
  }
  function onTouchMove(event2) {
    const document2 = getDocument();
    const swiper = this;
    const data = swiper.touchEventsData;
    const {
      params,
      touches,
      rtlTranslate: rtl,
      enabled
    } = swiper;
    if (!enabled)
      return;
    if (!params.simulateTouch && event2.pointerType === "mouse")
      return;
    let e8 = event2;
    if (e8.originalEvent)
      e8 = e8.originalEvent;
    if (e8.type === "pointermove") {
      if (data.touchId !== null)
        return;
      const id = e8.pointerId;
      if (id !== data.pointerId)
        return;
    }
    let targetTouch;
    if (e8.type === "touchmove") {
      targetTouch = [...e8.changedTouches].filter((t6) => t6.identifier === data.touchId)[0];
      if (!targetTouch || targetTouch.identifier !== data.touchId)
        return;
    } else {
      targetTouch = e8;
    }
    if (!data.isTouched) {
      if (data.startMoving && data.isScrolling) {
        swiper.emit("touchMoveOpposite", e8);
      }
      return;
    }
    const pageX = targetTouch.pageX;
    const pageY = targetTouch.pageY;
    if (e8.preventedByNestedSwiper) {
      touches.startX = pageX;
      touches.startY = pageY;
      return;
    }
    if (!swiper.allowTouchMove) {
      if (!e8.target.matches(data.focusableElements)) {
        swiper.allowClick = false;
      }
      if (data.isTouched) {
        Object.assign(touches, {
          startX: pageX,
          startY: pageY,
          currentX: pageX,
          currentY: pageY
        });
        data.touchStartTime = now();
      }
      return;
    }
    if (params.touchReleaseOnEdges && !params.loop) {
      if (swiper.isVertical()) {
        if (pageY < touches.startY && swiper.translate <= swiper.maxTranslate() || pageY > touches.startY && swiper.translate >= swiper.minTranslate()) {
          data.isTouched = false;
          data.isMoved = false;
          return;
        }
      } else if (pageX < touches.startX && swiper.translate <= swiper.maxTranslate() || pageX > touches.startX && swiper.translate >= swiper.minTranslate()) {
        return;
      }
    }
    if (document2.activeElement) {
      if (e8.target === document2.activeElement && e8.target.matches(data.focusableElements)) {
        data.isMoved = true;
        swiper.allowClick = false;
        return;
      }
    }
    if (data.allowTouchCallbacks) {
      swiper.emit("touchMove", e8);
    }
    touches.previousX = touches.currentX;
    touches.previousY = touches.currentY;
    touches.currentX = pageX;
    touches.currentY = pageY;
    const diffX = touches.currentX - touches.startX;
    const diffY = touches.currentY - touches.startY;
    if (swiper.params.threshold && Math.sqrt(diffX ** 2 + diffY ** 2) < swiper.params.threshold)
      return;
    if (typeof data.isScrolling === "undefined") {
      let touchAngle;
      if (swiper.isHorizontal() && touches.currentY === touches.startY || swiper.isVertical() && touches.currentX === touches.startX) {
        data.isScrolling = false;
      } else {
        if (diffX * diffX + diffY * diffY >= 25) {
          touchAngle = Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180 / Math.PI;
          data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : 90 - touchAngle > params.touchAngle;
        }
      }
    }
    if (data.isScrolling) {
      swiper.emit("touchMoveOpposite", e8);
    }
    if (typeof data.startMoving === "undefined") {
      if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {
        data.startMoving = true;
      }
    }
    if (data.isScrolling || e8.type === "touchmove" && data.preventTouchMoveFromPointerMove) {
      data.isTouched = false;
      return;
    }
    if (!data.startMoving) {
      return;
    }
    swiper.allowClick = false;
    if (!params.cssMode && e8.cancelable) {
      e8.preventDefault();
    }
    if (params.touchMoveStopPropagation && !params.nested) {
      e8.stopPropagation();
    }
    let diff = swiper.isHorizontal() ? diffX : diffY;
    let touchesDiff = swiper.isHorizontal() ? touches.currentX - touches.previousX : touches.currentY - touches.previousY;
    if (params.oneWayMovement) {
      diff = Math.abs(diff) * (rtl ? 1 : -1);
      touchesDiff = Math.abs(touchesDiff) * (rtl ? 1 : -1);
    }
    touches.diff = diff;
    diff *= params.touchRatio;
    if (rtl) {
      diff = -diff;
      touchesDiff = -touchesDiff;
    }
    const prevTouchesDirection = swiper.touchesDirection;
    swiper.swipeDirection = diff > 0 ? "prev" : "next";
    swiper.touchesDirection = touchesDiff > 0 ? "prev" : "next";
    const isLoop = swiper.params.loop && !params.cssMode;
    const allowLoopFix = swiper.touchesDirection === "next" && swiper.allowSlideNext || swiper.touchesDirection === "prev" && swiper.allowSlidePrev;
    if (!data.isMoved) {
      if (isLoop && allowLoopFix) {
        swiper.loopFix({
          direction: swiper.swipeDirection
        });
      }
      data.startTranslate = swiper.getTranslate();
      swiper.setTransition(0);
      if (swiper.animating) {
        const evt = new window.CustomEvent("transitionend", {
          bubbles: true,
          cancelable: true,
          detail: {
            bySwiperTouchMove: true
          }
        });
        swiper.wrapperEl.dispatchEvent(evt);
      }
      data.allowMomentumBounce = false;
      if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
        swiper.setGrabCursor(true);
      }
      swiper.emit("sliderFirstMove", e8);
    }
    let loopFixed;
    (/* @__PURE__ */ new Date()).getTime();
    if (data.isMoved && data.allowThresholdMove && prevTouchesDirection !== swiper.touchesDirection && isLoop && allowLoopFix && Math.abs(diff) >= 1) {
      Object.assign(touches, {
        startX: pageX,
        startY: pageY,
        currentX: pageX,
        currentY: pageY,
        startTranslate: data.currentTranslate
      });
      data.loopSwapReset = true;
      data.startTranslate = data.currentTranslate;
      return;
    }
    swiper.emit("sliderMove", e8);
    data.isMoved = true;
    data.currentTranslate = diff + data.startTranslate;
    let disableParentSwiper = true;
    let resistanceRatio = params.resistanceRatio;
    if (params.touchReleaseOnEdges) {
      resistanceRatio = 0;
    }
    if (diff > 0) {
      if (isLoop && allowLoopFix && !loopFixed && data.allowThresholdMove && data.currentTranslate > (params.centeredSlides ? swiper.minTranslate() - swiper.slidesSizesGrid[swiper.activeIndex + 1] - (params.slidesPerView !== "auto" && swiper.slides.length - params.slidesPerView >= 2 ? swiper.slidesSizesGrid[swiper.activeIndex + 1] + swiper.params.spaceBetween : 0) - swiper.params.spaceBetween : swiper.minTranslate())) {
        swiper.loopFix({
          direction: "prev",
          setTranslate: true,
          activeSlideIndex: 0
        });
      }
      if (data.currentTranslate > swiper.minTranslate()) {
        disableParentSwiper = false;
        if (params.resistance) {
          data.currentTranslate = swiper.minTranslate() - 1 + (-swiper.minTranslate() + data.startTranslate + diff) ** resistanceRatio;
        }
      }
    } else if (diff < 0) {
      if (isLoop && allowLoopFix && !loopFixed && data.allowThresholdMove && data.currentTranslate < (params.centeredSlides ? swiper.maxTranslate() + swiper.slidesSizesGrid[swiper.slidesSizesGrid.length - 1] + swiper.params.spaceBetween + (params.slidesPerView !== "auto" && swiper.slides.length - params.slidesPerView >= 2 ? swiper.slidesSizesGrid[swiper.slidesSizesGrid.length - 1] + swiper.params.spaceBetween : 0) : swiper.maxTranslate())) {
        swiper.loopFix({
          direction: "next",
          setTranslate: true,
          activeSlideIndex: swiper.slides.length - (params.slidesPerView === "auto" ? swiper.slidesPerViewDynamic() : Math.ceil(parseFloat(params.slidesPerView, 10)))
        });
      }
      if (data.currentTranslate < swiper.maxTranslate()) {
        disableParentSwiper = false;
        if (params.resistance) {
          data.currentTranslate = swiper.maxTranslate() + 1 - (swiper.maxTranslate() - data.startTranslate - diff) ** resistanceRatio;
        }
      }
    }
    if (disableParentSwiper) {
      e8.preventedByNestedSwiper = true;
    }
    if (!swiper.allowSlideNext && swiper.swipeDirection === "next" && data.currentTranslate < data.startTranslate) {
      data.currentTranslate = data.startTranslate;
    }
    if (!swiper.allowSlidePrev && swiper.swipeDirection === "prev" && data.currentTranslate > data.startTranslate) {
      data.currentTranslate = data.startTranslate;
    }
    if (!swiper.allowSlidePrev && !swiper.allowSlideNext) {
      data.currentTranslate = data.startTranslate;
    }
    if (params.threshold > 0) {
      if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {
        if (!data.allowThresholdMove) {
          data.allowThresholdMove = true;
          touches.startX = touches.currentX;
          touches.startY = touches.currentY;
          data.currentTranslate = data.startTranslate;
          touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;
          return;
        }
      } else {
        data.currentTranslate = data.startTranslate;
        return;
      }
    }
    if (!params.followFinger || params.cssMode)
      return;
    if (params.freeMode && params.freeMode.enabled && swiper.freeMode || params.watchSlidesProgress) {
      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
    }
    if (params.freeMode && params.freeMode.enabled && swiper.freeMode) {
      swiper.freeMode.onTouchMove();
    }
    swiper.updateProgress(data.currentTranslate);
    swiper.setTranslate(data.currentTranslate);
  }
  function onTouchEnd(event2) {
    const swiper = this;
    const data = swiper.touchEventsData;
    let e8 = event2;
    if (e8.originalEvent)
      e8 = e8.originalEvent;
    let targetTouch;
    const isTouchEvent2 = e8.type === "touchend" || e8.type === "touchcancel";
    if (!isTouchEvent2) {
      if (data.touchId !== null)
        return;
      if (e8.pointerId !== data.pointerId)
        return;
      targetTouch = e8;
    } else {
      targetTouch = [...e8.changedTouches].filter((t6) => t6.identifier === data.touchId)[0];
      if (!targetTouch || targetTouch.identifier !== data.touchId)
        return;
    }
    if (["pointercancel", "pointerout", "pointerleave", "contextmenu"].includes(e8.type)) {
      const proceed = ["pointercancel", "contextmenu"].includes(e8.type) && (swiper.browser.isSafari || swiper.browser.isWebView);
      if (!proceed) {
        return;
      }
    }
    data.pointerId = null;
    data.touchId = null;
    const {
      params,
      touches,
      rtlTranslate: rtl,
      slidesGrid,
      enabled
    } = swiper;
    if (!enabled)
      return;
    if (!params.simulateTouch && e8.pointerType === "mouse")
      return;
    if (data.allowTouchCallbacks) {
      swiper.emit("touchEnd", e8);
    }
    data.allowTouchCallbacks = false;
    if (!data.isTouched) {
      if (data.isMoved && params.grabCursor) {
        swiper.setGrabCursor(false);
      }
      data.isMoved = false;
      data.startMoving = false;
      return;
    }
    if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
      swiper.setGrabCursor(false);
    }
    const touchEndTime = now();
    const timeDiff = touchEndTime - data.touchStartTime;
    if (swiper.allowClick) {
      const pathTree = e8.path || e8.composedPath && e8.composedPath();
      swiper.updateClickedSlide(pathTree && pathTree[0] || e8.target, pathTree);
      swiper.emit("tap click", e8);
      if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) {
        swiper.emit("doubleTap doubleClick", e8);
      }
    }
    data.lastClickTime = now();
    nextTick(() => {
      if (!swiper.destroyed)
        swiper.allowClick = true;
    });
    if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 && !data.loopSwapReset || data.currentTranslate === data.startTranslate && !data.loopSwapReset) {
      data.isTouched = false;
      data.isMoved = false;
      data.startMoving = false;
      return;
    }
    data.isTouched = false;
    data.isMoved = false;
    data.startMoving = false;
    let currentPos;
    if (params.followFinger) {
      currentPos = rtl ? swiper.translate : -swiper.translate;
    } else {
      currentPos = -data.currentTranslate;
    }
    if (params.cssMode) {
      return;
    }
    if (params.freeMode && params.freeMode.enabled) {
      swiper.freeMode.onTouchEnd({
        currentPos
      });
      return;
    }
    const swipeToLast = currentPos >= -swiper.maxTranslate() && !swiper.params.loop;
    let stopIndex = 0;
    let groupSize = swiper.slidesSizesGrid[0];
    for (let i5 = 0; i5 < slidesGrid.length; i5 += i5 < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup) {
      const increment2 = i5 < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
      if (typeof slidesGrid[i5 + increment2] !== "undefined") {
        if (swipeToLast || currentPos >= slidesGrid[i5] && currentPos < slidesGrid[i5 + increment2]) {
          stopIndex = i5;
          groupSize = slidesGrid[i5 + increment2] - slidesGrid[i5];
        }
      } else if (swipeToLast || currentPos >= slidesGrid[i5]) {
        stopIndex = i5;
        groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];
      }
    }
    let rewindFirstIndex = null;
    let rewindLastIndex = null;
    if (params.rewind) {
      if (swiper.isBeginning) {
        rewindLastIndex = params.virtual && params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;
      } else if (swiper.isEnd) {
        rewindFirstIndex = 0;
      }
    }
    const ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;
    const increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
    if (timeDiff > params.longSwipesMs) {
      if (!params.longSwipes) {
        swiper.slideTo(swiper.activeIndex);
        return;
      }
      if (swiper.swipeDirection === "next") {
        if (ratio >= params.longSwipesRatio)
          swiper.slideTo(params.rewind && swiper.isEnd ? rewindFirstIndex : stopIndex + increment);
        else
          swiper.slideTo(stopIndex);
      }
      if (swiper.swipeDirection === "prev") {
        if (ratio > 1 - params.longSwipesRatio) {
          swiper.slideTo(stopIndex + increment);
        } else if (rewindLastIndex !== null && ratio < 0 && Math.abs(ratio) > params.longSwipesRatio) {
          swiper.slideTo(rewindLastIndex);
        } else {
          swiper.slideTo(stopIndex);
        }
      }
    } else {
      if (!params.shortSwipes) {
        swiper.slideTo(swiper.activeIndex);
        return;
      }
      const isNavButtonTarget = swiper.navigation && (e8.target === swiper.navigation.nextEl || e8.target === swiper.navigation.prevEl);
      if (!isNavButtonTarget) {
        if (swiper.swipeDirection === "next") {
          swiper.slideTo(rewindFirstIndex !== null ? rewindFirstIndex : stopIndex + increment);
        }
        if (swiper.swipeDirection === "prev") {
          swiper.slideTo(rewindLastIndex !== null ? rewindLastIndex : stopIndex);
        }
      } else if (e8.target === swiper.navigation.nextEl) {
        swiper.slideTo(stopIndex + increment);
      } else {
        swiper.slideTo(stopIndex);
      }
    }
  }
  function onResize() {
    const swiper = this;
    const {
      params,
      el
    } = swiper;
    if (el && el.offsetWidth === 0)
      return;
    if (params.breakpoints) {
      swiper.setBreakpoint();
    }
    const {
      allowSlideNext,
      allowSlidePrev,
      snapGrid
    } = swiper;
    const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
    swiper.allowSlideNext = true;
    swiper.allowSlidePrev = true;
    swiper.updateSize();
    swiper.updateSlides();
    swiper.updateSlidesClasses();
    const isVirtualLoop = isVirtual && params.loop;
    if ((params.slidesPerView === "auto" || params.slidesPerView > 1) && swiper.isEnd && !swiper.isBeginning && !swiper.params.centeredSlides && !isVirtualLoop) {
      swiper.slideTo(swiper.slides.length - 1, 0, false, true);
    } else {
      if (swiper.params.loop && !isVirtual) {
        swiper.slideToLoop(swiper.realIndex, 0, false, true);
      } else {
        swiper.slideTo(swiper.activeIndex, 0, false, true);
      }
    }
    if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {
      clearTimeout(swiper.autoplay.resizeTimeout);
      swiper.autoplay.resizeTimeout = setTimeout(() => {
        if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {
          swiper.autoplay.resume();
        }
      }, 500);
    }
    swiper.allowSlidePrev = allowSlidePrev;
    swiper.allowSlideNext = allowSlideNext;
    if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) {
      swiper.checkOverflow();
    }
  }
  function onClick(e8) {
    const swiper = this;
    if (!swiper.enabled)
      return;
    if (!swiper.allowClick) {
      if (swiper.params.preventClicks)
        e8.preventDefault();
      if (swiper.params.preventClicksPropagation && swiper.animating) {
        e8.stopPropagation();
        e8.stopImmediatePropagation();
      }
    }
  }
  function onScroll() {
    const swiper = this;
    const {
      wrapperEl,
      rtlTranslate,
      enabled
    } = swiper;
    if (!enabled)
      return;
    swiper.previousTranslate = swiper.translate;
    if (swiper.isHorizontal()) {
      swiper.translate = -wrapperEl.scrollLeft;
    } else {
      swiper.translate = -wrapperEl.scrollTop;
    }
    if (swiper.translate === 0)
      swiper.translate = 0;
    swiper.updateActiveIndex();
    swiper.updateSlidesClasses();
    let newProgress;
    const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
    if (translatesDiff === 0) {
      newProgress = 0;
    } else {
      newProgress = (swiper.translate - swiper.minTranslate()) / translatesDiff;
    }
    if (newProgress !== swiper.progress) {
      swiper.updateProgress(rtlTranslate ? -swiper.translate : swiper.translate);
    }
    swiper.emit("setTranslate", swiper.translate, false);
  }
  function onLoad(e8) {
    const swiper = this;
    processLazyPreloader(swiper, e8.target);
    if (swiper.params.cssMode || swiper.params.slidesPerView !== "auto" && !swiper.params.autoHeight) {
      return;
    }
    swiper.update();
  }
  function onDocumentTouchStart() {
    const swiper = this;
    if (swiper.documentTouchHandlerProceeded)
      return;
    swiper.documentTouchHandlerProceeded = true;
    if (swiper.params.touchReleaseOnEdges) {
      swiper.el.style.touchAction = "auto";
    }
  }
  var events = (swiper, method2) => {
    const document2 = getDocument();
    const {
      params,
      el,
      wrapperEl,
      device
    } = swiper;
    const capture = !!params.nested;
    const domMethod = method2 === "on" ? "addEventListener" : "removeEventListener";
    const swiperMethod = method2;
    if (!el || typeof el === "string")
      return;
    document2[domMethod]("touchstart", swiper.onDocumentTouchStart, {
      passive: false,
      capture
    });
    el[domMethod]("touchstart", swiper.onTouchStart, {
      passive: false
    });
    el[domMethod]("pointerdown", swiper.onTouchStart, {
      passive: false
    });
    document2[domMethod]("touchmove", swiper.onTouchMove, {
      passive: false,
      capture
    });
    document2[domMethod]("pointermove", swiper.onTouchMove, {
      passive: false,
      capture
    });
    document2[domMethod]("touchend", swiper.onTouchEnd, {
      passive: true
    });
    document2[domMethod]("pointerup", swiper.onTouchEnd, {
      passive: true
    });
    document2[domMethod]("pointercancel", swiper.onTouchEnd, {
      passive: true
    });
    document2[domMethod]("touchcancel", swiper.onTouchEnd, {
      passive: true
    });
    document2[domMethod]("pointerout", swiper.onTouchEnd, {
      passive: true
    });
    document2[domMethod]("pointerleave", swiper.onTouchEnd, {
      passive: true
    });
    document2[domMethod]("contextmenu", swiper.onTouchEnd, {
      passive: true
    });
    if (params.preventClicks || params.preventClicksPropagation) {
      el[domMethod]("click", swiper.onClick, true);
    }
    if (params.cssMode) {
      wrapperEl[domMethod]("scroll", swiper.onScroll);
    }
    if (params.updateOnWindowResize) {
      swiper[swiperMethod](device.ios || device.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", onResize, true);
    } else {
      swiper[swiperMethod]("observerUpdate", onResize, true);
    }
    el[domMethod]("load", swiper.onLoad, {
      capture: true
    });
  };
  function attachEvents() {
    const swiper = this;
    const {
      params
    } = swiper;
    swiper.onTouchStart = onTouchStart.bind(swiper);
    swiper.onTouchMove = onTouchMove.bind(swiper);
    swiper.onTouchEnd = onTouchEnd.bind(swiper);
    swiper.onDocumentTouchStart = onDocumentTouchStart.bind(swiper);
    if (params.cssMode) {
      swiper.onScroll = onScroll.bind(swiper);
    }
    swiper.onClick = onClick.bind(swiper);
    swiper.onLoad = onLoad.bind(swiper);
    events(swiper, "on");
  }
  function detachEvents() {
    const swiper = this;
    events(swiper, "off");
  }
  var events$1 = {
    attachEvents,
    detachEvents
  };
  var isGridEnabled = (swiper, params) => {
    return swiper.grid && params.grid && params.grid.rows > 1;
  };
  function setBreakpoint() {
    const swiper = this;
    const {
      realIndex,
      initialized,
      params,
      el
    } = swiper;
    const breakpoints2 = params.breakpoints;
    if (!breakpoints2 || breakpoints2 && Object.keys(breakpoints2).length === 0)
      return;
    const breakpoint = swiper.getBreakpoint(breakpoints2, swiper.params.breakpointsBase, swiper.el);
    if (!breakpoint || swiper.currentBreakpoint === breakpoint)
      return;
    const breakpointOnlyParams = breakpoint in breakpoints2 ? breakpoints2[breakpoint] : void 0;
    const breakpointParams = breakpointOnlyParams || swiper.originalParams;
    const wasMultiRow = isGridEnabled(swiper, params);
    const isMultiRow = isGridEnabled(swiper, breakpointParams);
    const wasGrabCursor = swiper.params.grabCursor;
    const isGrabCursor = breakpointParams.grabCursor;
    const wasEnabled = params.enabled;
    if (wasMultiRow && !isMultiRow) {
      el.classList.remove(`${params.containerModifierClass}grid`, `${params.containerModifierClass}grid-column`);
      swiper.emitContainerClasses();
    } else if (!wasMultiRow && isMultiRow) {
      el.classList.add(`${params.containerModifierClass}grid`);
      if (breakpointParams.grid.fill && breakpointParams.grid.fill === "column" || !breakpointParams.grid.fill && params.grid.fill === "column") {
        el.classList.add(`${params.containerModifierClass}grid-column`);
      }
      swiper.emitContainerClasses();
    }
    if (wasGrabCursor && !isGrabCursor) {
      swiper.unsetGrabCursor();
    } else if (!wasGrabCursor && isGrabCursor) {
      swiper.setGrabCursor();
    }
    ["navigation", "pagination", "scrollbar"].forEach((prop2) => {
      if (typeof breakpointParams[prop2] === "undefined")
        return;
      const wasModuleEnabled = params[prop2] && params[prop2].enabled;
      const isModuleEnabled = breakpointParams[prop2] && breakpointParams[prop2].enabled;
      if (wasModuleEnabled && !isModuleEnabled) {
        swiper[prop2].disable();
      }
      if (!wasModuleEnabled && isModuleEnabled) {
        swiper[prop2].enable();
      }
    });
    const directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;
    const needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);
    const wasLoop = params.loop;
    if (directionChanged && initialized) {
      swiper.changeDirection();
    }
    extend3(swiper.params, breakpointParams);
    const isEnabled = swiper.params.enabled;
    const hasLoop = swiper.params.loop;
    Object.assign(swiper, {
      allowTouchMove: swiper.params.allowTouchMove,
      allowSlideNext: swiper.params.allowSlideNext,
      allowSlidePrev: swiper.params.allowSlidePrev
    });
    if (wasEnabled && !isEnabled) {
      swiper.disable();
    } else if (!wasEnabled && isEnabled) {
      swiper.enable();
    }
    swiper.currentBreakpoint = breakpoint;
    swiper.emit("_beforeBreakpoint", breakpointParams);
    if (initialized) {
      if (needsReLoop) {
        swiper.loopDestroy();
        swiper.loopCreate(realIndex);
        swiper.updateSlides();
      } else if (!wasLoop && hasLoop) {
        swiper.loopCreate(realIndex);
        swiper.updateSlides();
      } else if (wasLoop && !hasLoop) {
        swiper.loopDestroy();
      }
    }
    swiper.emit("breakpoint", breakpointParams);
  }
  function getBreakpoint(breakpoints2, base, containerEl) {
    if (base === void 0) {
      base = "window";
    }
    if (!breakpoints2 || base === "container" && !containerEl)
      return void 0;
    let breakpoint = false;
    const window2 = getWindow();
    const currentHeight = base === "window" ? window2.innerHeight : containerEl.clientHeight;
    const points = Object.keys(breakpoints2).map((point) => {
      if (typeof point === "string" && point.indexOf("@") === 0) {
        const minRatio = parseFloat(point.substr(1));
        const value = currentHeight * minRatio;
        return {
          value,
          point
        };
      }
      return {
        value: point,
        point
      };
    });
    points.sort((a4, b2) => parseInt(a4.value, 10) - parseInt(b2.value, 10));
    for (let i5 = 0; i5 < points.length; i5 += 1) {
      const {
        point,
        value
      } = points[i5];
      if (base === "window") {
        if (window2.matchMedia(`(min-width: ${value}px)`).matches) {
          breakpoint = point;
        }
      } else if (value <= containerEl.clientWidth) {
        breakpoint = point;
      }
    }
    return breakpoint || "max";
  }
  var breakpoints = {
    setBreakpoint,
    getBreakpoint
  };
  function prepareClasses(entries, prefix) {
    const resultClasses = [];
    entries.forEach((item) => {
      if (typeof item === "object") {
        Object.keys(item).forEach((classNames) => {
          if (item[classNames]) {
            resultClasses.push(prefix + classNames);
          }
        });
      } else if (typeof item === "string") {
        resultClasses.push(prefix + item);
      }
    });
    return resultClasses;
  }
  function addClasses() {
    const swiper = this;
    const {
      classNames,
      params,
      rtl,
      el,
      device
    } = swiper;
    const suffixes = prepareClasses(["initialized", params.direction, {
      "free-mode": swiper.params.freeMode && params.freeMode.enabled
    }, {
      "autoheight": params.autoHeight
    }, {
      "rtl": rtl
    }, {
      "grid": params.grid && params.grid.rows > 1
    }, {
      "grid-column": params.grid && params.grid.rows > 1 && params.grid.fill === "column"
    }, {
      "android": device.android
    }, {
      "ios": device.ios
    }, {
      "css-mode": params.cssMode
    }, {
      "centered": params.cssMode && params.centeredSlides
    }, {
      "watch-progress": params.watchSlidesProgress
    }], params.containerModifierClass);
    classNames.push(...suffixes);
    el.classList.add(...classNames);
    swiper.emitContainerClasses();
  }
  function removeClasses() {
    const swiper = this;
    const {
      el,
      classNames
    } = swiper;
    if (!el || typeof el === "string")
      return;
    el.classList.remove(...classNames);
    swiper.emitContainerClasses();
  }
  var classes = {
    addClasses,
    removeClasses
  };
  function checkOverflow() {
    const swiper = this;
    const {
      isLocked: wasLocked,
      params
    } = swiper;
    const {
      slidesOffsetBefore
    } = params;
    if (slidesOffsetBefore) {
      const lastSlideIndex = swiper.slides.length - 1;
      const lastSlideRightEdge = swiper.slidesGrid[lastSlideIndex] + swiper.slidesSizesGrid[lastSlideIndex] + slidesOffsetBefore * 2;
      swiper.isLocked = swiper.size > lastSlideRightEdge;
    } else {
      swiper.isLocked = swiper.snapGrid.length === 1;
    }
    if (params.allowSlideNext === true) {
      swiper.allowSlideNext = !swiper.isLocked;
    }
    if (params.allowSlidePrev === true) {
      swiper.allowSlidePrev = !swiper.isLocked;
    }
    if (wasLocked && wasLocked !== swiper.isLocked) {
      swiper.isEnd = false;
    }
    if (wasLocked !== swiper.isLocked) {
      swiper.emit(swiper.isLocked ? "lock" : "unlock");
    }
  }
  var checkOverflow$1 = {
    checkOverflow
  };
  var defaults3 = {
    init: true,
    direction: "horizontal",
    oneWayMovement: false,
    swiperElementNodeName: "SWIPER-CONTAINER",
    touchEventsTarget: "wrapper",
    initialSlide: 0,
    speed: 300,
    cssMode: false,
    updateOnWindowResize: true,
    resizeObserver: true,
    nested: false,
    createElements: false,
    eventsPrefix: "swiper",
    enabled: true,
    focusableElements: "input, select, option, textarea, button, video, label",
    // Overrides
    width: null,
    height: null,
    //
    preventInteractionOnTransition: false,
    // ssr
    userAgent: null,
    url: null,
    // To support iOS's swipe-to-go-back gesture (when being used in-app).
    edgeSwipeDetection: false,
    edgeSwipeThreshold: 20,
    // Autoheight
    autoHeight: false,
    // Set wrapper width
    setWrapperSize: false,
    // Virtual Translate
    virtualTranslate: false,
    // Effects
    effect: "slide",
    // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'
    // Breakpoints
    breakpoints: void 0,
    breakpointsBase: "window",
    // Slides grid
    spaceBetween: 0,
    slidesPerView: 1,
    slidesPerGroup: 1,
    slidesPerGroupSkip: 0,
    slidesPerGroupAuto: false,
    centeredSlides: false,
    centeredSlidesBounds: false,
    slidesOffsetBefore: 0,
    // in px
    slidesOffsetAfter: 0,
    // in px
    normalizeSlideIndex: true,
    centerInsufficientSlides: false,
    // Disable swiper and hide navigation when container not overflow
    watchOverflow: true,
    // Round length
    roundLengths: false,
    // Touches
    touchRatio: 1,
    touchAngle: 45,
    simulateTouch: true,
    shortSwipes: true,
    longSwipes: true,
    longSwipesRatio: 0.5,
    longSwipesMs: 300,
    followFinger: true,
    allowTouchMove: true,
    threshold: 5,
    touchMoveStopPropagation: false,
    touchStartPreventDefault: true,
    touchStartForcePreventDefault: false,
    touchReleaseOnEdges: false,
    // Unique Navigation Elements
    uniqueNavElements: true,
    // Resistance
    resistance: true,
    resistanceRatio: 0.85,
    // Progress
    watchSlidesProgress: false,
    // Cursor
    grabCursor: false,
    // Clicks
    preventClicks: true,
    preventClicksPropagation: true,
    slideToClickedSlide: false,
    // loop
    loop: false,
    loopAddBlankSlides: true,
    loopAdditionalSlides: 0,
    loopPreventsSliding: true,
    // rewind
    rewind: false,
    // Swiping/no swiping
    allowSlidePrev: true,
    allowSlideNext: true,
    swipeHandler: null,
    // '.swipe-handler',
    noSwiping: true,
    noSwipingClass: "swiper-no-swiping",
    noSwipingSelector: null,
    // Passive Listeners
    passiveListeners: true,
    maxBackfaceHiddenSlides: 10,
    // NS
    containerModifierClass: "swiper-",
    // NEW
    slideClass: "swiper-slide",
    slideBlankClass: "swiper-slide-blank",
    slideActiveClass: "swiper-slide-active",
    slideVisibleClass: "swiper-slide-visible",
    slideFullyVisibleClass: "swiper-slide-fully-visible",
    slideNextClass: "swiper-slide-next",
    slidePrevClass: "swiper-slide-prev",
    wrapperClass: "swiper-wrapper",
    lazyPreloaderClass: "swiper-lazy-preloader",
    lazyPreloadPrevNext: 0,
    // Callbacks
    runCallbacksOnInit: true,
    // Internals
    _emitClasses: false
  };
  function moduleExtendParams(params, allModulesParams) {
    return function extendParams(obj) {
      if (obj === void 0) {
        obj = {};
      }
      const moduleParamName = Object.keys(obj)[0];
      const moduleParams = obj[moduleParamName];
      if (typeof moduleParams !== "object" || moduleParams === null) {
        extend3(allModulesParams, obj);
        return;
      }
      if (params[moduleParamName] === true) {
        params[moduleParamName] = {
          enabled: true
        };
      }
      if (moduleParamName === "navigation" && params[moduleParamName] && params[moduleParamName].enabled && !params[moduleParamName].prevEl && !params[moduleParamName].nextEl) {
        params[moduleParamName].auto = true;
      }
      if (["pagination", "scrollbar"].indexOf(moduleParamName) >= 0 && params[moduleParamName] && params[moduleParamName].enabled && !params[moduleParamName].el) {
        params[moduleParamName].auto = true;
      }
      if (!(moduleParamName in params && "enabled" in moduleParams)) {
        extend3(allModulesParams, obj);
        return;
      }
      if (typeof params[moduleParamName] === "object" && !("enabled" in params[moduleParamName])) {
        params[moduleParamName].enabled = true;
      }
      if (!params[moduleParamName])
        params[moduleParamName] = {
          enabled: false
        };
      extend3(allModulesParams, obj);
    };
  }
  var prototypes = {
    eventsEmitter,
    update,
    translate,
    transition,
    slide,
    loop,
    grabCursor,
    events: events$1,
    breakpoints,
    checkOverflow: checkOverflow$1,
    classes
  };
  var extendedDefaults = {};
  var Swiper = class _Swiper {
    constructor() {
      let el;
      let params;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      if (args.length === 1 && args[0].constructor && Object.prototype.toString.call(args[0]).slice(8, -1) === "Object") {
        params = args[0];
      } else {
        [el, params] = args;
      }
      if (!params)
        params = {};
      params = extend3({}, params);
      if (el && !params.el)
        params.el = el;
      const document2 = getDocument();
      if (params.el && typeof params.el === "string" && document2.querySelectorAll(params.el).length > 1) {
        const swipers = [];
        document2.querySelectorAll(params.el).forEach((containerEl) => {
          const newParams = extend3({}, params, {
            el: containerEl
          });
          swipers.push(new _Swiper(newParams));
        });
        return swipers;
      }
      const swiper = this;
      swiper.__swiper__ = true;
      swiper.support = getSupport();
      swiper.device = getDevice({
        userAgent: params.userAgent
      });
      swiper.browser = getBrowser();
      swiper.eventsListeners = {};
      swiper.eventsAnyListeners = [];
      swiper.modules = [...swiper.__modules__];
      if (params.modules && Array.isArray(params.modules)) {
        swiper.modules.push(...params.modules);
      }
      const allModulesParams = {};
      swiper.modules.forEach((mod) => {
        mod({
          params,
          swiper,
          extendParams: moduleExtendParams(params, allModulesParams),
          on: swiper.on.bind(swiper),
          once: swiper.once.bind(swiper),
          off: swiper.off.bind(swiper),
          emit: swiper.emit.bind(swiper)
        });
      });
      const swiperParams = extend3({}, defaults3, allModulesParams);
      swiper.params = extend3({}, swiperParams, extendedDefaults, params);
      swiper.originalParams = extend3({}, swiper.params);
      swiper.passedParams = extend3({}, params);
      if (swiper.params && swiper.params.on) {
        Object.keys(swiper.params.on).forEach((eventName) => {
          swiper.on(eventName, swiper.params.on[eventName]);
        });
      }
      if (swiper.params && swiper.params.onAny) {
        swiper.onAny(swiper.params.onAny);
      }
      Object.assign(swiper, {
        enabled: swiper.params.enabled,
        el,
        // Classes
        classNames: [],
        // Slides
        slides: [],
        slidesGrid: [],
        snapGrid: [],
        slidesSizesGrid: [],
        // isDirection
        isHorizontal() {
          return swiper.params.direction === "horizontal";
        },
        isVertical() {
          return swiper.params.direction === "vertical";
        },
        // Indexes
        activeIndex: 0,
        realIndex: 0,
        //
        isBeginning: true,
        isEnd: false,
        // Props
        translate: 0,
        previousTranslate: 0,
        progress: 0,
        velocity: 0,
        animating: false,
        cssOverflowAdjustment() {
          return Math.trunc(this.translate / 2 ** 23) * 2 ** 23;
        },
        // Locks
        allowSlideNext: swiper.params.allowSlideNext,
        allowSlidePrev: swiper.params.allowSlidePrev,
        // Touch Events
        touchEventsData: {
          isTouched: void 0,
          isMoved: void 0,
          allowTouchCallbacks: void 0,
          touchStartTime: void 0,
          isScrolling: void 0,
          currentTranslate: void 0,
          startTranslate: void 0,
          allowThresholdMove: void 0,
          // Form elements to match
          focusableElements: swiper.params.focusableElements,
          // Last click time
          lastClickTime: 0,
          clickTimeout: void 0,
          // Velocities
          velocities: [],
          allowMomentumBounce: void 0,
          startMoving: void 0,
          pointerId: null,
          touchId: null
        },
        // Clicks
        allowClick: true,
        // Touches
        allowTouchMove: swiper.params.allowTouchMove,
        touches: {
          startX: 0,
          startY: 0,
          currentX: 0,
          currentY: 0,
          diff: 0
        },
        // Images
        imagesToLoad: [],
        imagesLoaded: 0
      });
      swiper.emit("_swiper");
      if (swiper.params.init) {
        swiper.init();
      }
      return swiper;
    }
    getDirectionLabel(property) {
      if (this.isHorizontal()) {
        return property;
      }
      return {
        "width": "height",
        "margin-top": "margin-left",
        "margin-bottom ": "margin-right",
        "margin-left": "margin-top",
        "margin-right": "margin-bottom",
        "padding-left": "padding-top",
        "padding-right": "padding-bottom",
        "marginRight": "marginBottom"
      }[property];
    }
    getSlideIndex(slideEl) {
      const {
        slidesEl,
        params
      } = this;
      const slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);
      const firstSlideIndex = elementIndex(slides[0]);
      return elementIndex(slideEl) - firstSlideIndex;
    }
    getSlideIndexByData(index) {
      return this.getSlideIndex(this.slides.filter((slideEl) => slideEl.getAttribute("data-swiper-slide-index") * 1 === index)[0]);
    }
    recalcSlides() {
      const swiper = this;
      const {
        slidesEl,
        params
      } = swiper;
      swiper.slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);
    }
    enable() {
      const swiper = this;
      if (swiper.enabled)
        return;
      swiper.enabled = true;
      if (swiper.params.grabCursor) {
        swiper.setGrabCursor();
      }
      swiper.emit("enable");
    }
    disable() {
      const swiper = this;
      if (!swiper.enabled)
        return;
      swiper.enabled = false;
      if (swiper.params.grabCursor) {
        swiper.unsetGrabCursor();
      }
      swiper.emit("disable");
    }
    setProgress(progress, speed) {
      const swiper = this;
      progress = Math.min(Math.max(progress, 0), 1);
      const min2 = swiper.minTranslate();
      const max2 = swiper.maxTranslate();
      const current = (max2 - min2) * progress + min2;
      swiper.translateTo(current, typeof speed === "undefined" ? 0 : speed);
      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
    }
    emitContainerClasses() {
      const swiper = this;
      if (!swiper.params._emitClasses || !swiper.el)
        return;
      const cls = swiper.el.className.split(" ").filter((className) => {
        return className.indexOf("swiper") === 0 || className.indexOf(swiper.params.containerModifierClass) === 0;
      });
      swiper.emit("_containerClasses", cls.join(" "));
    }
    getSlideClasses(slideEl) {
      const swiper = this;
      if (swiper.destroyed)
        return "";
      return slideEl.className.split(" ").filter((className) => {
        return className.indexOf("swiper-slide") === 0 || className.indexOf(swiper.params.slideClass) === 0;
      }).join(" ");
    }
    emitSlidesClasses() {
      const swiper = this;
      if (!swiper.params._emitClasses || !swiper.el)
        return;
      const updates = [];
      swiper.slides.forEach((slideEl) => {
        const classNames = swiper.getSlideClasses(slideEl);
        updates.push({
          slideEl,
          classNames
        });
        swiper.emit("_slideClass", slideEl, classNames);
      });
      swiper.emit("_slideClasses", updates);
    }
    slidesPerViewDynamic(view, exact) {
      if (view === void 0) {
        view = "current";
      }
      if (exact === void 0) {
        exact = false;
      }
      const swiper = this;
      const {
        params,
        slides,
        slidesGrid,
        slidesSizesGrid,
        size: swiperSize,
        activeIndex
      } = swiper;
      let spv = 1;
      if (typeof params.slidesPerView === "number")
        return params.slidesPerView;
      if (params.centeredSlides) {
        let slideSize = slides[activeIndex] ? Math.ceil(slides[activeIndex].swiperSlideSize) : 0;
        let breakLoop;
        for (let i5 = activeIndex + 1; i5 < slides.length; i5 += 1) {
          if (slides[i5] && !breakLoop) {
            slideSize += Math.ceil(slides[i5].swiperSlideSize);
            spv += 1;
            if (slideSize > swiperSize)
              breakLoop = true;
          }
        }
        for (let i5 = activeIndex - 1; i5 >= 0; i5 -= 1) {
          if (slides[i5] && !breakLoop) {
            slideSize += slides[i5].swiperSlideSize;
            spv += 1;
            if (slideSize > swiperSize)
              breakLoop = true;
          }
        }
      } else {
        if (view === "current") {
          for (let i5 = activeIndex + 1; i5 < slides.length; i5 += 1) {
            const slideInView = exact ? slidesGrid[i5] + slidesSizesGrid[i5] - slidesGrid[activeIndex] < swiperSize : slidesGrid[i5] - slidesGrid[activeIndex] < swiperSize;
            if (slideInView) {
              spv += 1;
            }
          }
        } else {
          for (let i5 = activeIndex - 1; i5 >= 0; i5 -= 1) {
            const slideInView = slidesGrid[activeIndex] - slidesGrid[i5] < swiperSize;
            if (slideInView) {
              spv += 1;
            }
          }
        }
      }
      return spv;
    }
    update() {
      const swiper = this;
      if (!swiper || swiper.destroyed)
        return;
      const {
        snapGrid,
        params
      } = swiper;
      if (params.breakpoints) {
        swiper.setBreakpoint();
      }
      [...swiper.el.querySelectorAll('[loading="lazy"]')].forEach((imageEl) => {
        if (imageEl.complete) {
          processLazyPreloader(swiper, imageEl);
        }
      });
      swiper.updateSize();
      swiper.updateSlides();
      swiper.updateProgress();
      swiper.updateSlidesClasses();
      function setTranslate2() {
        const translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;
        const newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());
        swiper.setTranslate(newTranslate);
        swiper.updateActiveIndex();
        swiper.updateSlidesClasses();
      }
      let translated;
      if (params.freeMode && params.freeMode.enabled && !params.cssMode) {
        setTranslate2();
        if (params.autoHeight) {
          swiper.updateAutoHeight();
        }
      } else {
        if ((params.slidesPerView === "auto" || params.slidesPerView > 1) && swiper.isEnd && !params.centeredSlides) {
          const slides = swiper.virtual && params.virtual.enabled ? swiper.virtual.slides : swiper.slides;
          translated = swiper.slideTo(slides.length - 1, 0, false, true);
        } else {
          translated = swiper.slideTo(swiper.activeIndex, 0, false, true);
        }
        if (!translated) {
          setTranslate2();
        }
      }
      if (params.watchOverflow && snapGrid !== swiper.snapGrid) {
        swiper.checkOverflow();
      }
      swiper.emit("update");
    }
    changeDirection(newDirection, needUpdate) {
      if (needUpdate === void 0) {
        needUpdate = true;
      }
      const swiper = this;
      const currentDirection = swiper.params.direction;
      if (!newDirection) {
        newDirection = currentDirection === "horizontal" ? "vertical" : "horizontal";
      }
      if (newDirection === currentDirection || newDirection !== "horizontal" && newDirection !== "vertical") {
        return swiper;
      }
      swiper.el.classList.remove(`${swiper.params.containerModifierClass}${currentDirection}`);
      swiper.el.classList.add(`${swiper.params.containerModifierClass}${newDirection}`);
      swiper.emitContainerClasses();
      swiper.params.direction = newDirection;
      swiper.slides.forEach((slideEl) => {
        if (newDirection === "vertical") {
          slideEl.style.width = "";
        } else {
          slideEl.style.height = "";
        }
      });
      swiper.emit("changeDirection");
      if (needUpdate)
        swiper.update();
      return swiper;
    }
    changeLanguageDirection(direction) {
      const swiper = this;
      if (swiper.rtl && direction === "rtl" || !swiper.rtl && direction === "ltr")
        return;
      swiper.rtl = direction === "rtl";
      swiper.rtlTranslate = swiper.params.direction === "horizontal" && swiper.rtl;
      if (swiper.rtl) {
        swiper.el.classList.add(`${swiper.params.containerModifierClass}rtl`);
        swiper.el.dir = "rtl";
      } else {
        swiper.el.classList.remove(`${swiper.params.containerModifierClass}rtl`);
        swiper.el.dir = "ltr";
      }
      swiper.update();
    }
    mount(element) {
      const swiper = this;
      if (swiper.mounted)
        return true;
      let el = element || swiper.params.el;
      if (typeof el === "string") {
        el = document.querySelector(el);
      }
      if (!el) {
        return false;
      }
      el.swiper = swiper;
      if (el.parentNode && el.parentNode.host && el.parentNode.host.nodeName === swiper.params.swiperElementNodeName.toUpperCase()) {
        swiper.isElement = true;
      }
      const getWrapperSelector = () => {
        return `.${(swiper.params.wrapperClass || "").trim().split(" ").join(".")}`;
      };
      const getWrapper = () => {
        if (el && el.shadowRoot && el.shadowRoot.querySelector) {
          const res = el.shadowRoot.querySelector(getWrapperSelector());
          return res;
        }
        return elementChildren(el, getWrapperSelector())[0];
      };
      let wrapperEl = getWrapper();
      if (!wrapperEl && swiper.params.createElements) {
        wrapperEl = createElement("div", swiper.params.wrapperClass);
        el.append(wrapperEl);
        elementChildren(el, `.${swiper.params.slideClass}`).forEach((slideEl) => {
          wrapperEl.append(slideEl);
        });
      }
      Object.assign(swiper, {
        el,
        wrapperEl,
        slidesEl: swiper.isElement && !el.parentNode.host.slideSlots ? el.parentNode.host : wrapperEl,
        hostEl: swiper.isElement ? el.parentNode.host : el,
        mounted: true,
        // RTL
        rtl: el.dir.toLowerCase() === "rtl" || elementStyle(el, "direction") === "rtl",
        rtlTranslate: swiper.params.direction === "horizontal" && (el.dir.toLowerCase() === "rtl" || elementStyle(el, "direction") === "rtl"),
        wrongRTL: elementStyle(wrapperEl, "display") === "-webkit-box"
      });
      return true;
    }
    init(el) {
      const swiper = this;
      if (swiper.initialized)
        return swiper;
      const mounted = swiper.mount(el);
      if (mounted === false)
        return swiper;
      swiper.emit("beforeInit");
      if (swiper.params.breakpoints) {
        swiper.setBreakpoint();
      }
      swiper.addClasses();
      swiper.updateSize();
      swiper.updateSlides();
      if (swiper.params.watchOverflow) {
        swiper.checkOverflow();
      }
      if (swiper.params.grabCursor && swiper.enabled) {
        swiper.setGrabCursor();
      }
      if (swiper.params.loop && swiper.virtual && swiper.params.virtual.enabled) {
        swiper.slideTo(swiper.params.initialSlide + swiper.virtual.slidesBefore, 0, swiper.params.runCallbacksOnInit, false, true);
      } else {
        swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit, false, true);
      }
      if (swiper.params.loop) {
        swiper.loopCreate();
      }
      swiper.attachEvents();
      const lazyElements = [...swiper.el.querySelectorAll('[loading="lazy"]')];
      if (swiper.isElement) {
        lazyElements.push(...swiper.hostEl.querySelectorAll('[loading="lazy"]'));
      }
      lazyElements.forEach((imageEl) => {
        if (imageEl.complete) {
          processLazyPreloader(swiper, imageEl);
        } else {
          imageEl.addEventListener("load", (e8) => {
            processLazyPreloader(swiper, e8.target);
          });
        }
      });
      preload(swiper);
      swiper.initialized = true;
      preload(swiper);
      swiper.emit("init");
      swiper.emit("afterInit");
      return swiper;
    }
    destroy(deleteInstance, cleanStyles) {
      if (deleteInstance === void 0) {
        deleteInstance = true;
      }
      if (cleanStyles === void 0) {
        cleanStyles = true;
      }
      const swiper = this;
      const {
        params,
        el,
        wrapperEl,
        slides
      } = swiper;
      if (typeof swiper.params === "undefined" || swiper.destroyed) {
        return null;
      }
      swiper.emit("beforeDestroy");
      swiper.initialized = false;
      swiper.detachEvents();
      if (params.loop) {
        swiper.loopDestroy();
      }
      if (cleanStyles) {
        swiper.removeClasses();
        if (el && typeof el !== "string") {
          el.removeAttribute("style");
        }
        if (wrapperEl) {
          wrapperEl.removeAttribute("style");
        }
        if (slides && slides.length) {
          slides.forEach((slideEl) => {
            slideEl.classList.remove(params.slideVisibleClass, params.slideFullyVisibleClass, params.slideActiveClass, params.slideNextClass, params.slidePrevClass);
            slideEl.removeAttribute("style");
            slideEl.removeAttribute("data-swiper-slide-index");
          });
        }
      }
      swiper.emit("destroy");
      Object.keys(swiper.eventsListeners).forEach((eventName) => {
        swiper.off(eventName);
      });
      if (deleteInstance !== false) {
        if (swiper.el && typeof swiper.el !== "string") {
          swiper.el.swiper = null;
        }
        deleteProps(swiper);
      }
      swiper.destroyed = true;
      return null;
    }
    static extendDefaults(newDefaults) {
      extend3(extendedDefaults, newDefaults);
    }
    static get extendedDefaults() {
      return extendedDefaults;
    }
    static get defaults() {
      return defaults3;
    }
    static installModule(mod) {
      if (!_Swiper.prototype.__modules__)
        _Swiper.prototype.__modules__ = [];
      const modules = _Swiper.prototype.__modules__;
      if (typeof mod === "function" && modules.indexOf(mod) < 0) {
        modules.push(mod);
      }
    }
    static use(module) {
      if (Array.isArray(module)) {
        module.forEach((m2) => _Swiper.installModule(m2));
        return _Swiper;
      }
      _Swiper.installModule(module);
      return _Swiper;
    }
  };
  Object.keys(prototypes).forEach((prototypeGroup) => {
    Object.keys(prototypes[prototypeGroup]).forEach((protoMethod) => {
      Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];
    });
  });
  Swiper.use([Resize, Observer2]);

  // node_modules/.pnpm/swiper@11.1.9/node_modules/swiper/modules/index.mjs
  init_live_reload();

  // node_modules/.pnpm/swiper@11.1.9/node_modules/swiper/modules/virtual.mjs
  init_live_reload();

  // node_modules/.pnpm/swiper@11.1.9/node_modules/swiper/modules/keyboard.mjs
  init_live_reload();

  // node_modules/.pnpm/swiper@11.1.9/node_modules/swiper/modules/mousewheel.mjs
  init_live_reload();

  // node_modules/.pnpm/swiper@11.1.9/node_modules/swiper/modules/navigation.mjs
  init_live_reload();

  // node_modules/.pnpm/swiper@11.1.9/node_modules/swiper/shared/create-element-if-not-defined.mjs
  init_live_reload();
  function createElementIfNotDefined(swiper, originalParams, params, checkProps) {
    if (swiper.params.createElements) {
      Object.keys(checkProps).forEach((key2) => {
        if (!params[key2] && params.auto === true) {
          let element = elementChildren(swiper.el, `.${checkProps[key2]}`)[0];
          if (!element) {
            element = createElement("div", checkProps[key2]);
            element.className = checkProps[key2];
            swiper.el.append(element);
          }
          params[key2] = element;
          originalParams[key2] = element;
        }
      });
    }
    return params;
  }

  // node_modules/.pnpm/swiper@11.1.9/node_modules/swiper/modules/navigation.mjs
  function Navigation(_ref) {
    let {
      swiper,
      extendParams,
      on,
      emit
    } = _ref;
    extendParams({
      navigation: {
        nextEl: null,
        prevEl: null,
        hideOnClick: false,
        disabledClass: "swiper-button-disabled",
        hiddenClass: "swiper-button-hidden",
        lockClass: "swiper-button-lock",
        navigationDisabledClass: "swiper-navigation-disabled"
      }
    });
    swiper.navigation = {
      nextEl: null,
      prevEl: null
    };
    function getEl(el) {
      let res;
      if (el && typeof el === "string" && swiper.isElement) {
        res = swiper.el.querySelector(el);
        if (res)
          return res;
      }
      if (el) {
        if (typeof el === "string")
          res = [...document.querySelectorAll(el)];
        if (swiper.params.uniqueNavElements && typeof el === "string" && res && res.length > 1 && swiper.el.querySelectorAll(el).length === 1) {
          res = swiper.el.querySelector(el);
        } else if (res && res.length === 1) {
          res = res[0];
        }
      }
      if (el && !res)
        return el;
      return res;
    }
    function toggleEl(el, disabled) {
      const params = swiper.params.navigation;
      el = makeElementsArray(el);
      el.forEach((subEl) => {
        if (subEl) {
          subEl.classList[disabled ? "add" : "remove"](...params.disabledClass.split(" "));
          if (subEl.tagName === "BUTTON")
            subEl.disabled = disabled;
          if (swiper.params.watchOverflow && swiper.enabled) {
            subEl.classList[swiper.isLocked ? "add" : "remove"](params.lockClass);
          }
        }
      });
    }
    function update3() {
      const {
        nextEl,
        prevEl
      } = swiper.navigation;
      if (swiper.params.loop) {
        toggleEl(prevEl, false);
        toggleEl(nextEl, false);
        return;
      }
      toggleEl(prevEl, swiper.isBeginning && !swiper.params.rewind);
      toggleEl(nextEl, swiper.isEnd && !swiper.params.rewind);
    }
    function onPrevClick(e8) {
      e8.preventDefault();
      if (swiper.isBeginning && !swiper.params.loop && !swiper.params.rewind)
        return;
      swiper.slidePrev();
      emit("navigationPrev");
    }
    function onNextClick(e8) {
      e8.preventDefault();
      if (swiper.isEnd && !swiper.params.loop && !swiper.params.rewind)
        return;
      swiper.slideNext();
      emit("navigationNext");
    }
    function init5() {
      const params = swiper.params.navigation;
      swiper.params.navigation = createElementIfNotDefined(swiper, swiper.originalParams.navigation, swiper.params.navigation, {
        nextEl: "swiper-button-next",
        prevEl: "swiper-button-prev"
      });
      if (!(params.nextEl || params.prevEl))
        return;
      let nextEl = getEl(params.nextEl);
      let prevEl = getEl(params.prevEl);
      Object.assign(swiper.navigation, {
        nextEl,
        prevEl
      });
      nextEl = makeElementsArray(nextEl);
      prevEl = makeElementsArray(prevEl);
      const initButton = (el, dir) => {
        if (el) {
          el.addEventListener("click", dir === "next" ? onNextClick : onPrevClick);
        }
        if (!swiper.enabled && el) {
          el.classList.add(...params.lockClass.split(" "));
        }
      };
      nextEl.forEach((el) => initButton(el, "next"));
      prevEl.forEach((el) => initButton(el, "prev"));
    }
    function destroy() {
      let {
        nextEl,
        prevEl
      } = swiper.navigation;
      nextEl = makeElementsArray(nextEl);
      prevEl = makeElementsArray(prevEl);
      const destroyButton = (el, dir) => {
        el.removeEventListener("click", dir === "next" ? onNextClick : onPrevClick);
        el.classList.remove(...swiper.params.navigation.disabledClass.split(" "));
      };
      nextEl.forEach((el) => destroyButton(el, "next"));
      prevEl.forEach((el) => destroyButton(el, "prev"));
    }
    on("init", () => {
      if (swiper.params.navigation.enabled === false) {
        disable();
      } else {
        init5();
        update3();
      }
    });
    on("toEdge fromEdge lock unlock", () => {
      update3();
    });
    on("destroy", () => {
      destroy();
    });
    on("enable disable", () => {
      let {
        nextEl,
        prevEl
      } = swiper.navigation;
      nextEl = makeElementsArray(nextEl);
      prevEl = makeElementsArray(prevEl);
      if (swiper.enabled) {
        update3();
        return;
      }
      [...nextEl, ...prevEl].filter((el) => !!el).forEach((el) => el.classList.add(swiper.params.navigation.lockClass));
    });
    on("click", (_s, e8) => {
      let {
        nextEl,
        prevEl
      } = swiper.navigation;
      nextEl = makeElementsArray(nextEl);
      prevEl = makeElementsArray(prevEl);
      const targetEl = e8.target;
      let targetIsButton = prevEl.includes(targetEl) || nextEl.includes(targetEl);
      if (swiper.isElement && !targetIsButton) {
        const path = e8.path || e8.composedPath && e8.composedPath();
        if (path) {
          targetIsButton = path.find((pathEl) => nextEl.includes(pathEl) || prevEl.includes(pathEl));
        }
      }
      if (swiper.params.navigation.hideOnClick && !targetIsButton) {
        if (swiper.pagination && swiper.params.pagination && swiper.params.pagination.clickable && (swiper.pagination.el === targetEl || swiper.pagination.el.contains(targetEl)))
          return;
        let isHidden;
        if (nextEl.length) {
          isHidden = nextEl[0].classList.contains(swiper.params.navigation.hiddenClass);
        } else if (prevEl.length) {
          isHidden = prevEl[0].classList.contains(swiper.params.navigation.hiddenClass);
        }
        if (isHidden === true) {
          emit("navigationShow");
        } else {
          emit("navigationHide");
        }
        [...nextEl, ...prevEl].filter((el) => !!el).forEach((el) => el.classList.toggle(swiper.params.navigation.hiddenClass));
      }
    });
    const enable = () => {
      swiper.el.classList.remove(...swiper.params.navigation.navigationDisabledClass.split(" "));
      init5();
      update3();
    };
    const disable = () => {
      swiper.el.classList.add(...swiper.params.navigation.navigationDisabledClass.split(" "));
      destroy();
    };
    Object.assign(swiper.navigation, {
      enable,
      disable,
      update: update3,
      init: init5,
      destroy
    });
  }

  // node_modules/.pnpm/swiper@11.1.9/node_modules/swiper/modules/pagination.mjs
  init_live_reload();

  // node_modules/.pnpm/swiper@11.1.9/node_modules/swiper/shared/classes-to-selector.mjs
  init_live_reload();

  // node_modules/.pnpm/swiper@11.1.9/node_modules/swiper/modules/scrollbar.mjs
  init_live_reload();

  // node_modules/.pnpm/swiper@11.1.9/node_modules/swiper/modules/parallax.mjs
  init_live_reload();

  // node_modules/.pnpm/swiper@11.1.9/node_modules/swiper/modules/zoom.mjs
  init_live_reload();

  // node_modules/.pnpm/swiper@11.1.9/node_modules/swiper/modules/controller.mjs
  init_live_reload();

  // node_modules/.pnpm/swiper@11.1.9/node_modules/swiper/modules/a11y.mjs
  init_live_reload();

  // node_modules/.pnpm/swiper@11.1.9/node_modules/swiper/modules/history.mjs
  init_live_reload();

  // node_modules/.pnpm/swiper@11.1.9/node_modules/swiper/modules/hash-navigation.mjs
  init_live_reload();

  // node_modules/.pnpm/swiper@11.1.9/node_modules/swiper/modules/autoplay.mjs
  init_live_reload();

  // node_modules/.pnpm/swiper@11.1.9/node_modules/swiper/modules/thumbs.mjs
  init_live_reload();

  // node_modules/.pnpm/swiper@11.1.9/node_modules/swiper/modules/free-mode.mjs
  init_live_reload();

  // node_modules/.pnpm/swiper@11.1.9/node_modules/swiper/modules/grid.mjs
  init_live_reload();

  // node_modules/.pnpm/swiper@11.1.9/node_modules/swiper/modules/manipulation.mjs
  init_live_reload();

  // node_modules/.pnpm/swiper@11.1.9/node_modules/swiper/modules/effect-fade.mjs
  init_live_reload();

  // node_modules/.pnpm/swiper@11.1.9/node_modules/swiper/shared/effect-init.mjs
  init_live_reload();

  // node_modules/.pnpm/swiper@11.1.9/node_modules/swiper/shared/effect-target.mjs
  init_live_reload();

  // node_modules/.pnpm/swiper@11.1.9/node_modules/swiper/shared/effect-virtual-transition-end.mjs
  init_live_reload();

  // node_modules/.pnpm/swiper@11.1.9/node_modules/swiper/modules/effect-cube.mjs
  init_live_reload();

  // node_modules/.pnpm/swiper@11.1.9/node_modules/swiper/modules/effect-flip.mjs
  init_live_reload();

  // node_modules/.pnpm/swiper@11.1.9/node_modules/swiper/shared/create-shadow.mjs
  init_live_reload();

  // node_modules/.pnpm/swiper@11.1.9/node_modules/swiper/modules/effect-coverflow.mjs
  init_live_reload();

  // node_modules/.pnpm/swiper@11.1.9/node_modules/swiper/modules/effect-creative.mjs
  init_live_reload();

  // node_modules/.pnpm/swiper@11.1.9/node_modules/swiper/modules/effect-cards.mjs
  init_live_reload();

  // node_modules/.pnpm/vidstack@1.12.9/node_modules/vidstack/prod/vidstack-elements.js
  init_live_reload();
  init_vidstack_CRlI3Mh7();

  // node_modules/.pnpm/vidstack@1.12.9/node_modules/vidstack/prod/chunks/vidstack-CN6CifQX.js
  init_live_reload();
  init_vidstack_CRlI3Mh7();

  // node_modules/.pnpm/vidstack@1.12.9/node_modules/vidstack/prod/chunks/vidstack-C_8p1UgO.js
  init_live_reload();
  init_vidstack_CRlI3Mh7();
  init_vidstack_Cpte_fRf();
  init_vidstack_DyMkFGuS();
  init_vidstack_BmMUBVGQ();
  init_vidstack_B5628Ni3();
  init_vidstack_D5EzK014();
  init_vidstack_B01xzxC4();
  init_vidstack_C9vIqaYT();
  init_vidstack_vDnjyKV8();
  init_vidstack_Ds_q5BGO();
  init_vidstack_Dihypf8P();
  init_vidstack_DXXgp8ue();
  var List = class extends EventsTarget {
    items = [];
    /** @internal */
    [ListSymbol.readonly] = false;
    get length() {
      return this.items.length;
    }
    get readonly() {
      return this[ListSymbol.readonly];
    }
    /**
     * Returns the index of the first occurrence of the given item, or -1 if it is not present.
     */
    indexOf(item) {
      return this.items.indexOf(item);
    }
    /**
     * Returns an item matching the given `id`, or `null` if not present.
     */
    getById(id) {
      if (id === "")
        return null;
      return this.items.find((item) => item.id === id) ?? null;
    }
    /**
     * Transform list to an array.
     */
    toArray() {
      return [...this.items];
    }
    [Symbol.iterator]() {
      return this.items.values();
    }
    /** @internal */
    [ListSymbol.add](item, trigger) {
      const index = this.items.length;
      if (!("" + index in this)) {
        Object.defineProperty(this, index, {
          get() {
            return this.items[index];
          }
        });
      }
      if (this.items.includes(item))
        return;
      this.items.push(item);
      this.dispatchEvent(new DOMEvent("add", { detail: item, trigger }));
    }
    /** @internal */
    [ListSymbol.remove](item, trigger) {
      const index = this.items.indexOf(item);
      if (index >= 0) {
        this[ListSymbol.onRemove]?.(item, trigger);
        this.items.splice(index, 1);
        this.dispatchEvent(new DOMEvent("remove", { detail: item, trigger }));
      }
    }
    /** @internal */
    [ListSymbol.reset](trigger) {
      for (const item of [...this.items])
        this[ListSymbol.remove](item, trigger);
      this.items = [];
      this[ListSymbol.setReadonly](false, trigger);
      this[ListSymbol.onReset]?.();
    }
    /** @internal */
    [ListSymbol.setReadonly](readonly, trigger) {
      if (this[ListSymbol.readonly] === readonly)
        return;
      this[ListSymbol.readonly] = readonly;
      this.dispatchEvent(new DOMEvent("readonly-change", { detail: readonly, trigger }));
    }
  };
  var CAN_FULLSCREEN = fscreen.fullscreenEnabled;
  var FullscreenController = class extends ViewController {
    /**
     * Tracks whether we're the active fullscreen event listener. Fullscreen events can only be
     * listened to globally on the document so we need to know if they relate to the current host
     * element or not.
     */
    #listening = false;
    #active = false;
    get active() {
      return this.#active;
    }
    get supported() {
      return CAN_FULLSCREEN;
    }
    onConnect() {
      new EventsController(fscreen).add("fullscreenchange", this.#onChange.bind(this)).add("fullscreenerror", this.#onError.bind(this));
      onDispose(this.#onDisconnect.bind(this));
    }
    async #onDisconnect() {
      if (CAN_FULLSCREEN)
        await this.exit();
    }
    #onChange(event2) {
      const active = isFullscreen(this.el);
      if (active === this.#active)
        return;
      if (!active)
        this.#listening = false;
      this.#active = active;
      this.dispatch("fullscreen-change", { detail: active, trigger: event2 });
    }
    #onError(event2) {
      if (!this.#listening)
        return;
      this.dispatch("fullscreen-error", { detail: null, trigger: event2 });
      this.#listening = false;
    }
    async enter() {
      try {
        this.#listening = true;
        if (!this.el || isFullscreen(this.el))
          return;
        assertFullscreenAPI();
        return fscreen.requestFullscreen(this.el);
      } catch (error) {
        this.#listening = false;
        throw error;
      }
    }
    async exit() {
      if (!this.el || !isFullscreen(this.el))
        return;
      assertFullscreenAPI();
      return fscreen.exitFullscreen();
    }
  };
  function isFullscreen(host) {
    if (fscreen.fullscreenElement === host)
      return true;
    try {
      return host.matches(
        // @ts-expect-error - `fullscreenPseudoClass` is missing from `@types/fscreen`.
        fscreen.fullscreenPseudoClass
      );
    } catch (error) {
      return false;
    }
  }
  function assertFullscreenAPI() {
    if (CAN_FULLSCREEN)
      return;
    throw Error(
      "[vidstack] no fullscreen API"
    );
  }
  var ScreenOrientationController = class _ScreenOrientationController extends ViewController {
    #type = signal(this.#getScreenOrientation());
    #locked = signal(false);
    #currentLock;
    /**
     * The current screen orientation type.
     *
     * @signal
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/ScreenOrientation}
     * @see https://w3c.github.io/screen-orientation/#screen-orientation-types-and-locks
     */
    get type() {
      return this.#type();
    }
    /**
     * Whether the screen orientation is currently locked.
     *
     * @signal
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/ScreenOrientation}
     * @see https://w3c.github.io/screen-orientation/#screen-orientation-types-and-locks
     */
    get locked() {
      return this.#locked();
    }
    /**
     * Whether the viewport is in a portrait orientation.
     *
     * @signal
     */
    get portrait() {
      return this.#type().startsWith("portrait");
    }
    /**
     * Whether the viewport is in a landscape orientation.
     *
     * @signal
     */
    get landscape() {
      return this.#type().startsWith("landscape");
    }
    /**
     * Whether the native Screen Orientation API is available.
     */
    static supported = canOrientScreen();
    /**
     * Whether the native Screen Orientation API is available.
     */
    get supported() {
      return _ScreenOrientationController.supported;
    }
    onConnect() {
      if (this.supported) {
        listenEvent(screen.orientation, "change", this.#onOrientationChange.bind(this));
      } else {
        const query = window.matchMedia("(orientation: landscape)");
        query.onchange = this.#onOrientationChange.bind(this);
        onDispose(() => query.onchange = null);
      }
      onDispose(this.#onDisconnect.bind(this));
    }
    async #onDisconnect() {
      if (this.supported && this.#locked())
        await this.unlock();
    }
    #onOrientationChange(event2) {
      this.#type.set(this.#getScreenOrientation());
      this.dispatch("orientation-change", {
        detail: {
          orientation: peek(this.#type),
          lock: this.#currentLock
        },
        trigger: event2
      });
    }
    /**
     * Locks the orientation of the screen to the desired orientation type using the
     * Screen Orientation API.
     *
     * @param lockType - The screen lock orientation type.
     * @throws Error - If screen orientation API is unavailable.
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Screen/orientation}
     * @see {@link https://w3c.github.io/screen-orientation}
     */
    async lock(lockType) {
      if (peek(this.#locked) || this.#currentLock === lockType)
        return;
      this.#assertScreenOrientationAPI();
      await screen.orientation.lock(lockType);
      this.#locked.set(true);
      this.#currentLock = lockType;
    }
    /**
     * Unlocks the orientation of the screen to it's default state using the Screen Orientation
     * API. This method will throw an error if the API is unavailable.
     *
     * @throws Error - If screen orientation API is unavailable.
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Screen/orientation}
     * @see {@link https://w3c.github.io/screen-orientation}
     */
    async unlock() {
      if (!peek(this.#locked))
        return;
      this.#assertScreenOrientationAPI();
      this.#currentLock = void 0;
      await screen.orientation.unlock();
      this.#locked.set(false);
    }
    #assertScreenOrientationAPI() {
      if (this.supported)
        return;
      throw Error(
        "[vidstack] no orientation API"
      );
    }
    #getScreenOrientation() {
      if (this.supported)
        return window.screen.orientation.type;
      return window.innerWidth >= window.innerHeight ? "landscape-primary" : "portrait-primary";
    }
  };
  function isVideoQualitySrc(src) {
    return !isString(src) && "width" in src && "height" in src && isNumber(src.width) && isNumber(src.height);
  }
  var mediaState = new State({
    artist: "",
    artwork: null,
    audioTrack: null,
    audioTracks: [],
    autoPlay: false,
    autoPlayError: null,
    audioGain: null,
    buffered: new TimeRange(),
    canLoad: false,
    canLoadPoster: false,
    canFullscreen: false,
    canOrientScreen: canOrientScreen(),
    canPictureInPicture: false,
    canPlay: false,
    clipStartTime: 0,
    clipEndTime: 0,
    controls: false,
    get iOSControls() {
      return IS_IPHONE && this.mediaType === "video" && (!this.playsInline || !fscreen.fullscreenEnabled && this.fullscreen);
    },
    get nativeControls() {
      return this.controls || this.iOSControls;
    },
    controlsVisible: false,
    get controlsHidden() {
      return !this.controlsVisible;
    },
    crossOrigin: null,
    ended: false,
    error: null,
    fullscreen: false,
    get loop() {
      return this.providedLoop || this.userPrefersLoop;
    },
    logLevel: "silent",
    mediaType: "unknown",
    muted: false,
    paused: true,
    played: new TimeRange(),
    playing: false,
    playsInline: false,
    pictureInPicture: false,
    preload: "metadata",
    playbackRate: 1,
    qualities: [],
    quality: null,
    autoQuality: false,
    canSetQuality: true,
    canSetPlaybackRate: true,
    canSetVolume: false,
    canSetAudioGain: false,
    seekable: new TimeRange(),
    seeking: false,
    source: { src: "", type: "" },
    sources: [],
    started: false,
    textTracks: [],
    textTrack: null,
    get hasCaptions() {
      return this.textTracks.filter(isTrackCaptionKind).length > 0;
    },
    volume: 1,
    waiting: false,
    realCurrentTime: 0,
    get currentTime() {
      return this.ended ? this.duration : this.clipStartTime > 0 ? Math.max(0, Math.min(this.realCurrentTime - this.clipStartTime, this.duration)) : this.realCurrentTime;
    },
    providedDuration: -1,
    intrinsicDuration: 0,
    get realDuration() {
      return this.providedDuration > 0 ? this.providedDuration : this.intrinsicDuration;
    },
    get duration() {
      return this.clipEndTime > 0 ? this.clipEndTime - this.clipStartTime : Math.max(0, this.realDuration - this.clipStartTime);
    },
    get title() {
      return this.providedTitle || this.inferredTitle;
    },
    get poster() {
      return this.providedPoster || this.inferredPoster;
    },
    get viewType() {
      return this.providedViewType !== "unknown" ? this.providedViewType : this.inferredViewType;
    },
    get streamType() {
      return this.providedStreamType !== "unknown" ? this.providedStreamType : this.inferredStreamType;
    },
    get currentSrc() {
      return this.source;
    },
    get bufferedStart() {
      const start = getTimeRangesStart(this.buffered) ?? 0;
      return Math.max(0, start - this.clipStartTime);
    },
    get bufferedEnd() {
      const end = getTimeRangesEnd(this.buffered) ?? 0;
      return Math.min(this.duration, Math.max(0, end - this.clipStartTime));
    },
    get seekableStart() {
      const start = getTimeRangesStart(this.seekable) ?? 0;
      return Math.max(0, Math.abs(start - this.clipStartTime));
    },
    get seekableEnd() {
      const end = this.canPlay ? getTimeRangesEnd(this.seekable) ?? Infinity : 0;
      return this.clipEndTime > 0 ? Math.max(this.clipEndTime, Math.max(0, end - this.clipStartTime)) : end;
    },
    get seekableWindow() {
      return Math.max(0, this.seekableEnd - this.seekableStart);
    },
    // ~~ remote playback ~~
    canAirPlay: false,
    canGoogleCast: false,
    remotePlaybackState: "disconnected",
    remotePlaybackType: "none",
    remotePlaybackLoader: null,
    remotePlaybackInfo: null,
    get isAirPlayConnected() {
      return this.remotePlaybackType === "airplay" && this.remotePlaybackState === "connected";
    },
    get isGoogleCastConnected() {
      return this.remotePlaybackType === "google-cast" && this.remotePlaybackState === "connected";
    },
    // ~~ responsive design ~~
    pointer: "fine",
    orientation: "landscape",
    width: 0,
    height: 0,
    mediaWidth: 0,
    mediaHeight: 0,
    lastKeyboardAction: null,
    // ~~ user props ~~
    userBehindLiveEdge: false,
    // ~~ live props ~~
    liveEdgeTolerance: 10,
    minLiveDVRWindow: 60,
    get canSeek() {
      return /unknown|on-demand|:dvr/.test(this.streamType) && Number.isFinite(this.seekableWindow) && (!this.live || /:dvr/.test(this.streamType) && this.seekableWindow >= this.minLiveDVRWindow);
    },
    get live() {
      return this.streamType.includes("live") || !Number.isFinite(this.realDuration);
    },
    get liveEdgeStart() {
      return this.live && Number.isFinite(this.seekableEnd) ? Math.max(0, (this.liveSyncPosition ?? this.seekableEnd) - this.liveEdgeTolerance) : 0;
    },
    get liveEdge() {
      return this.live && (!this.canSeek || !this.userBehindLiveEdge && this.currentTime >= this.liveEdgeStart);
    },
    get liveEdgeWindow() {
      return this.live && Number.isFinite(this.seekableEnd) ? this.seekableEnd - this.liveEdgeStart : 0;
    },
    // ~~ internal props ~~
    autoPlaying: false,
    providedTitle: "",
    inferredTitle: "",
    providedLoop: false,
    userPrefersLoop: false,
    providedPoster: "",
    inferredPoster: "",
    inferredViewType: "unknown",
    providedViewType: "unknown",
    providedStreamType: "unknown",
    inferredStreamType: "unknown",
    liveSyncPosition: null,
    savedState: null
  });
  var RESET_ON_SRC_QUALITY_CHANGE = /* @__PURE__ */ new Set([
    "autoPlayError",
    "autoPlaying",
    "buffered",
    "canPlay",
    "error",
    "paused",
    "played",
    "playing",
    "seekable",
    "seeking",
    "waiting"
  ]);
  var RESET_ON_SRC_CHANGE = /* @__PURE__ */ new Set([
    ...RESET_ON_SRC_QUALITY_CHANGE,
    "ended",
    "inferredPoster",
    "inferredStreamType",
    "inferredTitle",
    "intrinsicDuration",
    "liveSyncPosition",
    "realCurrentTime",
    "savedState",
    "started",
    "userBehindLiveEdge"
  ]);
  function softResetMediaState($media, isSourceQualityChange = false) {
    const filter = isSourceQualityChange ? RESET_ON_SRC_QUALITY_CHANGE : RESET_ON_SRC_CHANGE;
    mediaState.reset($media, (prop2) => filter.has(prop2));
    tick();
  }
  var MediaRemoteControl = class {
    #target = null;
    #player = null;
    #prevTrackIndex = -1;
    #logger;
    constructor(logger = void 0) {
      this.#logger = logger;
    }
    /**
     * Set the target from which to dispatch media requests events from. The events should bubble
     * up from this target to the player element.
     *
     * @example
     * ```ts
     * const button = document.querySelector('button');
     * remote.setTarget(button);
     * ```
     */
    setTarget(target) {
      this.#target = target;
    }
    /**
     * Returns the current player element. This method will attempt to find the player by
     * searching up from either the given `target` or default target set via `remote.setTarget`.
     *
     * @example
     * ```ts
     * const player = remote.getPlayer();
     * ```
     */
    getPlayer(target) {
      if (this.#player)
        return this.#player;
      (target ?? this.#target)?.dispatchEvent(
        new DOMEvent("find-media-player", {
          detail: (player) => void (this.#player = player),
          bubbles: true,
          composed: true
        })
      );
      return this.#player;
    }
    /**
     * Set the current player element so the remote can support toggle methods such as
     * `togglePaused` as they rely on the current media state.
     */
    setPlayer(player) {
      this.#player = player;
    }
    /**
     * Dispatch a request to start the media loading process. This will only work if the media
     * player has been initialized with a custom loading strategy `load="custom">`.
     *
     * @docs {@link https://www.vidstack.io/docs/player/core-concepts/loading#load-strategies}
     */
    startLoading(trigger) {
      this.#dispatchRequest("media-start-loading", trigger);
    }
    /**
     * Dispatch a request to start the poster loading process. This will only work if the media
     * player has been initialized with a custom poster loading strategy `posterLoad="custom">`.
     *
     * @docs {@link https://www.vidstack.io/docs/player/core-concepts/loading#load-strategies}
     */
    startLoadingPoster(trigger) {
      this.#dispatchRequest("media-poster-start-loading", trigger);
    }
    /**
     * Dispatch a request to connect to AirPlay.
     *
     * @see {@link https://www.apple.com/au/airplay}
     */
    requestAirPlay(trigger) {
      this.#dispatchRequest("media-airplay-request", trigger);
    }
    /**
     * Dispatch a request to connect to Google Cast.
     *
     * @see {@link https://developers.google.com/cast/docs/overview}
     */
    requestGoogleCast(trigger) {
      this.#dispatchRequest("media-google-cast-request", trigger);
    }
    /**
     * Dispatch a request to begin/resume media playback.
     */
    play(trigger) {
      this.#dispatchRequest("media-play-request", trigger);
    }
    /**
     * Dispatch a request to pause media playback.
     */
    pause(trigger) {
      this.#dispatchRequest("media-pause-request", trigger);
    }
    /**
     * Dispatch a request to set the media volume to mute (0).
     */
    mute(trigger) {
      this.#dispatchRequest("media-mute-request", trigger);
    }
    /**
     * Dispatch a request to unmute the media volume and set it back to it's previous state.
     */
    unmute(trigger) {
      this.#dispatchRequest("media-unmute-request", trigger);
    }
    /**
     * Dispatch a request to enter fullscreen.
     *
     * @docs {@link https://www.vidstack.io/docs/player/api/fullscreen#remote-control}
     */
    enterFullscreen(target, trigger) {
      this.#dispatchRequest("media-enter-fullscreen-request", trigger, target);
    }
    /**
     * Dispatch a request to exit fullscreen.
     *
     * @docs {@link https://www.vidstack.io/docs/player/api/fullscreen#remote-control}
     */
    exitFullscreen(target, trigger) {
      this.#dispatchRequest("media-exit-fullscreen-request", trigger, target);
    }
    /**
     * Dispatch a request to lock the screen orientation.
     *
     * @docs {@link https://www.vidstack.io/docs/player/screen-orientation#remote-control}
     */
    lockScreenOrientation(lockType, trigger) {
      this.#dispatchRequest("media-orientation-lock-request", trigger, lockType);
    }
    /**
     * Dispatch a request to unlock the screen orientation.
     *
     * @docs {@link https://www.vidstack.io/docs/player/api/screen-orientation#remote-control}
     */
    unlockScreenOrientation(trigger) {
      this.#dispatchRequest("media-orientation-unlock-request", trigger);
    }
    /**
     * Dispatch a request to enter picture-in-picture mode.
     *
     * @docs {@link https://www.vidstack.io/docs/player/api/picture-in-picture#remote-control}
     */
    enterPictureInPicture(trigger) {
      this.#dispatchRequest("media-enter-pip-request", trigger);
    }
    /**
     * Dispatch a request to exit picture-in-picture mode.
     *
     * @docs {@link https://www.vidstack.io/docs/player/api/picture-in-picture#remote-control}
     */
    exitPictureInPicture(trigger) {
      this.#dispatchRequest("media-exit-pip-request", trigger);
    }
    /**
     * Notify the media player that a seeking process is happening and to seek to the given `time`.
     */
    seeking(time, trigger) {
      this.#dispatchRequest("media-seeking-request", trigger, time);
    }
    /**
     * Notify the media player that a seeking operation has completed and to seek to the given `time`.
     * This is generally called after a series of `remote.seeking()` calls.
     */
    seek(time, trigger) {
      this.#dispatchRequest("media-seek-request", trigger, time);
    }
    seekToLiveEdge(trigger) {
      this.#dispatchRequest("media-live-edge-request", trigger);
    }
    /**
     * Dispatch a request to update the length of the media in seconds.
     *
     * @example
     * ```ts
     * remote.changeDuration(100); // 100 seconds
     * ```
     */
    changeDuration(duration, trigger) {
      this.#dispatchRequest("media-duration-change-request", trigger, duration);
    }
    /**
     * Dispatch a request to update the clip start time. This is the time at which media playback
     * should start at.
     *
     * @example
     * ```ts
     * remote.changeClipStart(100); // start at 100 seconds
     * ```
     */
    changeClipStart(startTime, trigger) {
      this.#dispatchRequest("media-clip-start-change-request", trigger, startTime);
    }
    /**
     * Dispatch a request to update the clip end time. This is the time at which media playback
     * should end at.
     *
     * @example
     * ```ts
     * remote.changeClipEnd(100); // end at 100 seconds
     * ```
     */
    changeClipEnd(endTime, trigger) {
      this.#dispatchRequest("media-clip-end-change-request", trigger, endTime);
    }
    /**
     * Dispatch a request to update the media volume to the given `volume` level which is a value
     * between 0 and 1.
     *
     * @docs {@link https://www.vidstack.io/docs/player/api/audio-gain#remote-control}
     * @example
     * ```ts
     * remote.changeVolume(0); // 0%
     * remote.changeVolume(0.05); // 5%
     * remote.changeVolume(0.5); // 50%
     * remote.changeVolume(0.75); // 70%
     * remote.changeVolume(1); // 100%
     * ```
     */
    changeVolume(volume, trigger) {
      this.#dispatchRequest("media-volume-change-request", trigger, Math.max(0, Math.min(1, volume)));
    }
    /**
     * Dispatch a request to change the current audio track.
     *
     * @example
     * ```ts
     * remote.changeAudioTrack(1); // track at index 1
     * ```
     */
    changeAudioTrack(index, trigger) {
      this.#dispatchRequest("media-audio-track-change-request", trigger, index);
    }
    /**
     * Dispatch a request to change the video quality. The special value `-1` represents auto quality
     * selection.
     *
     * @example
     * ```ts
     * remote.changeQuality(-1); // auto
     * remote.changeQuality(1); // quality at index 1
     * ```
     */
    changeQuality(index, trigger) {
      this.#dispatchRequest("media-quality-change-request", trigger, index);
    }
    /**
     * Request auto quality selection.
     */
    requestAutoQuality(trigger) {
      this.changeQuality(-1, trigger);
    }
    /**
     * Dispatch a request to change the mode of the text track at the given index.
     *
     * @example
     * ```ts
     * remote.changeTextTrackMode(1, 'showing'); // track at index 1
     * ```
     */
    changeTextTrackMode(index, mode, trigger) {
      this.#dispatchRequest("media-text-track-change-request", trigger, {
        index,
        mode
      });
    }
    /**
     * Dispatch a request to change the media playback rate.
     *
     * @example
     * ```ts
     * remote.changePlaybackRate(0.5); // Half the normal speed
     * remote.changePlaybackRate(1); // Normal speed
     * remote.changePlaybackRate(1.5); // 50% faster than normal
     * remote.changePlaybackRate(2); // Double the normal speed
     * ```
     */
    changePlaybackRate(rate, trigger) {
      this.#dispatchRequest("media-rate-change-request", trigger, rate);
    }
    /**
     * Dispatch a request to change the media audio gain.
     *
     * @example
     * ```ts
     * remote.changeAudioGain(1); // Disable audio gain
     * remote.changeAudioGain(1.5); // 50% louder
     * remote.changeAudioGain(2); // 100% louder
     * ```
     */
    changeAudioGain(gain, trigger) {
      this.#dispatchRequest("media-audio-gain-change-request", trigger, gain);
    }
    /**
     * Dispatch a request to resume idle tracking on controls.
     */
    resumeControls(trigger) {
      this.#dispatchRequest("media-resume-controls-request", trigger);
    }
    /**
     * Dispatch a request to pause controls idle tracking. Pausing tracking will result in the
     * controls being visible until `remote.resumeControls()` is called. This method
     * is generally used when building custom controls and you'd like to prevent the UI from
     * disappearing.
     *
     * @example
     * ```ts
     * // Prevent controls hiding while menu is being interacted with.
     * function onSettingsOpen() {
     *   remote.pauseControls();
     * }
     *
     * function onSettingsClose() {
     *   remote.resumeControls();
     * }
     * ```
     */
    pauseControls(trigger) {
      this.#dispatchRequest("media-pause-controls-request", trigger);
    }
    /**
     * Dispatch a request to toggle the media playback state.
     */
    togglePaused(trigger) {
      const player = this.getPlayer(trigger?.target);
      if (!player) {
        return;
      }
      if (player.state.paused)
        this.play(trigger);
      else
        this.pause(trigger);
    }
    /**
     * Dispatch a request to toggle the controls visibility.
     */
    toggleControls(trigger) {
      const player = this.getPlayer(trigger?.target);
      if (!player) {
        return;
      }
      if (!player.controls.showing) {
        player.controls.show(0, trigger);
      } else {
        player.controls.hide(0, trigger);
      }
    }
    /**
     * Dispatch a request to toggle the media muted state.
     */
    toggleMuted(trigger) {
      const player = this.getPlayer(trigger?.target);
      if (!player) {
        return;
      }
      if (player.state.muted)
        this.unmute(trigger);
      else
        this.mute(trigger);
    }
    /**
     * Dispatch a request to toggle the media fullscreen state.
     *
     * @docs {@link https://www.vidstack.io/docs/player/api/fullscreen#remote-control}
     */
    toggleFullscreen(target, trigger) {
      const player = this.getPlayer(trigger?.target);
      if (!player) {
        return;
      }
      if (player.state.fullscreen)
        this.exitFullscreen(target, trigger);
      else
        this.enterFullscreen(target, trigger);
    }
    /**
     * Dispatch a request to toggle the media picture-in-picture mode.
     *
     * @docs {@link https://www.vidstack.io/docs/player/api/picture-in-picture#remote-control}
     */
    togglePictureInPicture(trigger) {
      const player = this.getPlayer(trigger?.target);
      if (!player) {
        return;
      }
      if (player.state.pictureInPicture)
        this.exitPictureInPicture(trigger);
      else
        this.enterPictureInPicture(trigger);
    }
    /**
     * Show captions.
     */
    showCaptions(trigger) {
      const player = this.getPlayer(trigger?.target);
      if (!player) {
        return;
      }
      let tracks = player.state.textTracks, index = this.#prevTrackIndex;
      if (!tracks[index] || !isTrackCaptionKind(tracks[index])) {
        index = -1;
      }
      if (index === -1) {
        index = tracks.findIndex((track) => isTrackCaptionKind(track) && track.default);
      }
      if (index === -1) {
        index = tracks.findIndex((track) => isTrackCaptionKind(track));
      }
      if (index >= 0)
        this.changeTextTrackMode(index, "showing", trigger);
      this.#prevTrackIndex = -1;
    }
    /**
     * Turn captions off.
     */
    disableCaptions(trigger) {
      const player = this.getPlayer(trigger?.target);
      if (!player) {
        return;
      }
      const tracks = player.state.textTracks, track = player.state.textTrack;
      if (track) {
        const index = tracks.indexOf(track);
        this.changeTextTrackMode(index, "disabled", trigger);
        this.#prevTrackIndex = index;
      }
    }
    /**
     * Dispatch a request to toggle the current captions mode.
     */
    toggleCaptions(trigger) {
      const player = this.getPlayer(trigger?.target);
      if (!player) {
        return;
      }
      if (player.state.textTrack) {
        this.disableCaptions();
      } else {
        this.showCaptions();
      }
    }
    userPrefersLoopChange(prefersLoop, trigger) {
      this.#dispatchRequest("media-user-loop-change-request", trigger, prefersLoop);
    }
    #dispatchRequest(type, trigger, detail) {
      const request = new DOMEvent(type, {
        bubbles: true,
        composed: true,
        cancelable: true,
        detail,
        trigger
      });
      let target = trigger?.target || null;
      if (target && target instanceof Component)
        target = target.el;
      const shouldUsePlayer = !target || target === document || target === window || target === document.body || this.#player?.el && target instanceof Node && !this.#player.el.contains(target);
      target = shouldUsePlayer ? this.#target ?? this.getPlayer()?.el : target ?? this.#target;
      if (this.#player) {
        if (type === "media-play-request" && !this.#player.state.canLoad) {
          target?.dispatchEvent(request);
        } else {
          this.#player.canPlayQueue.enqueue(type, () => target?.dispatchEvent(request));
        }
      } else {
        target?.dispatchEvent(request);
      }
    }
    #noPlayerWarning(method2) {
    }
  };
  var LocalMediaStorage = class {
    playerId = "vds-player";
    mediaId = null;
    #data = {
      volume: null,
      muted: null,
      audioGain: null,
      time: null,
      lang: null,
      captions: null,
      rate: null,
      quality: null
    };
    async getVolume() {
      return this.#data.volume;
    }
    async setVolume(volume) {
      this.#data.volume = volume;
      this.save();
    }
    async getMuted() {
      return this.#data.muted;
    }
    async setMuted(muted) {
      this.#data.muted = muted;
      this.save();
    }
    async getTime() {
      return this.#data.time;
    }
    async setTime(time, ended) {
      const shouldClear = time < 0;
      this.#data.time = !shouldClear ? time : null;
      if (shouldClear || ended)
        this.saveTime();
      else
        this.saveTimeThrottled();
    }
    async getLang() {
      return this.#data.lang;
    }
    async setLang(lang) {
      this.#data.lang = lang;
      this.save();
    }
    async getCaptions() {
      return this.#data.captions;
    }
    async setCaptions(enabled) {
      this.#data.captions = enabled;
      this.save();
    }
    async getPlaybackRate() {
      return this.#data.rate;
    }
    async setPlaybackRate(rate) {
      this.#data.rate = rate;
      this.save();
    }
    async getAudioGain() {
      return this.#data.audioGain;
    }
    async setAudioGain(gain) {
      this.#data.audioGain = gain;
      this.save();
    }
    async getVideoQuality() {
      return this.#data.quality;
    }
    async setVideoQuality(quality) {
      this.#data.quality = quality;
      this.save();
    }
    onChange(src, mediaId, playerId = "vds-player") {
      const savedData = playerId ? localStorage.getItem(playerId) : null, savedTime = mediaId ? localStorage.getItem(mediaId) : null;
      this.playerId = playerId;
      this.mediaId = mediaId;
      this.#data = {
        volume: null,
        muted: null,
        audioGain: null,
        lang: null,
        captions: null,
        rate: null,
        quality: null,
        ...savedData ? JSON.parse(savedData) : {},
        time: savedTime ? +savedTime : null
      };
    }
    save() {
      if (!this.playerId)
        return;
      const data = JSON.stringify({ ...this.#data, time: void 0 });
      localStorage.setItem(this.playerId, data);
    }
    saveTimeThrottled = functionThrottle(this.saveTime.bind(this), 1e3);
    saveTime() {
      if (!this.mediaId)
        return;
      const data = (this.#data.time ?? 0).toString();
      localStorage.setItem(this.mediaId, data);
    }
  };
  var NativeTextRenderer = class {
    priority = 0;
    #display = true;
    #video = null;
    #track = null;
    #tracks = /* @__PURE__ */ new Set();
    canRender(_2, video) {
      return !!video;
    }
    attach(video) {
      this.#video = video;
      if (video)
        video.textTracks.onchange = this.#onChange.bind(this);
    }
    addTrack(track) {
      this.#tracks.add(track);
      this.#attachTrack(track);
    }
    removeTrack(track) {
      track[TextTrackSymbol.native]?.remove?.();
      track[TextTrackSymbol.native] = null;
      this.#tracks.delete(track);
    }
    changeTrack(track) {
      const current = track?.[TextTrackSymbol.native];
      if (current && current.track.mode !== "showing") {
        current.track.mode = "showing";
      }
      this.#track = track;
    }
    setDisplay(display) {
      this.#display = display;
      this.#onChange();
    }
    detach() {
      if (this.#video)
        this.#video.textTracks.onchange = null;
      for (const track of this.#tracks)
        this.removeTrack(track);
      this.#tracks.clear();
      this.#video = null;
      this.#track = null;
    }
    #attachTrack(track) {
      if (!this.#video)
        return;
      const el = track[TextTrackSymbol.native] ??= this.#createTrackElement(track);
      if (isHTMLElement2(el)) {
        this.#video.append(el);
        el.track.mode = el.default ? "showing" : "disabled";
      }
    }
    #createTrackElement(track) {
      const el = document.createElement("track"), isDefault = track.default || track.mode === "showing", isSupported = track.src && track.type === "vtt";
      el.id = track.id;
      el.src = isSupported ? track.src : "";
      el.label = track.label;
      el.kind = track.kind;
      el.default = isDefault;
      track.language && (el.srclang = track.language);
      if (isDefault && !isSupported) {
        this.#copyCues(track, el.track);
      }
      return el;
    }
    #copyCues(track, native) {
      if (track.src && track.type === "vtt" || native.cues?.length)
        return;
      for (const cue of track.cues)
        native.addCue(cue);
    }
    #onChange(event2) {
      for (const track of this.#tracks) {
        const native = track[TextTrackSymbol.native];
        if (!native)
          continue;
        if (!this.#display) {
          native.track.mode = native.managed ? "hidden" : "disabled";
          continue;
        }
        const isShowing = native.track.mode === "showing";
        if (isShowing)
          this.#copyCues(track, native.track);
        track.setMode(isShowing ? "showing" : "disabled", event2);
      }
    }
  };
  var TextRenderers = class {
    #video = null;
    #textTracks;
    #renderers = [];
    #media;
    #nativeDisplay = false;
    #nativeRenderer = null;
    #customRenderer = null;
    constructor(media) {
      this.#media = media;
      const textTracks = media.textTracks;
      this.#textTracks = textTracks;
      effect(this.#watchControls.bind(this));
      onDispose(this.#detach.bind(this));
      new EventsController(textTracks).add("add", this.#onAddTrack.bind(this)).add("remove", this.#onRemoveTrack.bind(this)).add("mode-change", this.#update.bind(this));
    }
    #watchControls() {
      const { nativeControls } = this.#media.$state;
      this.#nativeDisplay = nativeControls();
      this.#update();
    }
    add(renderer) {
      this.#renderers.push(renderer);
      untrack(this.#update.bind(this));
    }
    remove(renderer) {
      renderer.detach();
      this.#renderers.splice(this.#renderers.indexOf(renderer), 1);
      untrack(this.#update.bind(this));
    }
    /** @internal */
    attachVideo(video) {
      requestAnimationFrame(() => {
        this.#video = video;
        if (video) {
          this.#nativeRenderer = new NativeTextRenderer();
          this.#nativeRenderer.attach(video);
          for (const track of this.#textTracks)
            this.#addNativeTrack(track);
        }
        this.#update();
      });
    }
    #addNativeTrack(track) {
      if (!isTrackCaptionKind(track))
        return;
      this.#nativeRenderer?.addTrack(track);
    }
    #removeNativeTrack(track) {
      if (!isTrackCaptionKind(track))
        return;
      this.#nativeRenderer?.removeTrack(track);
    }
    #onAddTrack(event2) {
      this.#addNativeTrack(event2.detail);
    }
    #onRemoveTrack(event2) {
      this.#removeNativeTrack(event2.detail);
    }
    #update() {
      const currentTrack = this.#textTracks.selected;
      if (this.#video && (this.#nativeDisplay || currentTrack?.[TextTrackSymbol.nativeHLS])) {
        this.#customRenderer?.changeTrack(null);
        this.#nativeRenderer?.setDisplay(true);
        this.#nativeRenderer?.changeTrack(currentTrack);
        return;
      }
      this.#nativeRenderer?.setDisplay(false);
      this.#nativeRenderer?.changeTrack(null);
      if (!currentTrack) {
        this.#customRenderer?.changeTrack(null);
        return;
      }
      const customRenderer = this.#renderers.sort((a4, b2) => a4.priority - b2.priority).find((renderer) => renderer.canRender(currentTrack, this.#video));
      if (this.#customRenderer !== customRenderer) {
        this.#customRenderer?.detach();
        customRenderer?.attach(this.#video);
        this.#customRenderer = customRenderer ?? null;
      }
      customRenderer?.changeTrack(currentTrack);
    }
    #detach() {
      this.#nativeRenderer?.detach();
      this.#nativeRenderer = null;
      this.#customRenderer?.detach();
      this.#customRenderer = null;
    }
  };
  var TextTrackList = class extends List {
    #canLoad = false;
    #defaults = {};
    #storage = null;
    #preferredLang = null;
    /** @internal */
    [TextTrackSymbol.crossOrigin];
    constructor() {
      super();
    }
    get selected() {
      const track = this.items.find((t6) => t6.mode === "showing" && isTrackCaptionKind(t6));
      return track ?? null;
    }
    get selectedIndex() {
      const selected = this.selected;
      return selected ? this.indexOf(selected) : -1;
    }
    get preferredLang() {
      return this.#preferredLang;
    }
    set preferredLang(lang) {
      this.#preferredLang = lang;
      this.#saveLang(lang);
    }
    add(init5, trigger) {
      const isTrack = init5 instanceof TextTrack, track = isTrack ? init5 : new TextTrack(init5), kind = init5.kind === "captions" || init5.kind === "subtitles" ? "captions" : init5.kind;
      if (this.#defaults[kind] && init5.default)
        delete init5.default;
      track.addEventListener("mode-change", this.#onTrackModeChangeBind);
      this[ListSymbol.add](track, trigger);
      track[TextTrackSymbol.crossOrigin] = this[TextTrackSymbol.crossOrigin];
      if (this.#canLoad)
        track[TextTrackSymbol.canLoad]();
      if (init5.default)
        this.#defaults[kind] = track;
      this.#selectTracks();
      return this;
    }
    remove(track, trigger) {
      this.#pendingRemoval = track;
      if (!this.items.includes(track))
        return;
      if (track === this.#defaults[track.kind])
        delete this.#defaults[track.kind];
      track.mode = "disabled";
      track[TextTrackSymbol.onModeChange] = null;
      track.removeEventListener("mode-change", this.#onTrackModeChangeBind);
      this[ListSymbol.remove](track, trigger);
      this.#pendingRemoval = null;
      return this;
    }
    clear(trigger) {
      for (const track of [...this.items]) {
        this.remove(track, trigger);
      }
      return this;
    }
    getByKind(kind) {
      const kinds = Array.isArray(kind) ? kind : [kind];
      return this.items.filter((track) => kinds.includes(track.kind));
    }
    /** @internal */
    [TextTrackSymbol.canLoad]() {
      if (this.#canLoad)
        return;
      for (const track of this.items)
        track[TextTrackSymbol.canLoad]();
      this.#canLoad = true;
      this.#selectTracks();
    }
    #selectTracks = functionDebounce(async () => {
      if (!this.#canLoad)
        return;
      if (!this.#preferredLang && this.#storage) {
        this.#preferredLang = await this.#storage.getLang();
      }
      const showCaptions = await this.#storage?.getCaptions(), kinds = [
        ["captions", "subtitles"],
        "chapters",
        "descriptions",
        "metadata"
      ];
      for (const kind of kinds) {
        const tracks = this.getByKind(kind);
        if (tracks.find((t6) => t6.mode === "showing"))
          continue;
        const preferredTrack = this.#preferredLang ? tracks.find((track2) => track2.language === this.#preferredLang) : null;
        const defaultTrack = isArray(kind) ? this.#defaults[kind.find((kind2) => this.#defaults[kind2]) || ""] : this.#defaults[kind];
        const track = preferredTrack ?? defaultTrack, isCaptionsKind = track && isTrackCaptionKind(track);
        if (track && (!isCaptionsKind || showCaptions !== false)) {
          track.mode = "showing";
          if (isCaptionsKind)
            this.#saveCaptionsTrack(track);
        }
      }
    }, 300);
    #pendingRemoval = null;
    #onTrackModeChangeBind = this.#onTrackModeChange.bind(this);
    #onTrackModeChange(event2) {
      const track = event2.detail;
      if (this.#storage && isTrackCaptionKind(track) && track !== this.#pendingRemoval) {
        this.#saveCaptionsTrack(track);
      }
      if (track.mode === "showing") {
        const kinds = isTrackCaptionKind(track) ? ["captions", "subtitles"] : [track.kind];
        for (const t6 of this.items) {
          if (t6.mode === "showing" && t6 != track && kinds.includes(t6.kind)) {
            t6.mode = "disabled";
          }
        }
      }
      this.dispatchEvent(
        new DOMEvent("mode-change", {
          detail: event2.detail,
          trigger: event2
        })
      );
    }
    #saveCaptionsTrack(track) {
      if (track.mode !== "disabled") {
        this.#saveLang(track.language);
      }
      this.#storage?.setCaptions?.(track.mode === "showing");
    }
    #saveLang(lang) {
      this.#storage?.setLang?.(this.#preferredLang = lang);
    }
    setStorage(storage) {
      this.#storage = storage;
    }
  };
  var SELECTED = Symbol(0);
  var SelectList = class extends List {
    get selected() {
      return this.items.find((item) => item.selected) ?? null;
    }
    get selectedIndex() {
      return this.items.findIndex((item) => item.selected);
    }
    /** @internal */
    [ListSymbol.onRemove](item, trigger) {
      this[ListSymbol.select](item, false, trigger);
    }
    /** @internal */
    [ListSymbol.add](item, trigger) {
      item[SELECTED] = false;
      Object.defineProperty(item, "selected", {
        get() {
          return this[SELECTED];
        },
        set: (selected) => {
          if (this.readonly)
            return;
          this[ListSymbol.onUserSelect]?.();
          this[ListSymbol.select](item, selected);
        }
      });
      super[ListSymbol.add](item, trigger);
    }
    /** @internal */
    [ListSymbol.select](item, selected, trigger) {
      if (selected === item?.[SELECTED])
        return;
      const prev = this.selected;
      if (item)
        item[SELECTED] = selected;
      const changed = !selected ? prev === item : prev !== item;
      if (changed) {
        if (prev)
          prev[SELECTED] = false;
        this.dispatchEvent(
          new DOMEvent("change", {
            detail: {
              prev,
              current: this.selected
            },
            trigger
          })
        );
      }
    }
  };
  var AudioTrackList = class extends SelectList {
  };
  var VideoQualityList = class extends SelectList {
    #auto = false;
    /**
     * Configures quality switching:
     *
     * - `current`: Trigger an immediate quality level switch. This will abort the current fragment
     * request if any, flush the whole buffer, and fetch fragment matching with current position
     * and requested quality level.
     *
     * - `next`: Trigger a quality level switch for next fragment. This could eventually flush
     * already buffered next fragment.
     *
     * - `load`: Set quality level for next loaded fragment.
     *
     * @see {@link https://www.vidstack.io/docs/player/api/video-quality#switch}
     * @see {@link https://github.com/video-dev/hls.js/blob/master/docs/API.md#quality-switch-control-api}
     */
    switch = "current";
    /**
     * Whether automatic quality selection is enabled.
     */
    get auto() {
      return this.#auto || this.readonly;
    }
    /** @internal */
    [QualitySymbol.enableAuto];
    /** @internal */
    [ListSymbol.onUserSelect]() {
      this[QualitySymbol.setAuto](false);
    }
    /** @internal */
    [ListSymbol.onReset](trigger) {
      this[QualitySymbol.enableAuto] = void 0;
      this[QualitySymbol.setAuto](false, trigger);
    }
    /**
     * Request automatic quality selection (if supported). This will be a no-op if the list is
     * `readonly` as that already implies auto-selection.
     */
    autoSelect(trigger) {
      if (this.readonly || this.#auto || !this[QualitySymbol.enableAuto])
        return;
      this[QualitySymbol.enableAuto]?.(trigger);
      this[QualitySymbol.setAuto](true, trigger);
    }
    getBySrc(src) {
      return this.items.find((quality) => quality.src === src);
    }
    /** @internal */
    [QualitySymbol.setAuto](auto, trigger) {
      if (this.#auto === auto)
        return;
      this.#auto = auto;
      this.dispatchEvent(
        new DOMEvent("auto-change", {
          detail: auto,
          trigger
        })
      );
    }
  };
  function isHTMLAudioElement(element) {
    return element instanceof HTMLAudioElement;
  }
  function isHTMLVideoElement(element) {
    return element instanceof HTMLVideoElement;
  }
  function isHTMLMediaElement(element) {
    return isHTMLAudioElement(element) || isHTMLVideoElement(element);
  }
  var MediaPlayerController = class extends ViewController {
  };
  var MEDIA_KEY_SHORTCUTS = {
    togglePaused: "k Space",
    toggleMuted: "m",
    toggleFullscreen: "f",
    togglePictureInPicture: "i",
    toggleCaptions: "c",
    seekBackward: "j J ArrowLeft",
    seekForward: "l L ArrowRight",
    volumeUp: "ArrowUp",
    volumeDown: "ArrowDown",
    speedUp: ">",
    slowDown: "<"
  };
  var MODIFIER_KEYS = /* @__PURE__ */ new Set(["Shift", "Alt", "Meta", "Ctrl"]);
  var BUTTON_SELECTORS = 'button, [role="button"]';
  var IGNORE_SELECTORS = 'input, textarea, select, [contenteditable], [role^="menuitem"], [role="timer"]';
  var MediaKeyboardController = class extends MediaPlayerController {
    #media;
    constructor(media) {
      super();
      this.#media = media;
    }
    onConnect() {
      effect(this.#onTargetChange.bind(this));
    }
    #onTargetChange() {
      const { keyDisabled, keyTarget } = this.$props;
      if (keyDisabled())
        return;
      const target = keyTarget() === "player" ? this.el : document, $active = signal(false);
      if (target === this.el) {
        new EventsController(this.el).add("focusin", () => $active.set(true)).add("focusout", (event2) => {
          if (!this.el.contains(event2.target))
            $active.set(false);
        });
      } else {
        if (!peek($active))
          $active.set(document.querySelector("[data-media-player]") === this.el);
        listenEvent(document, "focusin", (event2) => {
          const activePlayer = event2.composedPath().find((el) => el instanceof Element && el.localName === "media-player");
          if (activePlayer !== void 0)
            $active.set(this.el === activePlayer);
        });
      }
      effect(() => {
        if (!$active())
          return;
        new EventsController(target).add("keyup", this.#onKeyUp.bind(this)).add("keydown", this.#onKeyDown.bind(this)).add("keydown", this.#onPreventVideoKeys.bind(this), { capture: true });
      });
    }
    #onKeyUp(event2) {
      const focusedEl = document.activeElement;
      if (!event2.key || !this.$state.canSeek() || focusedEl?.matches(IGNORE_SELECTORS)) {
        return;
      }
      let { method: method2, value } = this.#getMatchingMethod(event2);
      if (!isString(value) && !isArray(value)) {
        value?.onKeyUp?.({
          event: event2,
          player: this.#media.player,
          remote: this.#media.remote
        });
        value?.callback?.(event2, this.#media.remote);
        return;
      }
      if (method2?.startsWith("seek")) {
        event2.preventDefault();
        event2.stopPropagation();
        if (this.#timeSlider) {
          this.#forwardTimeKeyboardEvent(event2, method2 === "seekForward");
          this.#timeSlider = null;
        } else {
          this.#media.remote.seek(this.#seekTotal, event2);
          this.#seekTotal = void 0;
        }
      }
      if (method2?.startsWith("volume")) {
        const volumeSlider = this.el.querySelector("[data-media-volume-slider]");
        volumeSlider?.dispatchEvent(
          new KeyboardEvent("keyup", {
            key: method2 === "volumeUp" ? "Up" : "Down",
            shiftKey: event2.shiftKey,
            trigger: event2
          })
        );
      }
    }
    #onKeyDown(event2) {
      if (!event2.key || MODIFIER_KEYS.has(event2.key))
        return;
      const focusedEl = document.activeElement;
      if (focusedEl?.matches(IGNORE_SELECTORS) || isKeyboardClick(event2) && focusedEl?.matches(BUTTON_SELECTORS)) {
        return;
      }
      let { method: method2, value } = this.#getMatchingMethod(event2), isNumberPress = !event2.metaKey && /^[0-9]$/.test(event2.key);
      if (!isString(value) && !isArray(value) && !isNumberPress) {
        value?.onKeyDown?.({
          event: event2,
          player: this.#media.player,
          remote: this.#media.remote
        });
        value?.callback?.(event2, this.#media.remote);
        return;
      }
      if (!method2 && isNumberPress) {
        event2.preventDefault();
        event2.stopPropagation();
        this.#media.remote.seek(this.$state.duration() / 10 * Number(event2.key), event2);
        return;
      }
      if (!method2)
        return;
      event2.preventDefault();
      event2.stopPropagation();
      switch (method2) {
        case "seekForward":
        case "seekBackward":
          this.#seeking(event2, method2, method2 === "seekForward");
          break;
        case "volumeUp":
        case "volumeDown":
          const volumeSlider = this.el.querySelector("[data-media-volume-slider]");
          if (volumeSlider) {
            volumeSlider.dispatchEvent(
              new KeyboardEvent("keydown", {
                key: method2 === "volumeUp" ? "Up" : "Down",
                shiftKey: event2.shiftKey,
                trigger: event2
              })
            );
          } else {
            const value2 = event2.shiftKey ? 0.1 : 0.05;
            this.#media.remote.changeVolume(
              this.$state.volume() + (method2 === "volumeUp" ? +value2 : -value2),
              event2
            );
          }
          break;
        case "toggleFullscreen":
          this.#media.remote.toggleFullscreen("prefer-media", event2);
          break;
        case "speedUp":
        case "slowDown":
          const playbackRate = this.$state.playbackRate();
          this.#media.remote.changePlaybackRate(
            Math.max(0.25, Math.min(2, playbackRate + (method2 === "speedUp" ? 0.25 : -0.25))),
            event2
          );
          break;
        default:
          this.#media.remote[method2]?.(event2);
      }
      this.$state.lastKeyboardAction.set({
        action: method2,
        event: event2
      });
    }
    #onPreventVideoKeys(event2) {
      if (isHTMLMediaElement(event2.target) && this.#getMatchingMethod(event2).method) {
        event2.preventDefault();
      }
    }
    #getMatchingMethod(event2) {
      const keyShortcuts = {
        ...this.$props.keyShortcuts(),
        ...this.#media.ariaKeys
      };
      const method2 = Object.keys(keyShortcuts).find((method22) => {
        const value = keyShortcuts[method22], keys = isArray(value) ? value.join(" ") : isString(value) ? value : value?.keys;
        const combinations = (isArray(keys) ? keys : keys?.split(" "))?.map(
          (key2) => replaceSymbolKeys(key2).replace(/Control/g, "Ctrl").split("+")
        );
        return combinations?.some((combo) => {
          const modifierKeys = new Set(combo.filter((key2) => MODIFIER_KEYS.has(key2)));
          for (const modKey of MODIFIER_KEYS) {
            const modKeyProp = modKey.toLowerCase() + "Key";
            if (!modifierKeys.has(modKey) && event2[modKeyProp]) {
              return false;
            }
          }
          return combo.every((key2) => {
            return MODIFIER_KEYS.has(key2) ? event2[key2.toLowerCase() + "Key"] : event2.key === key2.replace("Space", " ");
          });
        });
      });
      return {
        method: method2,
        value: method2 ? keyShortcuts[method2] : null
      };
    }
    #seekTotal;
    #calcSeekAmount(event2, type) {
      const seekBy = event2.shiftKey ? 10 : 5;
      return this.#seekTotal = Math.max(
        0,
        Math.min(
          (this.#seekTotal ?? this.$state.currentTime()) + (type === "seekForward" ? +seekBy : -seekBy),
          this.$state.duration()
        )
      );
    }
    #timeSlider = null;
    #forwardTimeKeyboardEvent(event2, forward) {
      this.#timeSlider?.dispatchEvent(
        new KeyboardEvent(event2.type, {
          key: !forward ? "Left" : "Right",
          shiftKey: event2.shiftKey,
          trigger: event2
        })
      );
    }
    #seeking(event2, type, forward) {
      if (!this.$state.canSeek())
        return;
      if (!this.#timeSlider) {
        this.#timeSlider = this.el.querySelector("[data-media-time-slider]");
      }
      if (this.#timeSlider) {
        this.#forwardTimeKeyboardEvent(event2, forward);
      } else {
        this.#media.remote.seeking(this.#calcSeekAmount(event2, type), event2);
      }
    }
  };
  var SYMBOL_KEY_MAP = ["!", "@", "#", "$", "%", "^", "&", "*", "(", ")"];
  function replaceSymbolKeys(key2) {
    return key2.replace(/Shift\+(\d)/g, (_2, num) => SYMBOL_KEY_MAP[num - 1]);
  }
  var MediaControls = class extends MediaPlayerController {
    #idleTimer = -2;
    #pausedTracking = false;
    #hideOnMouseLeave = signal(false);
    #isMouseOutside = signal(false);
    #focusedItem = null;
    #canIdle = signal(true);
    /**
     * The default amount of delay in milliseconds while media playback is progressing without user
     * activity to indicate an idle state (i.e., hide controls).
     *
     * @defaultValue 2000
     */
    defaultDelay = 2e3;
    /**
     * Whether controls can hide after a delay in user interaction. If this is false, controls will
     * not hide and be user controlled.
     */
    get canIdle() {
      return this.#canIdle();
    }
    set canIdle(canIdle) {
      this.#canIdle.set(canIdle);
    }
    /**
     * Whether controls visibility should be toggled when the mouse enters and leaves the player
     * container.
     *
     * @defaultValue false
     */
    get hideOnMouseLeave() {
      const { hideControlsOnMouseLeave } = this.$props;
      return this.#hideOnMouseLeave() || hideControlsOnMouseLeave();
    }
    set hideOnMouseLeave(hide2) {
      this.#hideOnMouseLeave.set(hide2);
    }
    /**
     * Whether media controls are currently visible.
     */
    get showing() {
      return this.$state.controlsVisible();
    }
    /**
     * Show controls.
     */
    show(delay = 0, trigger) {
      this.#clearIdleTimer();
      if (!this.#pausedTracking) {
        this.#changeVisibility(true, delay, trigger);
      }
    }
    /**
     * Hide controls.
     */
    hide(delay = this.defaultDelay, trigger) {
      this.#clearIdleTimer();
      if (!this.#pausedTracking) {
        this.#changeVisibility(false, delay, trigger);
      }
    }
    /**
     * Whether all idle tracking on controls should be paused until resumed again.
     */
    pause(trigger) {
      this.#pausedTracking = true;
      this.#clearIdleTimer();
      this.#changeVisibility(true, 0, trigger);
    }
    resume(trigger) {
      this.#pausedTracking = false;
      if (this.$state.paused())
        return;
      this.#changeVisibility(false, this.defaultDelay, trigger);
    }
    onConnect() {
      effect(this.#init.bind(this));
    }
    #init() {
      const { viewType } = this.$state;
      if (!this.el || !this.#canIdle())
        return;
      if (viewType() === "audio") {
        this.show();
        return;
      }
      effect(this.#watchMouse.bind(this));
      effect(this.#watchPaused.bind(this));
      const onPlay = this.#onPlay.bind(this), onPause = this.#onPause.bind(this), onEnd = this.#onEnd.bind(this);
      new EventsController(this.el).add("can-play", (event2) => this.show(0, event2)).add("play", onPlay).add("pause", onPause).add("end", onEnd).add("auto-play-fail", onPause);
    }
    #watchMouse() {
      if (!this.el)
        return;
      const { started, pointer, paused } = this.$state;
      if (!started() || pointer() !== "fine")
        return;
      const events2 = new EventsController(this.el), shouldHideOnMouseLeave = this.hideOnMouseLeave;
      if (!shouldHideOnMouseLeave || !this.#isMouseOutside()) {
        effect(() => {
          if (!paused())
            events2.add("pointermove", this.#onStopIdle.bind(this));
        });
      }
      if (shouldHideOnMouseLeave) {
        events2.add("mouseenter", this.#onMouseEnter.bind(this)).add("mouseleave", this.#onMouseLeave.bind(this));
      }
    }
    #watchPaused() {
      const { paused, started, autoPlayError } = this.$state;
      if (paused() || autoPlayError() && !started())
        return;
      const onStopIdle = this.#onStopIdle.bind(this);
      effect(() => {
        if (!this.el)
          return;
        const pointer = this.$state.pointer(), isTouch = pointer === "coarse", events2 = new EventsController(this.el), eventTypes = [isTouch ? "touchend" : "pointerup", "keydown"];
        for (const eventType of eventTypes) {
          events2.add(eventType, onStopIdle, { passive: false });
        }
      });
    }
    #onPlay(event2) {
      if (event2.triggers.hasType("ended"))
        return;
      this.show(0, event2);
      this.hide(void 0, event2);
    }
    #onPause(event2) {
      this.show(0, event2);
    }
    #onEnd(event2) {
      const { loop: loop2 } = this.$state;
      if (loop2())
        this.hide(0, event2);
    }
    #onMouseEnter(event2) {
      this.#isMouseOutside.set(false);
      this.show(0, event2);
      this.hide(void 0, event2);
    }
    #onMouseLeave(event2) {
      this.#isMouseOutside.set(true);
      this.hide(0, event2);
    }
    #clearIdleTimer() {
      window.clearTimeout(this.#idleTimer);
      this.#idleTimer = -1;
    }
    #onStopIdle(event2) {
      if (
        // @ts-expect-error
        event2.MEDIA_GESTURE || this.#pausedTracking || isTouchPinchEvent(event2)
      ) {
        return;
      }
      if (isKeyboardEvent(event2)) {
        if (event2.key === "Escape") {
          this.el?.focus();
          this.#focusedItem = null;
        } else if (this.#focusedItem) {
          event2.preventDefault();
          requestAnimationFrame(() => {
            this.#focusedItem?.focus();
            this.#focusedItem = null;
          });
        }
      }
      this.show(0, event2);
      this.hide(this.defaultDelay, event2);
    }
    #changeVisibility(visible, delay, trigger) {
      if (delay === 0) {
        this.#onChange(visible, trigger);
        return;
      }
      this.#idleTimer = window.setTimeout(() => {
        if (!this.scope)
          return;
        this.#onChange(visible && !this.#pausedTracking, trigger);
      }, delay);
    }
    #onChange(visible, trigger) {
      if (this.$state.controlsVisible() === visible)
        return;
      this.$state.controlsVisible.set(visible);
      if (!visible && document.activeElement && this.el?.contains(document.activeElement)) {
        this.#focusedItem = document.activeElement;
        requestAnimationFrame(() => {
          this.el?.focus({ preventScroll: true });
        });
      }
      this.dispatch("controls-change", {
        detail: visible,
        trigger
      });
    }
  };
  var AudioProviderLoader = class {
    name = "audio";
    target;
    canPlay(src) {
      if (!isAudioSrc(src))
        return false;
      return !isString(src.src) || src.type === "?" || canPlayAudioType(this.target, src.type);
    }
    mediaType() {
      return "audio";
    }
    async load(ctx) {
      return new (await Promise.resolve().then(() => (init_vidstack_audio(), vidstack_audio_exports))).AudioProvider(this.target, ctx);
    }
  };
  var VideoProviderLoader = class {
    name = "video";
    target;
    canPlay(src) {
      if (!isVideoSrc(src))
        return false;
      return !isString(src.src) || src.type === "?" || canPlayVideoType(this.target, src.type);
    }
    mediaType() {
      return "video";
    }
    async load(ctx) {
      return new (await Promise.resolve().then(() => (init_vidstack_video(), vidstack_video_exports))).VideoProvider(this.target, ctx);
    }
  };
  var HLSProviderLoader = class _HLSProviderLoader extends VideoProviderLoader {
    static supported = isHLSSupported();
    name = "hls";
    canPlay(src) {
      return _HLSProviderLoader.supported && isHLSSrc(src);
    }
    async load(context3) {
      return new (await Promise.resolve().then(() => (init_vidstack_hls(), vidstack_hls_exports))).HLSProvider(this.target, context3);
    }
  };
  var DASHProviderLoader = class _DASHProviderLoader extends VideoProviderLoader {
    static supported = isDASHSupported();
    name = "dash";
    canPlay(src) {
      return _DASHProviderLoader.supported && isDASHSrc(src);
    }
    async load(context3) {
      return new (await Promise.resolve().then(() => (init_vidstack_dash(), vidstack_dash_exports))).DASHProvider(this.target, context3);
    }
  };
  var VimeoProviderLoader = class {
    name = "vimeo";
    target;
    preconnect() {
      const connections = [
        "https://i.vimeocdn.com",
        "https://f.vimeocdn.com",
        "https://fresnel.vimeocdn.com"
      ];
      for (const url of connections) {
        preconnect(url);
      }
    }
    canPlay(src) {
      return isString(src.src) && src.type === "video/vimeo";
    }
    mediaType() {
      return "video";
    }
    async load(ctx) {
      return new (await Promise.resolve().then(() => (init_vidstack_vimeo(), vidstack_vimeo_exports))).VimeoProvider(this.target, ctx);
    }
    async loadPoster(src, ctx, abort) {
      const { resolveVimeoVideoId: resolveVimeoVideoId2, getVimeoVideoInfo: getVimeoVideoInfo2 } = await Promise.resolve().then(() => (init_vidstack_krOAtKMi(), vidstack_krOAtKMi_exports));
      if (!isString(src.src))
        return null;
      const { videoId, hash } = resolveVimeoVideoId2(src.src);
      if (videoId) {
        return getVimeoVideoInfo2(videoId, abort, hash).then((info) => info ? info.poster : null);
      }
      return null;
    }
  };
  var YouTubeProviderLoader = class {
    name = "youtube";
    target;
    preconnect() {
      const connections = [
        // Botguard script.
        "https://www.google.com",
        // Posters.
        "https://i.ytimg.com",
        // Ads.
        "https://googleads.g.doubleclick.net",
        "https://static.doubleclick.net"
      ];
      for (const url of connections) {
        preconnect(url);
      }
    }
    canPlay(src) {
      return isString(src.src) && src.type === "video/youtube";
    }
    mediaType() {
      return "video";
    }
    async load(ctx) {
      return new (await Promise.resolve().then(() => (init_vidstack_youtube(), vidstack_youtube_exports))).YouTubeProvider(this.target, ctx);
    }
    async loadPoster(src, ctx, abort) {
      const { findYouTubePoster: findYouTubePoster2, resolveYouTubeVideoId: resolveYouTubeVideoId2 } = await Promise.resolve().then(() => (init_vidstack_Zc3I7oOd(), vidstack_Zc3I7oOd_exports));
      const videoId = isString(src.src) && resolveYouTubeVideoId2(src.src);
      if (videoId)
        return findYouTubePoster2(videoId, abort);
      return null;
    }
  };
  var MEDIA_ATTRIBUTES = Symbol(0);
  var mediaAttributes = [
    "autoPlay",
    "canAirPlay",
    "canFullscreen",
    "canGoogleCast",
    "canLoad",
    "canLoadPoster",
    "canPictureInPicture",
    "canPlay",
    "canSeek",
    "ended",
    "fullscreen",
    "isAirPlayConnected",
    "isGoogleCastConnected",
    "live",
    "liveEdge",
    "loop",
    "mediaType",
    "muted",
    "paused",
    "pictureInPicture",
    "playing",
    "playsInline",
    "remotePlaybackState",
    "remotePlaybackType",
    "seeking",
    "started",
    "streamType",
    "viewType",
    "waiting"
  ];
  var mediaPlayerProps = {
    artist: "",
    artwork: null,
    autoplay: false,
    autoPlay: false,
    clipStartTime: 0,
    clipEndTime: 0,
    controls: false,
    currentTime: 0,
    crossorigin: null,
    crossOrigin: null,
    duration: -1,
    fullscreenOrientation: "landscape",
    googleCast: {},
    load: "visible",
    posterLoad: "visible",
    logLevel: "silent",
    loop: false,
    muted: false,
    paused: true,
    playsinline: false,
    playsInline: false,
    playbackRate: 1,
    poster: "",
    preload: "metadata",
    preferNativeHLS: false,
    src: "",
    title: "",
    controlsDelay: 2e3,
    hideControlsOnMouseLeave: false,
    viewType: "unknown",
    streamType: "unknown",
    volume: 1,
    liveEdgeTolerance: 10,
    minLiveDVRWindow: 60,
    keyDisabled: false,
    keyTarget: "player",
    keyShortcuts: MEDIA_KEY_SHORTCUTS,
    storage: null
  };
  var MediaLoadController = class extends MediaPlayerController {
    #type;
    #callback;
    constructor(type, callback) {
      super();
      this.#type = type;
      this.#callback = callback;
    }
    async onAttach(el) {
      const load = this.$props[this.#type]();
      if (load === "eager") {
        requestAnimationFrame(this.#callback);
      } else if (load === "idle") {
        waitIdlePeriod(this.#callback);
      } else if (load === "visible") {
        let dispose2, observer = new IntersectionObserver((entries) => {
          if (!this.scope)
            return;
          if (entries[0].isIntersecting) {
            dispose2?.();
            dispose2 = void 0;
            this.#callback();
          }
        });
        observer.observe(el);
        dispose2 = onDispose(() => observer.disconnect());
      }
    }
  };
  var MediaPlayerDelegate = class {
    #handle;
    #media;
    constructor(handle, media) {
      this.#handle = handle;
      this.#media = media;
    }
    notify(type, ...init5) {
      this.#handle(
        new DOMEvent(type, {
          detail: init5?.[0],
          trigger: init5?.[1]
        })
      );
    }
    async ready(info, trigger) {
      return untrack(async () => {
        this.#media;
        const {
          autoPlay,
          canPlay,
          started,
          duration,
          seekable,
          buffered,
          remotePlaybackInfo,
          playsInline,
          savedState,
          source
        } = this.#media.$state;
        if (canPlay())
          return;
        const detail = {
          duration: info?.duration ?? duration(),
          seekable: info?.seekable ?? seekable(),
          buffered: info?.buffered ?? buffered(),
          provider: this.#media.$provider()
        };
        this.notify("can-play", detail, trigger);
        tick();
        let provider = this.#media.$provider(), { storage, qualities } = this.#media, { muted, volume, clipStartTime, playbackRate } = this.#media.$props;
        await storage?.onLoad?.(source());
        const savedPlaybackTime = savedState()?.currentTime, savedPlayingState = savedState()?.paused, storageTime = await storage?.getTime(), startTime = savedPlaybackTime ?? storageTime ?? clipStartTime(), shouldAutoPlay = savedPlayingState || savedPlayingState !== false && !started() && autoPlay();
        if (provider) {
          provider.setVolume(await storage?.getVolume() ?? volume());
          provider.setMuted(muted() || !!await storage?.getMuted());
          const audioGain = await storage?.getAudioGain() ?? 1;
          if (audioGain > 1)
            provider.audioGain?.setGain?.(audioGain);
          provider.setPlaybackRate?.(await storage?.getPlaybackRate() ?? playbackRate());
          provider.setPlaysInline?.(playsInline());
          if (startTime > 0)
            provider.setCurrentTime(startTime);
        }
        const prefQuality = await storage?.getVideoQuality();
        if (prefQuality && qualities.length) {
          let currentQuality = null, currentScore = Infinity;
          for (const quality of qualities) {
            const score = Math.abs(prefQuality.width - quality.width) + Math.abs(prefQuality.height - quality.height) + (prefQuality.bitrate ? Math.abs(prefQuality.bitrate - (quality.bitrate ?? 0)) : 0);
            if (score < currentScore) {
              currentQuality = quality;
              currentScore = score;
            }
          }
          if (currentQuality)
            currentQuality.selected = true;
        }
        if (canPlay() && shouldAutoPlay) {
          await this.#attemptAutoplay(trigger);
        } else if (storageTime && storageTime > 0) {
          this.notify("started", void 0, trigger);
        }
        remotePlaybackInfo.set(null);
      });
    }
    async #attemptAutoplay(trigger) {
      const {
        player,
        $state: { autoPlaying, muted }
      } = this.#media;
      autoPlaying.set(true);
      const attemptEvent = new DOMEvent("auto-play-attempt", { trigger });
      try {
        await player.play(attemptEvent);
      } catch (error) {
      }
    }
  };
  var Queue = class {
    #queue = /* @__PURE__ */ new Map();
    /**
     * Queue the given `item` under the given `key` to be processed at a later time by calling
     * `serve(key)`.
     */
    enqueue(key2, item) {
      this.#queue.set(key2, item);
    }
    /**
     * Process item in queue for the given `key`.
     */
    serve(key2) {
      const value = this.peek(key2);
      this.#queue.delete(key2);
      return value;
    }
    /**
     * Peek at item in queue for the given `key`.
     */
    peek(key2) {
      return this.#queue.get(key2);
    }
    /**
     * Removes queued item under the given `key`.
     */
    delete(key2) {
      this.#queue.delete(key2);
    }
    /**
     * Clear all items in the queue.
     */
    clear() {
      this.#queue.clear();
    }
  };
  var RequestQueue = class {
    #serving = false;
    #pending = deferredPromise();
    #queue = /* @__PURE__ */ new Map();
    /**
     * The number of callbacks that are currently in queue.
     */
    get size() {
      return this.#queue.size;
    }
    /**
     * Whether items in the queue are being served immediately, otherwise they're queued to
     * be processed later.
     */
    get isServing() {
      return this.#serving;
    }
    /**
     * Waits for the queue to be flushed (ie: start serving).
     */
    async waitForFlush() {
      if (this.#serving)
        return;
      await this.#pending.promise;
    }
    /**
     * Queue the given `callback` to be invoked at a later time by either calling the `serve()` or
     * `start()` methods. If the queue has started serving (i.e., `start()` was already called),
     * then the callback will be invoked immediately.
     *
     * @param key - Uniquely identifies this callback so duplicates are ignored.
     * @param callback - The function to call when this item in the queue is being served.
     */
    enqueue(key2, callback) {
      if (this.#serving) {
        callback();
        return;
      }
      this.#queue.delete(key2);
      this.#queue.set(key2, callback);
    }
    /**
     * Invokes the callback with the given `key` in the queue (if it exists).
     */
    serve(key2) {
      this.#queue.get(key2)?.();
      this.#queue.delete(key2);
    }
    /**
     * Flush all queued items and start serving future requests immediately until `stop()` is called.
     */
    start() {
      this.#flush();
      this.#serving = true;
      if (this.#queue.size > 0)
        this.#flush();
    }
    /**
     * Stop serving requests, they'll be queued until you begin processing again by calling `start()`.
     */
    stop() {
      this.#serving = false;
    }
    /**
     * Stop serving requests, empty the request queue, and release any promises waiting for the
     * queue to flush.
     */
    reset() {
      this.stop();
      this.#queue.clear();
      this.#release();
    }
    #flush() {
      for (const key2 of this.#queue.keys())
        this.serve(key2);
      this.#release();
    }
    #release() {
      this.#pending.resolve();
      this.#pending = deferredPromise();
    }
  };
  var MediaRequestManager = class extends MediaPlayerController {
    #stateMgr;
    #request;
    #media;
    controls;
    #fullscreen;
    #orientation;
    #$provider;
    #providerQueue = new RequestQueue();
    constructor(stateMgr, request, media) {
      super();
      this.#stateMgr = stateMgr;
      this.#request = request;
      this.#media = media;
      this.#$provider = media.$provider;
      this.controls = new MediaControls();
      this.#fullscreen = new FullscreenController();
      this.#orientation = new ScreenOrientationController();
    }
    onAttach() {
      this.listen("fullscreen-change", this.#onFullscreenChange.bind(this));
    }
    onConnect(el) {
      const names = Object.getOwnPropertyNames(Object.getPrototypeOf(this)), events2 = new EventsController(el), handleRequest = this.#handleRequest.bind(this);
      for (const name of names) {
        if (name.startsWith("media-")) {
          events2.add(name, handleRequest);
        }
      }
      this.#attachLoadPlayListener();
      effect(this.#watchProvider.bind(this));
      effect(this.#watchControlsDelayChange.bind(this));
      effect(this.#watchAudioGainSupport.bind(this));
      effect(this.#watchAirPlaySupport.bind(this));
      effect(this.#watchGoogleCastSupport.bind(this));
      effect(this.#watchFullscreenSupport.bind(this));
      effect(this.#watchPiPSupport.bind(this));
    }
    onDestroy() {
      try {
        const destroyEvent = this.createEvent("destroy"), { pictureInPicture, fullscreen } = this.$state;
        if (fullscreen())
          this.exitFullscreen("prefer-media", destroyEvent);
        if (pictureInPicture())
          this.exitPictureInPicture(destroyEvent);
      } catch (e8) {
      }
      this.#providerQueue.reset();
    }
    #attachLoadPlayListener() {
      const { load } = this.$props, { canLoad } = this.$state;
      if (load() !== "play" || canLoad())
        return;
      const off = this.listen("media-play-request", (event2) => {
        this.#handleLoadPlayStrategy(event2);
        off();
      });
    }
    #watchProvider() {
      const provider = this.#$provider(), canPlay = this.$state.canPlay();
      if (provider && canPlay) {
        this.#providerQueue.start();
      }
      return () => {
        this.#providerQueue.stop();
      };
    }
    #handleRequest(event2) {
      event2.stopPropagation();
      if (event2.defaultPrevented)
        return;
      if (!this[event2.type])
        return;
      if (peek(this.#$provider)) {
        this[event2.type](event2);
      } else {
        this.#providerQueue.enqueue(event2.type, () => {
          if (peek(this.#$provider))
            this[event2.type](event2);
        });
      }
    }
    async play(trigger) {
      const { canPlay, paused, autoPlaying } = this.$state;
      if (this.#handleLoadPlayStrategy(trigger))
        return;
      if (!peek(paused))
        return;
      if (trigger)
        this.#request.queue.enqueue("media-play-request", trigger);
      const isAutoPlaying = peek(autoPlaying);
      try {
        const provider = peek(this.#$provider);
        throwIfNotReadyForPlayback(provider, peek(canPlay));
        return await provider.play();
      } catch (error) {
        const errorEvent = this.createEvent("play-fail", {
          detail: coerceToError(error),
          trigger
        });
        errorEvent.autoPlay = isAutoPlaying;
        this.#stateMgr.handle(errorEvent);
        throw error;
      }
    }
    #handleLoadPlayStrategy(trigger) {
      const { load } = this.$props, { canLoad } = this.$state;
      if (load() === "play" && !canLoad()) {
        const event2 = this.createEvent("media-start-loading", { trigger });
        this.dispatchEvent(event2);
        this.#providerQueue.enqueue("media-play-request", async () => {
          try {
            await this.play(event2);
          } catch (error) {
          }
        });
        return true;
      }
      return false;
    }
    async pause(trigger) {
      const { canPlay, paused } = this.$state;
      if (peek(paused))
        return;
      if (trigger) {
        this.#request.queue.enqueue("media-pause-request", trigger);
      }
      try {
        const provider = peek(this.#$provider);
        throwIfNotReadyForPlayback(provider, peek(canPlay));
        return await provider.pause();
      } catch (error) {
        this.#request.queue.delete("media-pause-request");
        throw error;
      }
    }
    setAudioGain(gain, trigger) {
      const { audioGain, canSetAudioGain } = this.$state;
      if (audioGain() === gain)
        return;
      const provider = this.#$provider();
      if (!provider?.audioGain || !canSetAudioGain()) {
        throw Error("[vidstack] audio gain api not available");
      }
      if (trigger) {
        this.#request.queue.enqueue("media-audio-gain-change-request", trigger);
      }
      provider.audioGain.setGain(gain);
    }
    seekToLiveEdge(trigger) {
      const { canPlay, live, liveEdge, canSeek, liveSyncPosition, seekableEnd, userBehindLiveEdge } = this.$state;
      userBehindLiveEdge.set(false);
      if (peek(() => !live() || liveEdge() || !canSeek()))
        return;
      const provider = peek(this.#$provider);
      throwIfNotReadyForPlayback(provider, peek(canPlay));
      if (trigger)
        this.#request.queue.enqueue("media-seek-request", trigger);
      const end = seekableEnd() - 2;
      provider.setCurrentTime(Math.min(end, liveSyncPosition() ?? end));
    }
    #wasPIPActive = false;
    async enterFullscreen(target = "prefer-media", trigger) {
      const adapter = this.#getFullscreenAdapter(target);
      throwIfFullscreenNotSupported(target, adapter);
      if (adapter.active)
        return;
      if (peek(this.$state.pictureInPicture)) {
        this.#wasPIPActive = true;
        await this.exitPictureInPicture(trigger);
      }
      if (trigger) {
        this.#request.queue.enqueue("media-enter-fullscreen-request", trigger);
      }
      return adapter.enter();
    }
    async exitFullscreen(target = "prefer-media", trigger) {
      const adapter = this.#getFullscreenAdapter(target);
      throwIfFullscreenNotSupported(target, adapter);
      if (!adapter.active)
        return;
      if (trigger) {
        this.#request.queue.enqueue("media-exit-fullscreen-request", trigger);
      }
      try {
        const result = await adapter.exit();
        if (this.#wasPIPActive && peek(this.$state.canPictureInPicture)) {
          await this.enterPictureInPicture();
        }
        return result;
      } finally {
        this.#wasPIPActive = false;
      }
    }
    #getFullscreenAdapter(target) {
      const provider = peek(this.#$provider);
      return target === "prefer-media" && this.#fullscreen.supported || target === "media" ? this.#fullscreen : provider?.fullscreen;
    }
    async enterPictureInPicture(trigger) {
      this.#throwIfPIPNotSupported();
      if (this.$state.pictureInPicture())
        return;
      if (trigger) {
        this.#request.queue.enqueue("media-enter-pip-request", trigger);
      }
      return await this.#$provider().pictureInPicture.enter();
    }
    async exitPictureInPicture(trigger) {
      this.#throwIfPIPNotSupported();
      if (!this.$state.pictureInPicture())
        return;
      if (trigger) {
        this.#request.queue.enqueue("media-exit-pip-request", trigger);
      }
      return await this.#$provider().pictureInPicture.exit();
    }
    #throwIfPIPNotSupported() {
      if (this.$state.canPictureInPicture())
        return;
      throw Error(
        "[vidstack] no pip support"
      );
    }
    #watchControlsDelayChange() {
      this.controls.defaultDelay = this.$props.controlsDelay();
    }
    #watchAudioGainSupport() {
      const { canSetAudioGain } = this.$state, supported = !!this.#$provider()?.audioGain?.supported;
      canSetAudioGain.set(supported);
    }
    #watchAirPlaySupport() {
      const { canAirPlay } = this.$state, supported = !!this.#$provider()?.airPlay?.supported;
      canAirPlay.set(supported);
    }
    #watchGoogleCastSupport() {
      const { canGoogleCast, source } = this.$state, supported = IS_CHROME && !IS_IOS && canGoogleCastSrc(source());
      canGoogleCast.set(supported);
    }
    #watchFullscreenSupport() {
      const { canFullscreen } = this.$state, supported = this.#fullscreen.supported || !!this.#$provider()?.fullscreen?.supported;
      canFullscreen.set(supported);
    }
    #watchPiPSupport() {
      const { canPictureInPicture } = this.$state, supported = !!this.#$provider()?.pictureInPicture?.supported;
      canPictureInPicture.set(supported);
    }
    async ["media-airplay-request"](event2) {
      try {
        await this.requestAirPlay(event2);
      } catch (error) {
      }
    }
    async requestAirPlay(trigger) {
      try {
        const adapter = this.#$provider()?.airPlay;
        if (!adapter?.supported) {
          throw Error(false ? "AirPlay adapter not available on provider." : "No AirPlay adapter.");
        }
        if (trigger) {
          this.#request.queue.enqueue("media-airplay-request", trigger);
        }
        return await adapter.prompt();
      } catch (error) {
        this.#request.queue.delete("media-airplay-request");
        throw error;
      }
    }
    async ["media-google-cast-request"](event2) {
      try {
        await this.requestGoogleCast(event2);
      } catch (error) {
      }
    }
    #googleCastLoader;
    async requestGoogleCast(trigger) {
      try {
        const { canGoogleCast } = this.$state;
        if (!peek(canGoogleCast)) {
          const error = Error(
            false ? "Google Cast not available on this platform." : "Cast not available."
          );
          error.code = "CAST_NOT_AVAILABLE";
          throw error;
        }
        preconnect("https://www.gstatic.com");
        if (!this.#googleCastLoader) {
          const $module = await Promise.resolve().then(() => (init_vidstack_kV1_bfkY(), vidstack_kV1_bfkY_exports));
          this.#googleCastLoader = new $module.GoogleCastLoader();
        }
        await this.#googleCastLoader.prompt(this.#media);
        if (trigger) {
          this.#request.queue.enqueue("media-google-cast-request", trigger);
        }
        const isConnecting = peek(this.$state.remotePlaybackState) !== "disconnected";
        if (isConnecting) {
          this.$state.savedState.set({
            paused: peek(this.$state.paused),
            currentTime: peek(this.$state.currentTime)
          });
        }
        this.$state.remotePlaybackLoader.set(isConnecting ? this.#googleCastLoader : null);
      } catch (error) {
        this.#request.queue.delete("media-google-cast-request");
        throw error;
      }
    }
    ["media-clip-start-change-request"](event2) {
      const { clipStartTime } = this.$state;
      clipStartTime.set(event2.detail);
    }
    ["media-clip-end-change-request"](event2) {
      const { clipEndTime } = this.$state;
      clipEndTime.set(event2.detail);
      this.dispatch("duration-change", {
        detail: event2.detail,
        trigger: event2
      });
    }
    ["media-duration-change-request"](event2) {
      const { providedDuration, clipEndTime } = this.$state;
      providedDuration.set(event2.detail);
      if (clipEndTime() <= 0) {
        this.dispatch("duration-change", {
          detail: event2.detail,
          trigger: event2
        });
      }
    }
    ["media-audio-track-change-request"](event2) {
      const { logger, audioTracks } = this.#media;
      if (audioTracks.readonly) {
        return;
      }
      const index = event2.detail, track = audioTracks[index];
      if (track) {
        const key2 = event2.type;
        this.#request.queue.enqueue(key2, event2);
        track.selected = true;
      }
    }
    async ["media-enter-fullscreen-request"](event2) {
      try {
        await this.enterFullscreen(event2.detail, event2);
      } catch (error) {
        this.#onFullscreenError(error, event2);
      }
    }
    async ["media-exit-fullscreen-request"](event2) {
      try {
        await this.exitFullscreen(event2.detail, event2);
      } catch (error) {
        this.#onFullscreenError(error, event2);
      }
    }
    async #onFullscreenChange(event2) {
      const lockType = peek(this.$props.fullscreenOrientation), isFullscreen2 = event2.detail;
      if (isUndefined(lockType) || lockType === "none" || !this.#orientation.supported)
        return;
      if (isFullscreen2) {
        if (this.#orientation.locked)
          return;
        this.dispatch("media-orientation-lock-request", {
          detail: lockType,
          trigger: event2
        });
      } else if (this.#orientation.locked) {
        this.dispatch("media-orientation-unlock-request", {
          trigger: event2
        });
      }
    }
    #onFullscreenError(error, request) {
      this.#stateMgr.handle(
        this.createEvent("fullscreen-error", {
          detail: coerceToError(error)
        })
      );
    }
    async ["media-orientation-lock-request"](event2) {
      const key2 = event2.type;
      try {
        this.#request.queue.enqueue(key2, event2);
        await this.#orientation.lock(event2.detail);
      } catch (error) {
        this.#request.queue.delete(key2);
      }
    }
    async ["media-orientation-unlock-request"](event2) {
      const key2 = event2.type;
      try {
        this.#request.queue.enqueue(key2, event2);
        await this.#orientation.unlock();
      } catch (error) {
        this.#request.queue.delete(key2);
      }
    }
    async ["media-enter-pip-request"](event2) {
      try {
        await this.enterPictureInPicture(event2);
      } catch (error) {
        this.#onPictureInPictureError(error, event2);
      }
    }
    async ["media-exit-pip-request"](event2) {
      try {
        await this.exitPictureInPicture(event2);
      } catch (error) {
        this.#onPictureInPictureError(error, event2);
      }
    }
    #onPictureInPictureError(error, request) {
      this.#stateMgr.handle(
        this.createEvent("picture-in-picture-error", {
          detail: coerceToError(error)
        })
      );
    }
    ["media-live-edge-request"](event2) {
      const { live, liveEdge, canSeek } = this.$state;
      if (!live() || liveEdge() || !canSeek())
        return;
      this.#request.queue.enqueue("media-seek-request", event2);
      try {
        this.seekToLiveEdge();
      } catch (error) {
        this.#request.queue.delete("media-seek-request");
      }
    }
    async ["media-loop-request"](event2) {
      try {
        this.#request.looping = true;
        this.#request.replaying = true;
        await this.play(event2);
      } catch (error) {
        this.#request.looping = false;
      }
    }
    ["media-user-loop-change-request"](event2) {
      this.$state.userPrefersLoop.set(event2.detail);
    }
    async ["media-pause-request"](event2) {
      if (this.$state.paused())
        return;
      try {
        await this.pause(event2);
      } catch (error) {
      }
    }
    async ["media-play-request"](event2) {
      if (!this.$state.paused())
        return;
      try {
        await this.play(event2);
      } catch (e8) {
      }
    }
    ["media-rate-change-request"](event2) {
      const { playbackRate, canSetPlaybackRate } = this.$state;
      if (playbackRate() === event2.detail || !canSetPlaybackRate())
        return;
      const provider = this.#$provider();
      if (!provider?.setPlaybackRate)
        return;
      this.#request.queue.enqueue("media-rate-change-request", event2);
      provider.setPlaybackRate(event2.detail);
    }
    ["media-audio-gain-change-request"](event2) {
      try {
        this.setAudioGain(event2.detail, event2);
      } catch (e8) {
      }
    }
    ["media-quality-change-request"](event2) {
      const { qualities, storage, logger } = this.#media;
      if (qualities.readonly) {
        return;
      }
      this.#request.queue.enqueue("media-quality-change-request", event2);
      const index = event2.detail;
      if (index < 0) {
        qualities.autoSelect(event2);
        if (event2.isOriginTrusted)
          storage?.setVideoQuality?.(null);
      } else {
        const quality = qualities[index];
        if (quality) {
          quality.selected = true;
          if (event2.isOriginTrusted) {
            storage?.setVideoQuality?.({
              id: quality.id,
              width: quality.width,
              height: quality.height,
              bitrate: quality.bitrate
            });
          }
        }
      }
    }
    ["media-pause-controls-request"](event2) {
      const key2 = event2.type;
      this.#request.queue.enqueue(key2, event2);
      this.controls.pause(event2);
    }
    ["media-resume-controls-request"](event2) {
      const key2 = event2.type;
      this.#request.queue.enqueue(key2, event2);
      this.controls.resume(event2);
    }
    ["media-seek-request"](event2) {
      const { seekableStart, seekableEnd, ended, canSeek, live, userBehindLiveEdge, clipStartTime } = this.$state, seekTime = event2.detail;
      if (ended())
        this.#request.replaying = true;
      const key2 = event2.type;
      this.#request.seeking = false;
      this.#request.queue.delete(key2);
      const clippedTime = seekTime + clipStartTime(), isStart = Math.floor(seekTime) === Math.floor(seekableStart()), isEnd = Math.floor(clippedTime) === Math.floor(seekableEnd()), boundTime = isStart ? seekableStart() : isEnd ? seekableEnd() : Math.min(Math.max(seekableStart() + 0.1, clippedTime), seekableEnd() - 0.1);
      if (!Number.isFinite(boundTime) || !canSeek())
        return;
      this.#request.queue.enqueue(key2, event2);
      this.#$provider().setCurrentTime(boundTime);
      if (live() && event2.isOriginTrusted && Math.abs(seekableEnd() - boundTime) >= 2) {
        userBehindLiveEdge.set(true);
      }
    }
    ["media-seeking-request"](event2) {
      const key2 = event2.type;
      this.#request.queue.enqueue(key2, event2);
      this.$state.seeking.set(true);
      this.#request.seeking = true;
    }
    ["media-start-loading"](event2) {
      if (this.$state.canLoad())
        return;
      const key2 = event2.type;
      this.#request.queue.enqueue(key2, event2);
      this.#stateMgr.handle(this.createEvent("can-load"));
    }
    ["media-poster-start-loading"](event2) {
      if (this.$state.canLoadPoster())
        return;
      const key2 = event2.type;
      this.#request.queue.enqueue(key2, event2);
      this.#stateMgr.handle(this.createEvent("can-load-poster"));
    }
    ["media-text-track-change-request"](event2) {
      const { index, mode } = event2.detail, track = this.#media.textTracks[index];
      if (track) {
        const key2 = event2.type;
        this.#request.queue.enqueue(key2, event2);
        track.setMode(mode, event2);
      }
    }
    ["media-mute-request"](event2) {
      if (this.$state.muted())
        return;
      const key2 = event2.type;
      this.#request.queue.enqueue(key2, event2);
      this.#$provider().setMuted(true);
    }
    ["media-unmute-request"](event2) {
      const { muted, volume } = this.$state;
      if (!muted())
        return;
      const key2 = event2.type;
      this.#request.queue.enqueue(key2, event2);
      this.#media.$provider().setMuted(false);
      if (volume() === 0) {
        this.#request.queue.enqueue(key2, event2);
        this.#$provider().setVolume(0.25);
      }
    }
    ["media-volume-change-request"](event2) {
      const { muted, volume } = this.$state;
      const newVolume = event2.detail;
      if (volume() === newVolume)
        return;
      const key2 = event2.type;
      this.#request.queue.enqueue(key2, event2);
      this.#$provider().setVolume(newVolume);
      if (newVolume > 0 && muted()) {
        this.#request.queue.enqueue(key2, event2);
        this.#$provider().setMuted(false);
      }
    }
    #logError(title, error, request) {
      return;
    }
  };
  function throwIfNotReadyForPlayback(provider, canPlay) {
    if (provider && canPlay)
      return;
    throw Error(
      "[vidstack] media not ready"
    );
  }
  function throwIfFullscreenNotSupported(target, fullscreen) {
    if (fullscreen?.supported)
      return;
    throw Error(
      "[vidstack] no fullscreen support"
    );
  }
  var MediaRequestContext = class {
    seeking = false;
    looping = false;
    replaying = false;
    queue = new Queue();
  };
  var TRACKED_EVENT = /* @__PURE__ */ new Set([
    "auto-play",
    "auto-play-fail",
    "can-load",
    "sources-change",
    "source-change",
    "load-start",
    "abort",
    "error",
    "loaded-metadata",
    "loaded-data",
    "can-play",
    "play",
    "play-fail",
    "pause",
    "playing",
    "seeking",
    "seeked",
    "waiting"
  ]);
  var MediaStateManager = class extends MediaPlayerController {
    #request;
    #media;
    #trackedEvents = /* @__PURE__ */ new Map();
    #clipEnded = false;
    #playedIntervals = [];
    #playedInterval = [-1, -1];
    #firingWaiting = false;
    #waitingTrigger;
    constructor(request, media) {
      super();
      this.#request = request;
      this.#media = media;
    }
    onAttach(el) {
      el.setAttribute("aria-busy", "true");
      new EventsController(this).add("fullscreen-change", this["fullscreen-change"].bind(this)).add("fullscreen-error", this["fullscreen-error"].bind(this)).add("orientation-change", this["orientation-change"].bind(this));
    }
    onConnect(el) {
      effect(this.#watchCanSetVolume.bind(this));
      this.#addTextTrackListeners();
      this.#addQualityListeners();
      this.#addAudioTrackListeners();
      this.#resumePlaybackOnConnect();
      onDispose(this.#pausePlaybackOnDisconnect.bind(this));
    }
    onDestroy() {
      const { audioTracks, qualities, textTracks } = this.#media;
      audioTracks[ListSymbol.reset]();
      qualities[ListSymbol.reset]();
      textTracks[ListSymbol.reset]();
      this.#stopWatchingQualityResize();
    }
    handle(event2) {
      if (!this.scope)
        return;
      const type = event2.type;
      untrack(() => this[event2.type]?.(event2));
      {
        if (TRACKED_EVENT.has(type))
          this.#trackedEvents.set(type, event2);
        this.dispatch(event2);
      }
    }
    #isPlayingOnDisconnect = false;
    #resumePlaybackOnConnect() {
      if (!this.#isPlayingOnDisconnect)
        return;
      requestAnimationFrame(() => {
        if (!this.scope)
          return;
        this.#media.remote.play(new DOMEvent("dom-connect"));
      });
      this.#isPlayingOnDisconnect = false;
    }
    #pausePlaybackOnDisconnect() {
      if (this.#isPlayingOnDisconnect)
        return;
      this.#isPlayingOnDisconnect = !this.$state.paused();
      this.#media.$provider()?.pause();
    }
    #resetTracking() {
      this.#stopWaiting();
      this.#clipEnded = false;
      this.#request.replaying = false;
      this.#request.looping = false;
      this.#firingWaiting = false;
      this.#waitingTrigger = void 0;
      this.#trackedEvents.clear();
    }
    #satisfyRequest(request, event2) {
      const requestEvent = this.#request.queue.serve(request);
      if (!requestEvent)
        return;
      event2.request = requestEvent;
      event2.triggers.add(requestEvent);
    }
    #addTextTrackListeners() {
      this.#onTextTracksChange();
      this.#onTextTrackModeChange();
      const textTracks = this.#media.textTracks;
      new EventsController(textTracks).add("add", this.#onTextTracksChange.bind(this)).add("remove", this.#onTextTracksChange.bind(this)).add("mode-change", this.#onTextTrackModeChange.bind(this));
    }
    #addQualityListeners() {
      const qualities = this.#media.qualities;
      new EventsController(qualities).add("add", this.#onQualitiesChange.bind(this)).add("remove", this.#onQualitiesChange.bind(this)).add("change", this.#onQualityChange.bind(this)).add("auto-change", this.#onAutoQualityChange.bind(this)).add("readonly-change", this.#onCanSetQualityChange.bind(this));
    }
    #addAudioTrackListeners() {
      const audioTracks = this.#media.audioTracks;
      new EventsController(audioTracks).add("add", this.#onAudioTracksChange.bind(this)).add("remove", this.#onAudioTracksChange.bind(this)).add("change", this.#onAudioTrackChange.bind(this));
    }
    #onTextTracksChange(event2) {
      const { textTracks } = this.$state;
      textTracks.set(this.#media.textTracks.toArray());
      this.dispatch("text-tracks-change", {
        detail: textTracks(),
        trigger: event2
      });
    }
    #onTextTrackModeChange(event2) {
      if (event2)
        this.#satisfyRequest("media-text-track-change-request", event2);
      const current = this.#media.textTracks.selected, { textTrack } = this.$state;
      if (textTrack() !== current) {
        textTrack.set(current);
        this.dispatch("text-track-change", {
          detail: current,
          trigger: event2
        });
      }
    }
    #onAudioTracksChange(event2) {
      const { audioTracks } = this.$state;
      audioTracks.set(this.#media.audioTracks.toArray());
      this.dispatch("audio-tracks-change", {
        detail: audioTracks(),
        trigger: event2
      });
    }
    #onAudioTrackChange(event2) {
      const { audioTrack } = this.$state;
      audioTrack.set(this.#media.audioTracks.selected);
      if (event2)
        this.#satisfyRequest("media-audio-track-change-request", event2);
      this.dispatch("audio-track-change", {
        detail: audioTrack(),
        trigger: event2
      });
    }
    #onQualitiesChange(event2) {
      const { qualities } = this.$state;
      qualities.set(this.#media.qualities.toArray());
      this.dispatch("qualities-change", {
        detail: qualities(),
        trigger: event2
      });
    }
    #onQualityChange(event2) {
      const { quality } = this.$state;
      quality.set(this.#media.qualities.selected);
      if (event2)
        this.#satisfyRequest("media-quality-change-request", event2);
      this.dispatch("quality-change", {
        detail: quality(),
        trigger: event2
      });
    }
    #onAutoQualityChange() {
      const { qualities } = this.#media, isAuto = qualities.auto;
      this.$state.autoQuality.set(isAuto);
      if (!isAuto)
        this.#stopWatchingQualityResize();
    }
    #stopQualityResizeEffect = null;
    #watchQualityResize() {
      this.#stopWatchingQualityResize();
      this.#stopQualityResizeEffect = effect(() => {
        const { qualities } = this.#media, { mediaWidth, mediaHeight } = this.$state, w2 = mediaWidth(), h5 = mediaHeight();
        if (w2 === 0 || h5 === 0)
          return;
        let selectedQuality = null, minScore = Infinity;
        for (const quality of qualities) {
          const score = Math.abs(quality.width - w2) + Math.abs(quality.height - h5);
          if (score < minScore) {
            minScore = score;
            selectedQuality = quality;
          }
        }
        if (selectedQuality) {
          qualities[ListSymbol.select](
            selectedQuality,
            true,
            new DOMEvent("resize", { detail: { width: w2, height: h5 } })
          );
        }
      });
    }
    #stopWatchingQualityResize() {
      this.#stopQualityResizeEffect?.();
      this.#stopQualityResizeEffect = null;
    }
    #onCanSetQualityChange() {
      this.$state.canSetQuality.set(!this.#media.qualities.readonly);
    }
    #watchCanSetVolume() {
      const { canSetVolume, isGoogleCastConnected } = this.$state;
      if (isGoogleCastConnected()) {
        canSetVolume.set(false);
        return;
      }
      canChangeVolume().then(canSetVolume.set);
    }
    ["provider-change"](event2) {
      const prevProvider = this.#media.$provider(), newProvider = event2.detail;
      if (prevProvider?.type === newProvider?.type)
        return;
      prevProvider?.destroy?.();
      prevProvider?.scope?.dispose();
      this.#media.$provider.set(event2.detail);
      if (prevProvider && event2.detail === null) {
        this.#resetMediaState(event2);
      }
    }
    ["provider-loader-change"](event2) {
    }
    ["auto-play"](event2) {
      this.$state.autoPlayError.set(null);
    }
    ["auto-play-fail"](event2) {
      this.$state.autoPlayError.set(event2.detail);
      this.#resetTracking();
    }
    ["can-load"](event2) {
      this.$state.canLoad.set(true);
      this.#trackedEvents.set("can-load", event2);
      this.#media.textTracks[TextTrackSymbol.canLoad]();
      this.#satisfyRequest("media-start-loading", event2);
    }
    ["can-load-poster"](event2) {
      this.$state.canLoadPoster.set(true);
      this.#trackedEvents.set("can-load-poster", event2);
      this.#satisfyRequest("media-poster-start-loading", event2);
    }
    ["media-type-change"](event2) {
      const sourceChangeEvent = this.#trackedEvents.get("source-change");
      if (sourceChangeEvent)
        event2.triggers.add(sourceChangeEvent);
      const viewType = this.$state.viewType();
      this.$state.mediaType.set(event2.detail);
      const providedViewType = this.$state.providedViewType(), currentViewType = providedViewType === "unknown" ? event2.detail : providedViewType;
      if (viewType !== currentViewType) {
        {
          setTimeout(() => {
            requestAnimationFrame(() => {
              if (!this.scope)
                return;
              this.$state.inferredViewType.set(event2.detail);
              this.dispatch("view-type-change", {
                detail: currentViewType,
                trigger: event2
              });
            });
          }, 0);
        }
      }
    }
    ["stream-type-change"](event2) {
      const sourceChangeEvent = this.#trackedEvents.get("source-change");
      if (sourceChangeEvent)
        event2.triggers.add(sourceChangeEvent);
      const { streamType, inferredStreamType } = this.$state;
      inferredStreamType.set(event2.detail);
      event2.detail = streamType();
    }
    ["rate-change"](event2) {
      const { storage } = this.#media, { canPlay } = this.$state;
      this.$state.playbackRate.set(event2.detail);
      this.#satisfyRequest("media-rate-change-request", event2);
      if (canPlay()) {
        storage?.setPlaybackRate?.(event2.detail);
      }
    }
    ["remote-playback-change"](event2) {
      const { remotePlaybackState, remotePlaybackType } = this.$state, { type, state } = event2.detail, isConnected = state === "connected";
      remotePlaybackType.set(type);
      remotePlaybackState.set(state);
      const key2 = type === "airplay" ? "media-airplay-request" : "media-google-cast-request";
      if (isConnected) {
        this.#satisfyRequest(key2, event2);
      } else {
        const requestEvent = this.#request.queue.peek(key2);
        if (requestEvent) {
          event2.request = requestEvent;
          event2.triggers.add(requestEvent);
        }
      }
    }
    ["sources-change"](event2) {
      const prevSources = this.$state.sources(), newSources = event2.detail;
      this.$state.sources.set(newSources);
      this.#onSourceQualitiesChange(prevSources, newSources, event2);
    }
    #onSourceQualitiesChange(prevSources, newSources, trigger) {
      let { qualities } = this.#media, added = false, removed = false;
      for (const prevSrc of prevSources) {
        if (!isVideoQualitySrc(prevSrc))
          continue;
        const exists = newSources.some((s5) => s5.src === prevSrc.src);
        if (!exists) {
          const quality = qualities.getBySrc(prevSrc.src);
          if (quality) {
            qualities[ListSymbol.remove](quality, trigger);
            removed = true;
          }
        }
      }
      if (removed && !qualities.length) {
        this.$state.savedState.set(null);
        qualities[ListSymbol.reset](trigger);
      }
      for (const src of newSources) {
        if (!isVideoQualitySrc(src) || qualities.getBySrc(src.src))
          continue;
        const quality = {
          id: src.id ?? src.height + "p",
          bitrate: null,
          codec: null,
          ...src,
          selected: false
        };
        qualities[ListSymbol.add](quality, trigger);
        added = true;
      }
      if (added && !qualities[QualitySymbol.enableAuto]) {
        this.#watchQualityResize();
        qualities[QualitySymbol.enableAuto] = this.#watchQualityResize.bind(this);
        qualities[QualitySymbol.setAuto](true, trigger);
      }
    }
    ["source-change"](event2) {
      event2.isQualityChange = event2.originEvent?.type === "quality-change";
      const source = event2.detail;
      this.#resetMediaState(event2, event2.isQualityChange);
      this.#trackedEvents.set(event2.type, event2);
      this.$state.source.set(source);
      this.el?.setAttribute("aria-busy", "true");
    }
    #resetMediaState(event2, isSourceQualityChange = false) {
      const { audioTracks, qualities } = this.#media;
      if (!isSourceQualityChange) {
        this.#playedIntervals = [];
        this.#playedInterval = [-1, -1];
        audioTracks[ListSymbol.reset](event2);
        qualities[ListSymbol.reset](event2);
        softResetMediaState(this.$state, isSourceQualityChange);
        this.#resetTracking();
        return;
      }
      softResetMediaState(this.$state, isSourceQualityChange);
      this.#resetTracking();
    }
    ["abort"](event2) {
      const sourceChangeEvent = this.#trackedEvents.get("source-change");
      if (sourceChangeEvent)
        event2.triggers.add(sourceChangeEvent);
      const canLoadEvent = this.#trackedEvents.get("can-load");
      if (canLoadEvent && !event2.triggers.hasType("can-load")) {
        event2.triggers.add(canLoadEvent);
      }
    }
    ["load-start"](event2) {
      const sourceChangeEvent = this.#trackedEvents.get("source-change");
      if (sourceChangeEvent)
        event2.triggers.add(sourceChangeEvent);
    }
    ["error"](event2) {
      this.$state.error.set(event2.detail);
      const abortEvent = this.#trackedEvents.get("abort");
      if (abortEvent)
        event2.triggers.add(abortEvent);
    }
    ["loaded-metadata"](event2) {
      const loadStartEvent = this.#trackedEvents.get("load-start");
      if (loadStartEvent)
        event2.triggers.add(loadStartEvent);
    }
    ["loaded-data"](event2) {
      const loadStartEvent = this.#trackedEvents.get("load-start");
      if (loadStartEvent)
        event2.triggers.add(loadStartEvent);
    }
    ["can-play"](event2) {
      const loadedMetadata = this.#trackedEvents.get("loaded-metadata");
      if (loadedMetadata)
        event2.triggers.add(loadedMetadata);
      this.#onCanPlayDetail(event2.detail);
      this.el?.setAttribute("aria-busy", "false");
    }
    ["can-play-through"](event2) {
      this.#onCanPlayDetail(event2.detail);
      const canPlay = this.#trackedEvents.get("can-play");
      if (canPlay)
        event2.triggers.add(canPlay);
    }
    #onCanPlayDetail(detail) {
      const { seekable, buffered, intrinsicDuration, canPlay } = this.$state;
      canPlay.set(true);
      buffered.set(detail.buffered);
      seekable.set(detail.seekable);
      const seekableEnd = getTimeRangesEnd(detail.seekable) ?? Infinity;
      intrinsicDuration.set(seekableEnd);
    }
    ["duration-change"](event2) {
      const { live, intrinsicDuration, providedDuration, clipEndTime, ended } = this.$state, time = event2.detail;
      if (!live()) {
        const duration = !Number.isNaN(time) ? time : 0;
        intrinsicDuration.set(duration);
        if (ended())
          this.#onEndPrecisionChange(event2);
      }
      if (providedDuration() > 0 || clipEndTime() > 0) {
        event2.stopImmediatePropagation();
      }
    }
    ["progress"](event2) {
      const { buffered, bufferedEnd, seekable, seekableEnd, live, intrinsicDuration } = this.$state, { buffered: newBuffered, seekable: newSeekable } = event2.detail, newBufferedEnd = getTimeRangesEnd(newBuffered) ?? Infinity, hasBufferedLengthChanged = newBuffered.length !== buffered().length, hasBufferedEndChanged = newBufferedEnd > bufferedEnd(), newSeekableEnd = getTimeRangesEnd(newSeekable) ?? Infinity, hasSeekableLengthChanged = newSeekable.length !== seekable().length, hasSeekableEndChanged = newSeekableEnd > seekableEnd();
      if (hasBufferedLengthChanged || hasBufferedEndChanged) {
        buffered.set(newBuffered);
      }
      if (hasSeekableLengthChanged || hasSeekableEndChanged) {
        seekable.set(newSeekable);
      }
      if (live()) {
        intrinsicDuration.set(newSeekableEnd);
        this.dispatch("duration-change", {
          detail: newSeekableEnd,
          trigger: event2
        });
      }
    }
    ["play"](event2) {
      const {
        paused,
        autoPlayError,
        ended,
        autoPlaying,
        playsInline,
        pointer,
        muted,
        viewType,
        live,
        userBehindLiveEdge
      } = this.$state;
      this.#resetPlaybackIfNeeded();
      if (!paused()) {
        event2.stopImmediatePropagation();
        return;
      }
      event2.autoPlay = autoPlaying();
      const waitingEvent = this.#trackedEvents.get("waiting");
      if (waitingEvent)
        event2.triggers.add(waitingEvent);
      this.#satisfyRequest("media-play-request", event2);
      this.#trackedEvents.set("play", event2);
      paused.set(false);
      autoPlayError.set(null);
      if (event2.autoPlay) {
        this.handle(
          this.createEvent("auto-play", {
            detail: { muted: muted() },
            trigger: event2
          })
        );
        autoPlaying.set(false);
      }
      if (ended() || this.#request.replaying) {
        this.#request.replaying = false;
        ended.set(false);
        this.handle(this.createEvent("replay", { trigger: event2 }));
      }
      if (!playsInline() && viewType() === "video" && pointer() === "coarse") {
        this.#media.remote.enterFullscreen("prefer-media", event2);
      }
      if (live() && !userBehindLiveEdge()) {
        this.#media.remote.seekToLiveEdge(event2);
      }
    }
    #resetPlaybackIfNeeded(trigger) {
      const provider = peek(this.#media.$provider);
      if (!provider)
        return;
      const {
        ended,
        seekableStart,
        clipStartTime,
        clipEndTime,
        currentTime,
        realCurrentTime,
        duration
      } = this.$state;
      const shouldReset = ended() || realCurrentTime() < clipStartTime() || clipEndTime() > 0 && realCurrentTime() >= clipEndTime() || Math.abs(currentTime() - duration()) < 0.1;
      if (shouldReset) {
        this.dispatch("media-seek-request", {
          detail: seekableStart(),
          trigger
        });
      }
      return shouldReset;
    }
    ["play-fail"](event2) {
      const { muted, autoPlaying } = this.$state;
      const playEvent = this.#trackedEvents.get("play");
      if (playEvent)
        event2.triggers.add(playEvent);
      this.#satisfyRequest("media-play-request", event2);
      const { paused, playing } = this.$state;
      paused.set(true);
      playing.set(false);
      this.#resetTracking();
      this.#trackedEvents.set("play-fail", event2);
      if (event2.autoPlay) {
        this.handle(
          this.createEvent("auto-play-fail", {
            detail: {
              muted: muted(),
              error: event2.detail
            },
            trigger: event2
          })
        );
        autoPlaying.set(false);
      }
    }
    ["playing"](event2) {
      const playEvent = this.#trackedEvents.get("play"), seekedEvent = this.#trackedEvents.get("seeked");
      if (playEvent)
        event2.triggers.add(playEvent);
      else if (seekedEvent)
        event2.triggers.add(seekedEvent);
      setTimeout(() => this.#resetTracking(), 0);
      const {
        paused,
        playing,
        live,
        liveSyncPosition,
        seekableEnd,
        started,
        currentTime,
        seeking,
        ended
      } = this.$state;
      paused.set(false);
      playing.set(true);
      seeking.set(false);
      ended.set(false);
      if (this.#request.looping) {
        this.#request.looping = false;
        return;
      }
      if (live() && !started() && currentTime() === 0) {
        const end = liveSyncPosition() ?? seekableEnd() - 2;
        if (Number.isFinite(end))
          this.#media.$provider().setCurrentTime(end);
      }
      this["started"](event2);
    }
    ["started"](event2) {
      const { started } = this.$state;
      if (!started()) {
        started.set(true);
        this.handle(this.createEvent("started", { trigger: event2 }));
      }
    }
    ["pause"](event2) {
      if (!this.el?.isConnected) {
        this.#isPlayingOnDisconnect = true;
      }
      this.#satisfyRequest("media-pause-request", event2);
      const seekedEvent = this.#trackedEvents.get("seeked");
      if (seekedEvent)
        event2.triggers.add(seekedEvent);
      const { paused, playing } = this.$state;
      paused.set(true);
      playing.set(false);
      if (this.#clipEnded) {
        setTimeout(() => {
          this.handle(this.createEvent("end", { trigger: event2 }));
          this.#clipEnded = false;
        }, 0);
      }
      this.#resetTracking();
    }
    ["time-change"](event2) {
      if (this.#request.looping) {
        event2.stopImmediatePropagation();
        return;
      }
      let { waiting, played, clipEndTime, realCurrentTime, currentTime } = this.$state, newTime = event2.detail, endTime = clipEndTime();
      realCurrentTime.set(newTime);
      this.#updatePlayed();
      waiting.set(false);
      for (const track of this.#media.textTracks) {
        track[TextTrackSymbol.updateActiveCues](newTime, event2);
      }
      if (endTime > 0 && newTime >= endTime) {
        this.#clipEnded = true;
        this.dispatch("media-pause-request", { trigger: event2 });
      }
      this.#saveTime();
      this.dispatch("time-update", {
        detail: { currentTime: currentTime(), played: played() },
        trigger: event2
      });
    }
    #updatePlayed() {
      const { currentTime, played, paused } = this.$state;
      if (paused())
        return;
      this.#playedInterval = updateTimeIntervals(
        this.#playedIntervals,
        this.#playedInterval,
        currentTime()
      );
      played.set(new TimeRange(this.#playedIntervals));
    }
    // Called to update time again incase duration precision has changed.
    #onEndPrecisionChange(trigger) {
      const { clipStartTime, clipEndTime, duration } = this.$state, isClipped = clipStartTime() > 0 || clipEndTime() > 0;
      if (isClipped)
        return;
      this.handle(
        this.createEvent("time-change", {
          detail: duration(),
          trigger
        })
      );
    }
    #saveTime() {
      const { storage } = this.#media, { canPlay, realCurrentTime } = this.$state;
      if (canPlay()) {
        storage?.setTime?.(realCurrentTime());
      }
    }
    ["audio-gain-change"](event2) {
      const { storage } = this.#media, { canPlay, audioGain } = this.$state;
      audioGain.set(event2.detail);
      this.#satisfyRequest("media-audio-gain-change-request", event2);
      if (canPlay())
        storage?.setAudioGain?.(audioGain());
    }
    ["volume-change"](event2) {
      const { storage } = this.#media, { volume, muted, canPlay } = this.$state, detail = event2.detail;
      volume.set(detail.volume);
      muted.set(detail.muted || detail.volume === 0);
      this.#satisfyRequest("media-volume-change-request", event2);
      this.#satisfyRequest(detail.muted ? "media-mute-request" : "media-unmute-request", event2);
      if (canPlay()) {
        storage?.setVolume?.(volume());
        storage?.setMuted?.(muted());
      }
    }
    ["seeking"] = functionThrottle(
      (event2) => {
        const { seeking, realCurrentTime, paused } = this.$state;
        seeking.set(true);
        realCurrentTime.set(event2.detail);
        this.#satisfyRequest("media-seeking-request", event2);
        if (paused()) {
          this.#waitingTrigger = event2;
          this.#fireWaiting();
        }
        this.#playedInterval = [-1, -1];
      },
      150,
      { leading: true }
    );
    ["seeked"](event2) {
      const { seeking, currentTime, realCurrentTime, paused, seekableEnd, ended } = this.$state;
      if (this.#request.seeking) {
        seeking.set(true);
        event2.stopImmediatePropagation();
      } else if (seeking()) {
        const waitingEvent = this.#trackedEvents.get("waiting");
        if (waitingEvent)
          event2.triggers.add(waitingEvent);
        const seekingEvent = this.#trackedEvents.get("seeking");
        if (seekingEvent && !event2.triggers.has(seekingEvent)) {
          event2.triggers.add(seekingEvent);
        }
        if (paused())
          this.#stopWaiting();
        seeking.set(false);
        realCurrentTime.set(event2.detail);
        this.#satisfyRequest("media-seek-request", event2);
        const origin = event2?.originEvent;
        if (origin?.isTrusted && !(origin instanceof MessageEvent) && !/seek/.test(origin.type)) {
          this["started"](event2);
        }
      }
      if (Math.floor(currentTime()) !== Math.floor(seekableEnd())) {
        ended.set(false);
      } else {
        this.end(event2);
      }
    }
    ["waiting"](event2) {
      if (this.#firingWaiting || this.#request.seeking)
        return;
      event2.stopImmediatePropagation();
      this.#waitingTrigger = event2;
      this.#fireWaiting();
    }
    #fireWaiting = functionDebounce(() => {
      if (!this.#waitingTrigger)
        return;
      this.#firingWaiting = true;
      const { waiting, playing } = this.$state;
      waiting.set(true);
      playing.set(false);
      const event2 = this.createEvent("waiting", { trigger: this.#waitingTrigger });
      this.#trackedEvents.set("waiting", event2);
      this.dispatch(event2);
      this.#waitingTrigger = void 0;
      this.#firingWaiting = false;
    }, 300);
    ["end"](event2) {
      const { loop: loop2, ended } = this.$state;
      if (!loop2() && ended())
        return;
      if (loop2()) {
        setTimeout(() => {
          requestAnimationFrame(() => {
            this.#resetPlaybackIfNeeded(event2);
            this.dispatch("media-loop-request", { trigger: event2 });
          });
        }, 10);
        return;
      }
      setTimeout(() => this.#onEnded(event2), 0);
    }
    #onEnded(event2) {
      const { storage } = this.#media, { paused, seeking, ended, duration } = this.$state;
      this.#onEndPrecisionChange(event2);
      if (!paused()) {
        this.dispatch("pause", { trigger: event2 });
      }
      if (seeking()) {
        this.dispatch("seeked", {
          detail: duration(),
          trigger: event2
        });
      }
      ended.set(true);
      this.#resetTracking();
      storage?.setTime?.(duration(), true);
      this.dispatch("ended", {
        trigger: event2
      });
    }
    #stopWaiting() {
      this.#fireWaiting.cancel();
      this.$state.waiting.set(false);
    }
    ["fullscreen-change"](event2) {
      const isFullscreen2 = event2.detail;
      this.$state.fullscreen.set(isFullscreen2);
      this.#satisfyRequest(
        isFullscreen2 ? "media-enter-fullscreen-request" : "media-exit-fullscreen-request",
        event2
      );
    }
    ["fullscreen-error"](event2) {
      this.#satisfyRequest("media-enter-fullscreen-request", event2);
      this.#satisfyRequest("media-exit-fullscreen-request", event2);
    }
    ["orientation-change"](event2) {
      const isLocked = event2.detail.lock;
      this.#satisfyRequest(
        isLocked ? "media-orientation-lock-request" : "media-orientation-unlock-request",
        event2
      );
    }
    ["picture-in-picture-change"](event2) {
      const isPiP = event2.detail;
      this.$state.pictureInPicture.set(isPiP);
      this.#satisfyRequest(isPiP ? "media-enter-pip-request" : "media-exit-pip-request", event2);
    }
    ["picture-in-picture-error"](event2) {
      this.#satisfyRequest("media-enter-pip-request", event2);
      this.#satisfyRequest("media-exit-pip-request", event2);
    }
    ["title-change"](event2) {
      if (!event2.trigger)
        return;
      event2.stopImmediatePropagation();
      this.$state.inferredTitle.set(event2.detail);
    }
    ["poster-change"](event2) {
      if (!event2.trigger)
        return;
      event2.stopImmediatePropagation();
      this.$state.inferredPoster.set(event2.detail);
    }
  };
  var MediaStateSync = class extends MediaPlayerController {
    onSetup() {
      this.#init();
      const effects2 = [
        this.#watchMetadata,
        this.#watchAutoplay,
        this.#watchClipStartTime,
        this.#watchClipEndTime,
        this.#watchControls,
        this.#watchCrossOrigin,
        this.#watchDuration,
        this.#watchLive,
        this.#watchLiveEdge,
        this.#watchLiveTolerance,
        this.#watchLoop,
        this.#watchPlaysInline,
        this.#watchPoster,
        this.#watchProvidedTypes,
        this.#watchTitle
      ];
      for (const callback of effects2) {
        effect(callback.bind(this));
      }
    }
    #init() {
      const providedProps = {
        duration: "providedDuration",
        loop: "providedLoop",
        poster: "providedPoster",
        streamType: "providedStreamType",
        title: "providedTitle",
        viewType: "providedViewType"
      };
      const skip = /* @__PURE__ */ new Set([
        "currentTime",
        "paused",
        "playbackRate",
        "volume"
      ]);
      for (const prop2 of Object.keys(this.$props)) {
        if (skip.has(prop2))
          continue;
        this.$state[providedProps[prop2] ?? prop2]?.set(this.$props[prop2]());
      }
      this.$state.muted.set(this.$props.muted() || this.$props.volume() === 0);
    }
    // Sync "provided" props with internal state. Provided props are used to differentiate from
    // provider inferred values.
    #watchProvidedTypes() {
      const { viewType, streamType, title, poster, loop: loop2 } = this.$props, $state = this.$state;
      $state.providedPoster.set(poster());
      $state.providedStreamType.set(streamType());
      $state.providedViewType.set(viewType());
      $state.providedTitle.set(title());
      $state.providedLoop.set(loop2());
    }
    #watchLogLevel() {
      return;
    }
    #watchMetadata() {
      const { artist, artwork } = this.$props;
      this.$state.artist.set(artist());
      this.$state.artwork.set(artwork());
    }
    #watchTitle() {
      const { title } = this.$state;
      this.dispatch("title-change", { detail: title() });
    }
    #watchAutoplay() {
      const autoPlay = this.$props.autoPlay() || this.$props.autoplay();
      this.$state.autoPlay.set(autoPlay);
      this.dispatch("auto-play-change", { detail: autoPlay });
    }
    #watchLoop() {
      const loop2 = this.$state.loop();
      this.dispatch("loop-change", { detail: loop2 });
    }
    #watchControls() {
      const controls = this.$props.controls();
      this.$state.controls.set(controls);
    }
    #watchPoster() {
      const { poster } = this.$state;
      this.dispatch("poster-change", { detail: poster() });
    }
    #watchCrossOrigin() {
      const crossOrigin = this.$props.crossOrigin() ?? this.$props.crossorigin(), value = crossOrigin === true ? "" : crossOrigin;
      this.$state.crossOrigin.set(value);
    }
    #watchDuration() {
      const { duration } = this.$props;
      this.dispatch("media-duration-change-request", {
        detail: duration()
      });
    }
    #watchPlaysInline() {
      const inline2 = this.$props.playsInline() || this.$props.playsinline();
      this.$state.playsInline.set(inline2);
      this.dispatch("plays-inline-change", { detail: inline2 });
    }
    #watchClipStartTime() {
      const { clipStartTime } = this.$props;
      this.dispatch("media-clip-start-change-request", {
        detail: clipStartTime()
      });
    }
    #watchClipEndTime() {
      const { clipEndTime } = this.$props;
      this.dispatch("media-clip-end-change-request", {
        detail: clipEndTime()
      });
    }
    #watchLive() {
      this.dispatch("live-change", { detail: this.$state.live() });
    }
    #watchLiveTolerance() {
      this.$state.liveEdgeTolerance.set(this.$props.liveEdgeTolerance());
      this.$state.minLiveDVRWindow.set(this.$props.minLiveDVRWindow());
    }
    #watchLiveEdge() {
      this.dispatch("live-edge-change", { detail: this.$state.liveEdge() });
    }
  };
  var actions = ["play", "pause", "seekforward", "seekbackward", "seekto"];
  var NavigatorMediaSession = class extends MediaPlayerController {
    onConnect() {
      effect(this.#onMetadataChange.bind(this));
      effect(this.#onPlaybackStateChange.bind(this));
      const handleAction = this.#handleAction.bind(this);
      for (const action of actions) {
        navigator.mediaSession.setActionHandler(action, handleAction);
      }
      onDispose(this.#onDisconnect.bind(this));
    }
    #onDisconnect() {
      for (const action of actions) {
        navigator.mediaSession.setActionHandler(action, null);
      }
    }
    #onMetadataChange() {
      const { title, artist, artwork, poster } = this.$state;
      navigator.mediaSession.metadata = new MediaMetadata({
        title: title(),
        artist: artist(),
        artwork: artwork() ?? [{ src: poster() }]
      });
    }
    #onPlaybackStateChange() {
      const { canPlay, paused } = this.$state;
      navigator.mediaSession.playbackState = !canPlay() ? "none" : paused() ? "paused" : "playing";
    }
    #handleAction(details) {
      const trigger = new DOMEvent(`media-session-action`, { detail: details });
      switch (details.action) {
        case "play":
          this.dispatch("media-play-request", { trigger });
          break;
        case "pause":
          this.dispatch("media-pause-request", { trigger });
          break;
        case "seekto":
        case "seekforward":
        case "seekbackward":
          this.dispatch("media-seek-request", {
            detail: isNumber(details.seekTime) ? details.seekTime : this.$state.currentTime() + (details.seekOffset ?? (details.action === "seekforward" ? 10 : -10)),
            trigger
          });
          break;
      }
    }
  };
  var MediaPlayer = class _MediaPlayer extends Component {
    static props = mediaPlayerProps;
    static state = mediaState;
    #media;
    #stateMgr;
    #requestMgr;
    canPlayQueue = new RequestQueue();
    remoteControl;
    get #provider() {
      return this.#media.$provider();
    }
    get #props() {
      return this.$props;
    }
    constructor() {
      super();
      new MediaStateSync();
      const context3 = {
        player: this,
        qualities: new VideoQualityList(),
        audioTracks: new AudioTrackList(),
        storage: null,
        $provider: signal(null),
        $providerSetup: signal(false),
        $props: this.$props,
        $state: this.$state
      };
      context3.remote = this.remoteControl = new MediaRemoteControl(
        void 0
      );
      context3.remote.setPlayer(this);
      context3.textTracks = new TextTrackList();
      context3.textTracks[TextTrackSymbol.crossOrigin] = this.$state.crossOrigin;
      context3.textRenderers = new TextRenderers(context3);
      context3.ariaKeys = {};
      this.#media = context3;
      provideContext(mediaContext, context3);
      this.orientation = new ScreenOrientationController();
      new FocusVisibleController();
      new MediaKeyboardController(context3);
      const request = new MediaRequestContext();
      this.#stateMgr = new MediaStateManager(request, context3);
      this.#requestMgr = new MediaRequestManager(this.#stateMgr, request, context3);
      context3.delegate = new MediaPlayerDelegate(this.#stateMgr.handle.bind(this.#stateMgr), context3);
      context3.notify = context3.delegate.notify.bind(context3.delegate);
      if (typeof navigator !== "undefined" && "mediaSession" in navigator) {
        new NavigatorMediaSession();
      }
      new MediaLoadController("load", this.startLoading.bind(this));
      new MediaLoadController("posterLoad", this.startLoadingPoster.bind(this));
    }
    onSetup() {
      this.#setupMediaAttributes();
      effect(this.#watchCanPlay.bind(this));
      effect(this.#watchMuted.bind(this));
      effect(this.#watchPaused.bind(this));
      effect(this.#watchVolume.bind(this));
      effect(this.#watchCurrentTime.bind(this));
      effect(this.#watchPlaysInline.bind(this));
      effect(this.#watchPlaybackRate.bind(this));
    }
    onAttach(el) {
      el.setAttribute("data-media-player", "");
      setAttributeIfEmpty(el, "tabindex", "0");
      setAttributeIfEmpty(el, "role", "region");
      effect(this.#watchStorage.bind(this));
      effect(this.#watchTitle.bind(this));
      effect(this.#watchOrientation.bind(this));
      listenEvent(el, "find-media-player", this.#onFindPlayer.bind(this));
    }
    onConnect(el) {
      if (IS_IPHONE)
        setAttribute(el, "data-iphone", "");
      const pointerQuery = window.matchMedia("(pointer: coarse)");
      this.#onPointerChange(pointerQuery);
      pointerQuery.onchange = this.#onPointerChange.bind(this);
      const resize = new ResizeObserver(animationFrameThrottle(this.#onResize.bind(this)));
      resize.observe(el);
      effect(this.#onResize.bind(this));
      this.dispatch("media-player-connect", {
        detail: this,
        bubbles: true,
        composed: true
      });
      onDispose(() => {
        resize.disconnect();
        pointerQuery.onchange = null;
      });
    }
    onDestroy() {
      this.#media.player = null;
      this.canPlayQueue.reset();
    }
    #skipTitleUpdate = false;
    #watchTitle() {
      const el = this.$el, { title, live, viewType, providedTitle } = this.$state, isLive = live(), type = uppercaseFirstChar(viewType()), typeText = type !== "Unknown" ? `${isLive ? "Live " : ""}${type}` : isLive ? "Live" : "Media", currentTitle = title();
      setAttribute(
        this.el,
        "aria-label",
        `${typeText} Player` + (currentTitle ? ` - ${currentTitle}` : "")
      );
      if (el?.hasAttribute("title")) {
        this.#skipTitleUpdate = true;
        el?.removeAttribute("title");
      }
    }
    #watchOrientation() {
      const orientation = this.orientation.landscape ? "landscape" : "portrait";
      this.$state.orientation.set(orientation);
      setAttribute(this.el, "data-orientation", orientation);
      this.#onResize();
    }
    #watchCanPlay() {
      if (this.$state.canPlay() && this.#provider)
        this.canPlayQueue.start();
      else
        this.canPlayQueue.stop();
    }
    #setupMediaAttributes() {
      if (_MediaPlayer[MEDIA_ATTRIBUTES]) {
        this.setAttributes(_MediaPlayer[MEDIA_ATTRIBUTES]);
        return;
      }
      const $attrs = {
        "data-load": function() {
          return this.$props.load();
        },
        "data-captions": function() {
          const track = this.$state.textTrack();
          return !!track && isTrackCaptionKind(track);
        },
        "data-ios-controls": function() {
          return this.$state.iOSControls();
        },
        "data-controls": function() {
          return this.controls.showing;
        },
        "data-buffering": function() {
          const { canLoad, canPlay, waiting } = this.$state;
          return canLoad() && (!canPlay() || waiting());
        },
        "data-error": function() {
          const { error } = this.$state;
          return !!error();
        },
        "data-autoplay-error": function() {
          const { autoPlayError } = this.$state;
          return !!autoPlayError();
        }
      };
      const alias = {
        autoPlay: "autoplay",
        canAirPlay: "can-airplay",
        canPictureInPicture: "can-pip",
        pictureInPicture: "pip",
        playsInline: "playsinline",
        remotePlaybackState: "remote-state",
        remotePlaybackType: "remote-type",
        isAirPlayConnected: "airplay",
        isGoogleCastConnected: "google-cast"
      };
      for (const prop2 of mediaAttributes) {
        const attrName = "data-" + (alias[prop2] ?? camelToKebabCase(prop2));
        $attrs[attrName] = function() {
          return this.$state[prop2]();
        };
      }
      delete $attrs.title;
      _MediaPlayer[MEDIA_ATTRIBUTES] = $attrs;
      this.setAttributes($attrs);
    }
    #onFindPlayer(event2) {
      event2.detail(this);
    }
    #onResize() {
      if (!this.el)
        return;
      const width = this.el.clientWidth, height = this.el.clientHeight;
      this.$state.width.set(width);
      this.$state.height.set(height);
      setStyle(this.el, "--player-width", width + "px");
      setStyle(this.el, "--player-height", height + "px");
    }
    #onPointerChange(queryList) {
      const pointer = queryList.matches ? "coarse" : "fine";
      setAttribute(this.el, "data-pointer", pointer);
      this.$state.pointer.set(pointer);
      this.#onResize();
    }
    /**
     * The current media provider.
     */
    get provider() {
      return this.#provider;
    }
    /**
     * Media controls settings.
     */
    get controls() {
      return this.#requestMgr.controls;
    }
    set controls(controls) {
      this.#props.controls.set(controls);
    }
    /**
     * Controls the screen orientation of the current browser window and dispatches orientation
     * change events on the player.
     */
    orientation;
    /**
     * The title of the current media.
     */
    get title() {
      return peek(this.$state.title);
    }
    set title(newTitle) {
      if (this.#skipTitleUpdate) {
        this.#skipTitleUpdate = false;
        return;
      }
      this.#props.title.set(newTitle);
    }
    /**
     * A list of all `VideoQuality` objects representing the set of available video renditions.
     *
     * @see {@link https://vidstack.io/docs/player/api/video-quality}
     */
    get qualities() {
      return this.#media.qualities;
    }
    /**
     * A list of all `AudioTrack` objects representing the set of available audio tracks.
     *
     * @see {@link https://vidstack.io/docs/player/api/audio-tracks}
     */
    get audioTracks() {
      return this.#media.audioTracks;
    }
    /**
     * A list of all `TextTrack` objects representing the set of available text tracks.
     *
     * @see {@link https://vidstack.io/docs/player/api/text-tracks}
     */
    get textTracks() {
      return this.#media.textTracks;
    }
    /**
     * Contains text renderers which are responsible for loading, parsing, and rendering text
     * tracks.
     */
    get textRenderers() {
      return this.#media.textRenderers;
    }
    get duration() {
      return this.$state.duration();
    }
    set duration(duration) {
      this.#props.duration.set(duration);
    }
    get paused() {
      return peek(this.$state.paused);
    }
    set paused(paused) {
      this.#queuePausedUpdate(paused);
    }
    #watchPaused() {
      this.#queuePausedUpdate(this.$props.paused());
    }
    #queuePausedUpdate(paused) {
      if (paused) {
        this.canPlayQueue.enqueue("paused", () => this.#requestMgr.pause());
      } else
        this.canPlayQueue.enqueue("paused", () => this.#requestMgr.play());
    }
    get muted() {
      return peek(this.$state.muted);
    }
    set muted(muted) {
      this.#queueMutedUpdate(muted);
    }
    #watchMuted() {
      this.#queueMutedUpdate(this.$props.muted());
    }
    #queueMutedUpdate(muted) {
      this.canPlayQueue.enqueue("muted", () => {
        if (this.#provider)
          this.#provider.setMuted(muted);
      });
    }
    get currentTime() {
      return peek(this.$state.currentTime);
    }
    set currentTime(time) {
      this.#queueCurrentTimeUpdate(time);
    }
    #watchCurrentTime() {
      this.#queueCurrentTimeUpdate(this.$props.currentTime());
    }
    #queueCurrentTimeUpdate(time) {
      this.canPlayQueue.enqueue("currentTime", () => {
        const { currentTime, clipStartTime, seekableStart, seekableEnd } = this.$state;
        if (time === peek(currentTime))
          return;
        peek(() => {
          if (!this.#provider)
            return;
          const clippedTime = time + clipStartTime(), isStart = Math.floor(time) === Math.floor(seekableStart()), isEnd = Math.floor(clippedTime) === Math.floor(seekableEnd()), boundTime = isStart ? seekableStart() : isEnd ? seekableEnd() : Math.min(Math.max(seekableStart() + 0.1, clippedTime), seekableEnd() - 0.1);
          if (Number.isFinite(boundTime)) {
            this.#provider.setCurrentTime(boundTime);
          }
        });
      });
    }
    get volume() {
      return peek(this.$state.volume);
    }
    set volume(volume) {
      this.#queueVolumeUpdate(volume);
    }
    #watchVolume() {
      this.#queueVolumeUpdate(this.$props.volume());
    }
    #queueVolumeUpdate(volume) {
      const clampedVolume = clampNumber(0, volume, 1);
      this.canPlayQueue.enqueue("volume", () => {
        if (this.#provider)
          this.#provider.setVolume(clampedVolume);
      });
    }
    get playbackRate() {
      return peek(this.$state.playbackRate);
    }
    set playbackRate(rate) {
      this.#queuePlaybackRateUpdate(rate);
    }
    #watchPlaybackRate() {
      this.#queuePlaybackRateUpdate(this.$props.playbackRate());
    }
    #queuePlaybackRateUpdate(rate) {
      this.canPlayQueue.enqueue("rate", () => {
        if (this.#provider)
          this.#provider.setPlaybackRate?.(rate);
      });
    }
    #watchPlaysInline() {
      this.#queuePlaysInlineUpdate(this.$props.playsInline());
    }
    #queuePlaysInlineUpdate(inline2) {
      this.canPlayQueue.enqueue("playsinline", () => {
        if (this.#provider)
          this.#provider.setPlaysInline?.(inline2);
      });
    }
    #watchStorage() {
      let storageValue = this.$props.storage(), storage = isString(storageValue) ? new LocalMediaStorage() : storageValue;
      if (storage?.onChange) {
        const { source } = this.$state, playerId = isString(storageValue) ? storageValue : this.el?.id, mediaId = computed(this.#computeMediaId.bind(this));
        effect(() => storage.onChange(source(), mediaId(), playerId || void 0));
      }
      this.#media.storage = storage;
      this.#media.textTracks.setStorage(storage);
      onDispose(() => {
        storage?.onDestroy?.();
        this.#media.storage = null;
        this.#media.textTracks.setStorage(null);
      });
    }
    #computeMediaId() {
      const { clipStartTime, clipEndTime } = this.$props, { source } = this.$state, src = source();
      return src.src ? `${src.src}:${clipStartTime()}:${clipEndTime()}` : null;
    }
    /**
     * Begins/resumes playback of the media. If this method is called programmatically before the
     * user has interacted with the player, the promise may be rejected subject to the browser's
     * autoplay policies. This method will throw if called before media is ready for playback.
     *
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/play}
     */
    async play(trigger) {
      return this.#requestMgr.play(trigger);
    }
    /**
     * Pauses playback of the media. This method will throw if called before media is ready for
     * playback.
     *
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/pause}
     */
    async pause(trigger) {
      return this.#requestMgr.pause(trigger);
    }
    /**
     * Attempts to display the player in fullscreen. The promise will resolve if successful, and
     * reject if not. This method will throw if any fullscreen API is _not_ currently available.
     *
     * @see {@link https://vidstack.io/docs/player/api/fullscreen}
     */
    async enterFullscreen(target, trigger) {
      return this.#requestMgr.enterFullscreen(target, trigger);
    }
    /**
     * Attempts to display the player inline by exiting fullscreen. This method will throw if any
     * fullscreen API is _not_ currently available.
     *
     * @see {@link https://vidstack.io/docs/player/api/fullscreen}
     */
    async exitFullscreen(target, trigger) {
      return this.#requestMgr.exitFullscreen(target, trigger);
    }
    /**
     * Attempts to display the player in picture-in-picture mode. This method will throw if PIP is
     * not supported. This method will also return a `PictureInPictureWindow` if the current
     * provider supports it.
     *
     * @see {@link https://vidstack.io/docs/player/api/picture-in-picture}
     */
    enterPictureInPicture(trigger) {
      return this.#requestMgr.enterPictureInPicture(trigger);
    }
    /**
     * Attempts to display the player in inline by exiting picture-in-picture mode. This method
     * will throw if not supported.
     *
     * @see {@link https://vidstack.io/docs/player/api/picture-in-picture}
     */
    exitPictureInPicture(trigger) {
      return this.#requestMgr.exitPictureInPicture(trigger);
    }
    /**
     * Sets the current time to the live edge (i.e., `duration`). This is a no-op for non-live
     * streams and will throw if called before media is ready for playback.
     *
     * @see {@link https://vidstack.io/docs/player/api/live}
     */
    seekToLiveEdge(trigger) {
      this.#requestMgr.seekToLiveEdge(trigger);
    }
    /**
     * Called when media can begin loading. Calling this method will trigger the initial provider
     * loading process. Calling it more than once has no effect.
     *
     * @see {@link https://vidstack.io/docs/player/core-concepts/loading#load-strategies}
     */
    startLoading(trigger) {
      this.#media.notify("can-load", void 0, trigger);
    }
    /**
     * Called when the poster image can begin loading. Calling it more than once has no effect.
     *
     * @see {@link https://vidstack.io/docs/player/core-concepts/loading#load-strategies}
     */
    startLoadingPoster(trigger) {
      this.#media.notify("can-load-poster", void 0, trigger);
    }
    /**
     * Request Apple AirPlay picker to open.
     */
    requestAirPlay(trigger) {
      return this.#requestMgr.requestAirPlay(trigger);
    }
    /**
     * Request Google Cast device picker to open. The Google Cast framework will be loaded if it
     * hasn't yet.
     */
    requestGoogleCast(trigger) {
      return this.#requestMgr.requestGoogleCast(trigger);
    }
    /**
     * Set the audio gain, amplifying volume and enabling a maximum volume above 100%.
     *
     * @see {@link https://vidstack.io/docs/player/api/audio-gain}
     */
    setAudioGain(gain, trigger) {
      return this.#requestMgr.setAudioGain(gain, trigger);
    }
    destroy() {
      super.destroy();
      this.#media.remote.setPlayer(null);
      this.dispatch("destroy");
    }
  };
  var mediaplayer__proto = MediaPlayer.prototype;
  prop(mediaplayer__proto, "canPlayQueue");
  prop(mediaplayer__proto, "remoteControl");
  prop(mediaplayer__proto, "provider");
  prop(mediaplayer__proto, "controls");
  prop(mediaplayer__proto, "orientation");
  prop(mediaplayer__proto, "title");
  prop(mediaplayer__proto, "qualities");
  prop(mediaplayer__proto, "audioTracks");
  prop(mediaplayer__proto, "textTracks");
  prop(mediaplayer__proto, "textRenderers");
  prop(mediaplayer__proto, "duration");
  prop(mediaplayer__proto, "paused");
  prop(mediaplayer__proto, "muted");
  prop(mediaplayer__proto, "currentTime");
  prop(mediaplayer__proto, "volume");
  prop(mediaplayer__proto, "playbackRate");
  method(mediaplayer__proto, "play");
  method(mediaplayer__proto, "pause");
  method(mediaplayer__proto, "enterFullscreen");
  method(mediaplayer__proto, "exitFullscreen");
  method(mediaplayer__proto, "enterPictureInPicture");
  method(mediaplayer__proto, "exitPictureInPicture");
  method(mediaplayer__proto, "seekToLiveEdge");
  method(mediaplayer__proto, "startLoading");
  method(mediaplayer__proto, "startLoadingPoster");
  method(mediaplayer__proto, "requestAirPlay");
  method(mediaplayer__proto, "requestGoogleCast");
  method(mediaplayer__proto, "setAudioGain");
  function resolveStreamTypeFromDASHManifest(manifestSrc, requestInit) {
    return fetch(manifestSrc, requestInit).then((res) => res.text()).then((manifest) => {
      return /type="static"/.test(manifest) ? "on-demand" : "live";
    });
  }
  function resolveStreamTypeFromHLSManifest(manifestSrc, requestInit) {
    return fetch(manifestSrc, requestInit).then((res) => res.text()).then((manifest) => {
      const renditionURI = resolveHLSRenditionURI(manifest);
      if (renditionURI) {
        return resolveStreamTypeFromHLSManifest(
          /^https?:/.test(renditionURI) ? renditionURI : new URL(renditionURI, manifestSrc).href,
          requestInit
        );
      }
      const streamType = /EXT-X-PLAYLIST-TYPE:\s*VOD/.test(manifest) ? "on-demand" : "live";
      if (streamType === "live" && resolveTargetDuration(manifest) >= 10 && (/#EXT-X-DVR-ENABLED:\s*true/.test(manifest) || manifest.includes("#EXT-X-DISCONTINUITY"))) {
        return "live:dvr";
      }
      return streamType;
    });
  }
  function resolveHLSRenditionURI(manifest) {
    const matches = manifest.match(/#EXT-X-STREAM-INF:[^\n]+(\n[^\n]+)*/g);
    return matches ? matches[0].split("\n")[1].trim() : null;
  }
  function resolveTargetDuration(manifest) {
    const lines = manifest.split("\n");
    for (const line of lines) {
      if (line.startsWith("#EXT-X-TARGETDURATION")) {
        const duration = parseFloat(line.split(":")[1]);
        if (!isNaN(duration)) {
          return duration;
        }
      }
    }
    return -1;
  }
  var sourceTypes = /* @__PURE__ */ new Map();
  var SourceSelection = class {
    #initialize = false;
    #loaders;
    #domSources;
    #media;
    #loader;
    constructor(domSources, media, loader, customLoaders = []) {
      this.#domSources = domSources;
      this.#media = media;
      this.#loader = loader;
      const DASH_LOADER = new DASHProviderLoader(), HLS_LOADER = new HLSProviderLoader(), VIDEO_LOADER = new VideoProviderLoader(), AUDIO_LOADER = new AudioProviderLoader(), YOUTUBE_LOADER = new YouTubeProviderLoader(), VIMEO_LOADER = new VimeoProviderLoader(), EMBED_LOADERS = [YOUTUBE_LOADER, VIMEO_LOADER];
      this.#loaders = computed(() => {
        const remoteLoader = media.$state.remotePlaybackLoader();
        const loaders = media.$props.preferNativeHLS() ? [VIDEO_LOADER, AUDIO_LOADER, DASH_LOADER, HLS_LOADER, ...EMBED_LOADERS, ...customLoaders] : [HLS_LOADER, VIDEO_LOADER, AUDIO_LOADER, DASH_LOADER, ...EMBED_LOADERS, ...customLoaders];
        return remoteLoader ? [remoteLoader, ...loaders] : loaders;
      });
      const { $state } = media;
      $state.sources.set(normalizeSrc(media.$props.src()));
      for (const src of $state.sources()) {
        const loader2 = this.#loaders().find((loader3) => loader3.canPlay(src));
        if (!loader2)
          continue;
        const mediaType = loader2.mediaType(src);
        media.$state.source.set(src);
        media.$state.mediaType.set(mediaType);
        media.$state.inferredViewType.set(mediaType);
        this.#loader.set(loader2);
        this.#initialize = true;
        break;
      }
    }
    connect() {
      const loader = this.#loader();
      if (this.#initialize) {
        this.#notifySourceChange(this.#media.$state.source(), loader);
        this.#notifyLoaderChange(loader);
        this.#initialize = false;
      }
      effect(this.#onSourcesChange.bind(this));
      effect(this.#onSourceChange.bind(this));
      effect(this.#onSetup.bind(this));
      effect(this.#onLoadSource.bind(this));
      effect(this.#onLoadPoster.bind(this));
    }
    #onSourcesChange() {
      this.#media.notify("sources-change", [
        ...normalizeSrc(this.#media.$props.src()),
        ...this.#domSources()
      ]);
    }
    #onSourceChange() {
      const { $state } = this.#media;
      const sources = $state.sources(), currentSource = peek($state.source), newSource = this.#findNewSource(currentSource, sources), noMatch = sources[0]?.src && !newSource.src && !newSource.type;
      if (noMatch) {
        const { crossOrigin } = $state, credentials = getRequestCredentials(crossOrigin()), abort = new AbortController();
        Promise.all(
          sources.map(
            (source) => isString(source.src) && source.type === "?" ? fetch(source.src, {
              method: "HEAD",
              credentials,
              signal: abort.signal
            }).then((res) => {
              source.type = res.headers.get("content-type") || "??";
              sourceTypes.set(source.src, source.type);
              return source;
            }).catch(() => source) : source
          )
        ).then((sources2) => {
          if (abort.signal.aborted)
            return;
          const newSource2 = this.#findNewSource(peek($state.source), sources2);
          tick();
          if (!newSource2.src) {
            this.#media.notify("error", {
              message: "Failed to load resource.",
              code: 4
            });
          }
        });
        return () => abort.abort();
      }
      tick();
    }
    #findNewSource(currentSource, sources) {
      let newSource = { src: "", type: "" }, newLoader = null, triggerEvent = new DOMEvent("sources-change", { detail: { sources } }), loaders = this.#loaders(), { started, paused, currentTime, quality, savedState } = this.#media.$state;
      for (const src of sources) {
        const loader = loaders.find((loader2) => loader2.canPlay(src));
        if (loader) {
          newSource = src;
          newLoader = loader;
          break;
        }
      }
      if (isVideoQualitySrc(newSource)) {
        const currentQuality = quality(), sourceQuality = sources.find((s5) => s5.src === currentQuality?.src);
        if (peek(started)) {
          savedState.set({
            paused: peek(paused),
            currentTime: peek(currentTime)
          });
        } else {
          savedState.set(null);
        }
        if (sourceQuality) {
          newSource = sourceQuality;
          triggerEvent = new DOMEvent("quality-change", {
            detail: { quality: currentQuality }
          });
        }
      }
      if (!isSameSrc(currentSource, newSource)) {
        this.#notifySourceChange(newSource, newLoader, triggerEvent);
      }
      if (newLoader !== peek(this.#loader)) {
        this.#notifyLoaderChange(newLoader, triggerEvent);
      }
      return newSource;
    }
    #notifySourceChange(src, loader, trigger) {
      this.#media.notify("source-change", src, trigger);
      this.#media.notify("media-type-change", loader?.mediaType(src) || "unknown", trigger);
    }
    #notifyLoaderChange(loader, trigger) {
      this.#media.$providerSetup.set(false);
      this.#media.notify("provider-change", null, trigger);
      loader && peek(() => loader.preconnect?.(this.#media));
      this.#loader.set(loader);
      this.#media.notify("provider-loader-change", loader, trigger);
    }
    #onSetup() {
      const provider = this.#media.$provider();
      if (!provider || peek(this.#media.$providerSetup))
        return;
      if (this.#media.$state.canLoad()) {
        scoped(() => provider.setup(), provider.scope);
        this.#media.$providerSetup.set(true);
        return;
      }
      peek(() => provider.preconnect?.());
    }
    #onLoadSource() {
      if (!this.#media.$providerSetup())
        return;
      const provider = this.#media.$provider(), source = this.#media.$state.source(), crossOrigin = peek(this.#media.$state.crossOrigin), preferNativeHLS = peek(this.#media.$props.preferNativeHLS);
      if (isSameSrc(provider?.currentSrc, source)) {
        return;
      }
      if (this.#media.$state.canLoad()) {
        const abort = new AbortController();
        if (isHLSSrc(source)) {
          if (preferNativeHLS || !isHLSSupported()) {
            resolveStreamTypeFromHLSManifest(source.src, {
              credentials: getRequestCredentials(crossOrigin),
              signal: abort.signal
            }).then((streamType) => {
              this.#media.notify("stream-type-change", streamType);
            }).catch(noop);
          }
        } else if (isDASHSrc(source)) {
          resolveStreamTypeFromDASHManifest(source.src, {
            credentials: getRequestCredentials(crossOrigin),
            signal: abort.signal
          }).then((streamType) => {
            this.#media.notify("stream-type-change", streamType);
          }).catch(noop);
        } else {
          this.#media.notify("stream-type-change", "on-demand");
        }
        peek(() => {
          const preload2 = peek(this.#media.$state.preload);
          return provider?.loadSource(source, preload2).catch((error) => {
          });
        });
        return () => abort.abort();
      }
      try {
        isString(source.src) && preconnect(new URL(source.src).origin);
      } catch (error) {
      }
    }
    #onLoadPoster() {
      const loader = this.#loader(), { providedPoster, source, canLoadPoster } = this.#media.$state;
      if (!loader || !loader.loadPoster || !source() || !canLoadPoster() || providedPoster())
        return;
      const abort = new AbortController(), trigger = new DOMEvent("source-change", { detail: source });
      loader.loadPoster(source(), this.#media, abort).then((url) => {
        this.#media.notify("poster-change", url || "", trigger);
      }).catch(() => {
        this.#media.notify("poster-change", "", trigger);
      });
      return () => {
        abort.abort();
      };
    }
  };
  function normalizeSrc(src) {
    return (isArray(src) ? src : [src]).map((src2) => {
      if (isString(src2)) {
        return { src: src2, type: inferType(src2) };
      } else {
        return { ...src2, type: inferType(src2.src, src2.type) };
      }
    });
  }
  function inferType(src, type) {
    if (isString(type) && type.length) {
      return type;
    } else if (isString(src) && sourceTypes.has(src)) {
      return sourceTypes.get(src);
    } else if (!type && isHLSSrc({ src, type: "" })) {
      return "application/x-mpegurl";
    } else if (!type && isDASHSrc({ src, type: "" })) {
      return "application/dash+xml";
    } else if (!isString(src) || src.startsWith("blob:")) {
      return "video/object";
    } else if (src.includes("youtube") || src.includes("youtu.be")) {
      return "video/youtube";
    } else if (src.includes("vimeo") && !src.includes("progressive_redirect") && !src.includes(".m3u8")) {
      return "video/vimeo";
    }
    return "?";
  }
  function isSameSrc(a4, b2) {
    return a4?.src === b2?.src && a4?.type === b2?.type;
  }
  var Tracks = class {
    #domTracks;
    #media;
    #prevTracks = [];
    constructor(domTracks, media) {
      this.#domTracks = domTracks;
      this.#media = media;
      effect(this.#onTracksChange.bind(this));
    }
    #onTracksChange() {
      const newTracks = this.#domTracks();
      for (const oldTrack of this.#prevTracks) {
        if (!newTracks.some((t6) => t6.id === oldTrack.id)) {
          const track = oldTrack.id && this.#media.textTracks.getById(oldTrack.id);
          if (track)
            this.#media.textTracks.remove(track);
        }
      }
      for (const newTrack of newTracks) {
        const id = newTrack.id || TextTrack.createId(newTrack);
        if (!this.#media.textTracks.getById(id)) {
          newTrack.id = id;
          this.#media.textTracks.add(newTrack);
        }
      }
      this.#prevTracks = newTracks;
    }
  };
  var MediaProvider = class extends Component {
    static props = {
      loaders: []
    };
    static state = new State({
      loader: null
    });
    #media;
    #sources;
    #domSources = signal([]);
    #domTracks = signal([]);
    #loader = null;
    onSetup() {
      this.#media = useMediaContext();
      this.#sources = new SourceSelection(
        this.#domSources,
        this.#media,
        this.$state.loader,
        this.$props.loaders()
      );
    }
    onAttach(el) {
      el.setAttribute("data-media-provider", "");
    }
    onConnect(el) {
      this.#sources.connect();
      new Tracks(this.#domTracks, this.#media);
      const resize = new ResizeObserver(animationFrameThrottle(this.#onResize.bind(this)));
      resize.observe(el);
      const mutations = new MutationObserver(this.#onMutation.bind(this));
      mutations.observe(el, { attributes: true, childList: true });
      this.#onResize();
      this.#onMutation();
      onDispose(() => {
        resize.disconnect();
        mutations.disconnect();
      });
    }
    #loadRafId = -1;
    load(target) {
      target?.setAttribute("aria-hidden", "true");
      window.cancelAnimationFrame(this.#loadRafId);
      this.#loadRafId = requestAnimationFrame(() => this.#runLoader(target));
      onDispose(() => {
        window.cancelAnimationFrame(this.#loadRafId);
      });
    }
    #runLoader(target) {
      if (!this.scope)
        return;
      const loader = this.$state.loader(), { $provider } = this.#media;
      if (this.#loader === loader && loader?.target === target && peek($provider))
        return;
      this.#destroyProvider();
      this.#loader = loader;
      if (loader)
        loader.target = target || null;
      if (!loader || !target)
        return;
      loader.load(this.#media).then((provider) => {
        if (!this.scope)
          return;
        if (peek(this.$state.loader) !== loader)
          return;
        this.#media.notify("provider-change", provider);
      });
    }
    onDestroy() {
      this.#loader = null;
      this.#destroyProvider();
    }
    #destroyProvider() {
      this.#media?.notify("provider-change", null);
    }
    #onResize() {
      if (!this.el)
        return;
      const { player, $state } = this.#media, width = this.el.offsetWidth, height = this.el.offsetHeight;
      if (!player)
        return;
      $state.mediaWidth.set(width);
      $state.mediaHeight.set(height);
      if (player.el) {
        setStyle(player.el, "--media-width", width + "px");
        setStyle(player.el, "--media-height", height + "px");
      }
    }
    #onMutation() {
      const sources = [], tracks = [], children = this.el.children;
      for (const el of children) {
        if (el.hasAttribute("data-vds"))
          continue;
        if (el instanceof HTMLSourceElement) {
          const src = {
            id: el.id,
            src: el.src,
            type: el.type
          };
          for (const prop2 of ["id", "src", "width", "height", "bitrate", "codec"]) {
            const value = el.getAttribute(`data-${prop2}`);
            if (isString(value))
              src[prop2] = /id|src|codec/.test(prop2) ? value : Number(value);
          }
          sources.push(src);
        } else if (el instanceof HTMLTrackElement) {
          const track = {
            src: el.src,
            kind: el.track.kind,
            language: el.srclang,
            label: el.label,
            default: el.default,
            type: el.getAttribute("data-type")
          };
          tracks.push({
            id: el.id || TextTrack.createId(track),
            ...track
          });
        }
      }
      this.#domSources.set(sources);
      this.#domTracks.set(tracks);
      tick();
    }
  };
  var mediaprovider__proto = MediaProvider.prototype;
  method(mediaprovider__proto, "load");

  // node_modules/.pnpm/vidstack@1.12.9/node_modules/vidstack/prod/chunks/vidstack-CN6CifQX.js
  init_vidstack_Cpte_fRf();
  var MediaProviderElement = class extends Host(HTMLElement, MediaProvider) {
    static tagName = "media-provider";
    #media;
    #target = null;
    #blocker = null;
    onSetup() {
      this.#media = useMediaContext();
      this.setAttribute("keep-alive", "");
    }
    onDestroy() {
      this.#blocker?.remove();
      this.#blocker = null;
      this.#target?.remove();
      this.#target = null;
    }
    onConnect() {
      effect(() => {
        const loader = this.$state.loader(), isYouTubeEmbed = loader?.name === "youtube", isVimeoEmbed = loader?.name === "vimeo", isEmbed = isYouTubeEmbed || isVimeoEmbed, isGoogleCast = loader?.name === "google-cast";
        const target = loader ? isGoogleCast ? this.#createGoogleCastContainer() : isEmbed ? this.#createIFrame() : loader.mediaType() === "audio" ? this.#createAudio() : this.#createVideo() : null;
        if (this.#target !== target) {
          const parent = this.#target?.parentElement ?? this;
          this.#target?.remove();
          this.#target = target;
          if (target)
            parent.prepend(target);
          if (isEmbed && target) {
            effect(() => {
              const { nativeControls, viewType } = this.#media.$state, showNativeControls = nativeControls(), isAudioView = viewType() === "audio", showBlocker = !showNativeControls && !isAudioView;
              if (showBlocker) {
                this.#blocker = this.querySelector(".vds-blocker");
                if (!this.#blocker) {
                  this.#blocker = document.createElement("div");
                  this.#blocker.classList.add("vds-blocker");
                  target.after(this.#blocker);
                }
              } else {
                this.#blocker?.remove();
                this.#blocker = null;
              }
              setAttribute(target, "data-no-controls", !showNativeControls);
            });
          }
        }
        if (isYouTubeEmbed)
          target?.classList.add("vds-youtube");
        else if (isVimeoEmbed)
          target?.classList.add("vds-vimeo");
        if (!isEmbed) {
          this.#blocker?.remove();
          this.#blocker = null;
        }
        this.load(target);
      });
    }
    #createAudio() {
      const audio = this.#target instanceof HTMLAudioElement ? this.#target : document.createElement("audio");
      const { controls, crossOrigin } = this.#media.$state;
      effect(() => {
        setAttribute(audio, "controls", controls());
        setAttribute(audio, "crossorigin", crossOrigin());
      });
      return audio;
    }
    #createVideo() {
      const video = this.#target instanceof HTMLVideoElement ? this.#target : document.createElement("video");
      const { crossOrigin, poster, nativeControls } = this.#media.$state, $controls = computed(() => nativeControls() ? "true" : null), $poster = computed(() => poster() && nativeControls() ? poster() : null);
      effect(() => {
        setAttribute(video, "controls", $controls());
        setAttribute(video, "crossorigin", crossOrigin());
        setAttribute(video, "poster", $poster());
      });
      return video;
    }
    #createIFrame() {
      const iframe = this.#target instanceof HTMLIFrameElement ? this.#target : document.createElement("iframe"), { nativeControls } = this.#media.$state;
      effect(() => setAttribute(iframe, "tabindex", !nativeControls() ? -1 : null));
      return iframe;
    }
    #createGoogleCastContainer() {
      if (this.#target?.classList.contains("vds-google-cast")) {
        return this.#target;
      }
      const container = document.createElement("div");
      container.classList.add("vds-google-cast");
      Promise.resolve().then(() => (init_vidstack_DJTshtlu(), vidstack_DJTshtlu_exports)).then(({ insertContent: insertContent2 }) => {
        insertContent2(container, this.#media.$state);
      });
      return container;
    }
  };
  var MediaPlayerElement = class extends Host(HTMLElement, MediaPlayer) {
    static tagName = "media-player";
    static attrs = {
      autoPlay: "autoplay",
      crossOrigin: "crossorigin",
      playsInline: "playsinline",
      preferNativeHLS: "prefer-native-hls",
      minLiveDVRWindow: "min-live-dvr-window"
    };
  };

  // node_modules/.pnpm/vidstack@1.12.9/node_modules/vidstack/prod/vidstack-elements.js
  init_vidstack_BOLMn4nu();
  init_lit_html();
  init_if_defined();
  init_unsafe_svg();
  init_async_directive();
  init_ref();
  init_keyed();
  init_unsafe_html();

  // node_modules/.pnpm/vidstack@1.12.9/node_modules/vidstack/prod/global/vidstack-player.js
  init_live_reload();

  // node_modules/.pnpm/vidstack@1.12.9/node_modules/vidstack/prod/define/vidstack-player.js
  init_live_reload();
  init_vidstack_CRlI3Mh7();
  defineCustomElement(MediaPlayerElement);
  defineCustomElement(MediaProviderElement);

  // node_modules/.pnpm/vidstack@1.12.9/node_modules/vidstack/prod/global/vidstack-player.js
  var LAYOUT_LOADED = Symbol();

  // src/videoSettings.ts
  function videoSettings() {
    defineCustomElement(MediaPlayButtonElement);
    const swiperMulti = new Swiper(".swiper-container.is-portfolio", {
      modules: [Navigation],
      slidesPerView: 3,
      slidesPerGroup: 1,
      grabCursor: false,
      a11y: false,
      autoHeight: false,
      allowTouchMove: true,
      followFinger: true,
      freeMode: false,
      lazy: true,
      keyboard: { enabled: true, onlyInViewport: true },
      navigation: {
        nextEl: "#right-button",
        prevEl: "#left-button"
      },
      breakpoints: {
        0: {
          /* when window >=0px - webflow mobile landscape/portriat */
          slidesPerView: 1,
          slidesPerGroup: 1,
          spaceBetween: 28
        },
        480: {
          /* when window >=0px - webflow mobile landscape/portriat */
          slidesPerView: 1,
          slidesPerGroup: 1,
          spaceBetween: 28,
          allowTouchMove: true
        },
        767: {
          /* when window >= 767px - webflow tablet */
          slidesPerView: 3,
          slidesPerGroup: 1,
          allowTouchMove: true,
          spaceBetween: 28
        },
        992: {
          /* when window >= 988px - webflow desktop */
          slidesPerView: 3,
          slidesPerGroup: 1,
          allowTouchMove: false,
          spaceBetween: 28
        }
      }
    });
    const video = document.querySelector("video");
    const videoVisual = document.querySelector(".video_visual");
    const leftHomeHero = document.querySelector(".left_home_hero");
    const playButton = document.querySelector("#play");
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
      navigator.userAgent
    );
    function toggleFullScreen(exit) {
      if (document.fullscreenElement && (video.ended || video.duration - video.currentTime <= 9.5) && exit) {
        document.exitFullscreen();
      }
    }
    function updateUI(isPlaying) {
      document.body.style.overflow = isPlaying ? "hidden" : "";
      document.body.setAttribute("element-theme", isPlaying ? "1" : "2");
      if (!isMobile) {
        videoVisual.classList.toggle("full", isPlaying);
        leftHomeHero.classList.toggle("video_play", isPlaying);
      }
      playButton.textContent = isPlaying ? "\u23F8 Pausar" : "\u25B6 Assistir";
    }
    function setupVideoControls() {
      if (!video || !videoVisual || !leftHomeHero || !playButton)
        return;
      let hasReached35Seconds = false;
      let isPlaying = false;
      video.addEventListener("play", () => {
        if (!hasReached35Seconds) {
          isPlaying = true;
          updateUI(isPlaying);
        }
      });
      video.addEventListener("pause", () => {
        isPlaying = false;
        updateUI(isPlaying);
      });
      video.addEventListener("ended", () => {
        isPlaying = false;
        updateUI(isPlaying);
        video.currentTime = 0;
        hasReached35Seconds = false;
      });
      video.addEventListener("timeupdate", () => {
        toggleFullScreen(true);
        if (video.currentTime >= 36 && !hasReached35Seconds) {
          hasReached35Seconds = true;
          isPlaying = false;
          updateUI(isPlaying);
        }
      });
      document.addEventListener("fullscreenchange", () => toggleFullScreen(false));
      playButton.addEventListener("click", () => {
        if (!hasReached35Seconds) {
          if (isPlaying) {
            video.pause();
          } else {
            video.play();
          }
          isPlaying = !isPlaying;
          updateUI(isPlaying);
        }
      });
    }
    setupVideoControls();
  }

  // src/index.ts
  initializeformCode();
  videoSettings();
  initializeMarqueeAnimation();
  initializeScrollEffect();
  initializedragEffect();
  initializeglobalCode();
})();
/*! Bundled license information:

sticksy/src/sticksy.js:
  (**
   * Sticksy.js
   * A library for making cool things like fixed widgets.
   * Dependency-free. ES5 code.
   * -
   * @version 0.2.0
   * @url https://github.com/kovart/sticksy
   * @author Artem Kovalchuk <kovart.dev@gmail.com>
   * @license The MIT License (MIT)
   *)

lit-html/lit-html.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directives/if-defined.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directive.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directives/unsafe-html.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directives/unsafe-svg.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directive-helpers.js:
  (**
   * @license
   * Copyright 2020 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/async-directive.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directives/ref.js:
  (**
   * @license
   * Copyright 2020 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directives/keyed.js:
  (**
   * @license
   * Copyright 2021 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

gsap/gsap-core.js:
  (*!
   * GSAP 3.12.5
   * https://gsap.com
   *
   * @license Copyright 2008-2024, GreenSock. All rights reserved.
   * Subject to the terms at https://gsap.com/standard-license or for
   * Club GSAP members, the agreement issued with that membership.
   * @author: Jack Doyle, jack@greensock.com
  *)

gsap/CSSPlugin.js:
  (*!
   * CSSPlugin 3.12.5
   * https://gsap.com
   *
   * Copyright 2008-2024, GreenSock. All rights reserved.
   * Subject to the terms at https://gsap.com/standard-license or for
   * Club GSAP members, the agreement issued with that membership.
   * @author: Jack Doyle, jack@greensock.com
  *)

mouse-follower/dist/index.module.js:
  (*!
   * Cuberto Mouse Follower
   * https://cuberto.com/
   *
   * @version 1.1.2
   * @author Cuberto, Artem Dordzhiev (Draft)
   *)

gsap/ScrollToPlugin.js:
  (*!
   * ScrollToPlugin 3.12.5
   * https://gsap.com
   *
   * @license Copyright 2008-2024, GreenSock. All rights reserved.
   * Subject to the terms at https://gsap.com/standard-license or for
   * Club GSAP members, the agreement issued with that membership.
   * @author: Jack Doyle, jack@greensock.com
  *)

gsap/Observer.js:
  (*!
   * Observer 3.12.5
   * https://gsap.com
   *
   * @license Copyright 2008-2024, GreenSock. All rights reserved.
   * Subject to the terms at https://gsap.com/standard-license or for
   * Club GSAP members, the agreement issued with that membership.
   * @author: Jack Doyle, jack@greensock.com
  *)

gsap/ScrollTrigger.js:
  (*!
   * ScrollTrigger 3.12.5
   * https://gsap.com
   *
   * @license Copyright 2008-2024, GreenSock. All rights reserved.
   * Subject to the terms at https://gsap.com/standard-license or for
   * Club GSAP members, the agreement issued with that membership.
   * @author: Jack Doyle, jack@greensock.com
  *)
*/
//# sourceMappingURL=index.js.map
